------- FILE c:\Users\Jag\Desktop\github\Nibiru Reaction-Atari2600\Nibiru Reaction 22-11-30.bas.asm LEVEL 1 PASS 3
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????				      processor	6502
------- FILE vcs.h LEVEL 2 PASS 3
      0  8400 ????				      include	"vcs.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????						; VCS.H
      4  8400 ????						; Version 1.05, 13/November/2003
      5  8400 ????
      6  8400 ????	       00 69	   VERSION_VCS =	105
      7  8400 ????
      8  8400 ????						; THIS IS A PRELIMINARY RELEASE OF *THE* "STANDARD" VCS.H
      9  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE THIS FILE!
     11  8400 ????						;
     12  8400 ????						; This file defines hardware registers and memory mapping for the
     13  8400 ????						; Atari 2600. It is distributed as a companion machine-specific support package
     14  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  8400 ????						; available at at http://www.atari2600.org/dasm
     16  8400 ????						;
     17  8400 ????						; Many thanks to the original author(s) of this file, and to everyone who has
     18  8400 ????						; contributed to understanding the Atari 2600.  If you take issue with the
     19  8400 ????						; contents, or naming of registers, please write to me (atari2600@taswegian.com)
     20  8400 ????						; with your views.  Please contribute, if you think you can improve this
     21  8400 ????						; file!
     22  8400 ????						;
     23  8400 ????						; Latest Revisions...
     24  8400 ????						; 1.05  13/NOV/2003	  - Correction to 1.04 - now functions as requested by MR.
     25  8400 ????						;			  - Added VERSION_VCS equate (which will reflect 100x version #)
     26  8400 ????						;			    This will allow conditional code to verify VCS.H being
     27  8400 ????						;			    used for code assembly.
     28  8400 ????						; 1.04  12/NOV/2003	 Added TIA_BASE_WRITE_ADDRESS and TIA_BASE_READ_ADDRESS for
     29  8400 ????						;			 convenient disassembly/reassembly compatibility for hardware
     30  8400 ????						;			 mirrored reading/writing differences.	This is more a 
     31  8400 ????						;			 readability issue, and binary compatibility with disassembled
     32  8400 ????						;			 and reassembled sources.  Per Manuel Rotschkar's suggestion.
     33  8400 ????						; 1.03  12/MAY/2003	 Added SEG segment at end of file to fix old-code compatibility
     34  8400 ????						;			 which was broken by the use of segments in this file, as
     35  8400 ????						;			 reported by Manuel Polik on [stella] 11/MAY/2003
     36  8400 ????						; 1.02  22/MAR/2003	 Added TIMINT($285)
     37  8400 ????						; 1.01				Constant offset added to allow use for 3F-style bankswitching
     38  8400 ????						;						 - define TIA_BASE_ADDRESS as $40 for Tigervision carts, otherwise
     39  8400 ????						;						   it is safe to leave it undefined, and the base address will
     40  8400 ????						;						   be set to 0.  Thanks to Eckhard Stolberg for the suggestion.
     41  8400 ????						;			    Note, may use -DLABEL=EXPRESSION to define TIA_BASE_ADDRESS
     42  8400 ????						;			  - register definitions are now generated through assignment
     43  8400 ????						;			    in uninitialised segments.	This allows a changeable base
     44  8400 ????						;			    address architecture.
     45  8400 ????						; 1.0	22/MAR/2003		Initial release
     46  8400 ????
     47  8400 ????
     48  8400 ????						;-------------------------------------------------------------------------------
     49  8400 ????
     50  8400 ????						; TIA_BASE_ADDRESS
     51  8400 ????						; The TIA_BASE_ADDRESS defines the base address of access to TIA registers.
     52  8400 ????						; Normally 0, the base address should (externally, before including this file)
     53  8400 ????						; be set to $40 when creating 3F-bankswitched (and other?) cartridges.
     54  8400 ????						; The reason is that this bankswitching scheme treats any access to locations
     55  8400 ????						; < $40 as a bankswitch.
     56  8400 ????
     57  8400 ????			  -	      IFNCONST	TIA_BASE_ADDRESS
     58  8400 ????			  -TIA_BASE_ADDRESS =	0
     59  8400 ????				      ENDIF
     60  8400 ????
     61  8400 ????						; Note: The address may be defined on the command-line using the -D switch, eg:
     62  8400 ????						; dasm.exe code.asm -DTIA_BASE_ADDRESS=$40 -f3 -v5 -ocode.bin
     63  8400 ????						; *OR* by declaring the label before including this file, eg:
     64  8400 ????						; TIA_BASE_ADDRESS = $40
     65  8400 ????						;   include "vcs.h"
     66  8400 ????
     67  8400 ????						; Alternate read/write address capability - allows for some disassembly compatibility
     68  8400 ????						; usage ; to allow reassembly to binary perfect copies).  This is essentially catering
     69  8400 ????						; for the mirrored ROM hardware registers.
     70  8400 ????
     71  8400 ????						; Usage: As per above, define the TIA_BASE_READ_ADDRESS and/or TIA_BASE_WRITE_ADDRESS
     72  8400 ????						; using the -D command-line switch, as required.  If the addresses are not defined, 
     73  8400 ????						; they defaut to the TIA_BASE_ADDRESS.
     74  8400 ????
     75  8400 ????			  -	      IFNCONST	TIA_BASE_READ_ADDRESS
     76  8400 ????			  -TIA_BASE_READ_ADDRESS =	TIA_BASE_ADDRESS
     77  8400 ????				      ENDIF
     78  8400 ????
     79  8400 ????			  -	      IFNCONST	TIA_BASE_WRITE_ADDRESS
     80  8400 ????			  -TIA_BASE_WRITE_ADDRESS =	TIA_BASE_ADDRESS
     81  8400 ????				      ENDIF
     82  8400 ????
     83  8400 ????						;-------------------------------------------------------------------------------
     84  8400 ????
     85 U002d ????				      SEG.U	TIA_REGISTERS_WRITE
     86 U0000					      ORG	TIA_BASE_WRITE_ADDRESS
     87 U0000
     88 U0000							; DO NOT CHANGE THE RELATIVE ORDERING OF REGISTERS!
     89 U0000
     90 U0000		       00	   VSYNC      ds	1	; $00	 0000 00x0   Vertical Sync Set-Clear
     91 U0001		       00	   VBLANK     ds	1	; $01	 xx00 00x0   Vertical Blank Set-Clear
     92 U0002		       00	   WSYNC      ds	1	; $02	 ---- ----   Wait for Horizontal Blank
     93 U0003		       00	   RSYNC      ds	1	; $03	 ---- ----   Reset Horizontal Sync Counter
     94 U0004		       00	   NUSIZ0     ds	1	; $04	 00xx 0xxx   Number-Size player/missle 0
     95 U0005		       00	   NUSIZ1     ds	1	; $05	 00xx 0xxx   Number-Size player/missle 1
     96 U0006		       00	   COLUP0     ds	1	; $06	 xxxx xxx0   Color-Luminance Player 0
     97 U0007		       00	   COLUP1     ds	1	; $07	 xxxx xxx0   Color-Luminance Player 1
     98 U0008		       00	   COLUPF     ds	1	; $08	 xxxx xxx0   Color-Luminance Playfield
     99 U0009		       00	   COLUBK     ds	1	; $09	 xxxx xxx0   Color-Luminance Background
    100 U000a		       00	   CTRLPF     ds	1	; $0A	 00xx 0xxx   Control Playfield, Ball, Collisions
    101 U000b		       00	   REFP0      ds	1	; $0B	 0000 x000   Reflection Player 0
    102 U000c		       00	   REFP1      ds	1	; $0C	 0000 x000   Reflection Player 1
    103 U000d		       00	   PF0	      ds	1	; $0D	 xxxx 0000   Playfield Register Byte 0
    104 U000e		       00	   PF1	      ds	1	; $0E	 xxxx xxxx   Playfield Register Byte 1
    105 U000f		       00	   PF2	      ds	1	; $0F	 xxxx xxxx   Playfield Register Byte 2
    106 U0010		       00	   RESP0      ds	1	; $10	 ---- ----   Reset Player 0
    107 U0011		       00	   RESP1      ds	1	; $11	 ---- ----   Reset Player 1
    108 U0012		       00	   RESM0      ds	1	; $12	 ---- ----   Reset Missle 0
    109 U0013		       00	   RESM1      ds	1	; $13	 ---- ----   Reset Missle 1
    110 U0014		       00	   RESBL      ds	1	; $14	 ---- ----   Reset Ball
    111 U0015		       00	   AUDC0      ds	1	; $15	 0000 xxxx   Audio Control 0
    112 U0016		       00	   AUDC1      ds	1	; $16	 0000 xxxx   Audio Control 1
    113 U0017		       00	   AUDF0      ds	1	; $17	 000x xxxx   Audio Frequency 0
    114 U0018		       00	   AUDF1      ds	1	; $18	 000x xxxx   Audio Frequency 1
    115 U0019		       00	   AUDV0      ds	1	; $19	 0000 xxxx   Audio Volume 0
    116 U001a		       00	   AUDV1      ds	1	; $1A	 0000 xxxx   Audio Volume 1
    117 U001b		       00	   GRP0       ds	1	; $1B	 xxxx xxxx   Graphics Register Player 0
    118 U001c		       00	   GRP1       ds	1	; $1C	 xxxx xxxx   Graphics Register Player 1
    119 U001d		       00	   ENAM0      ds	1	; $1D	 0000 00x0   Graphics Enable Missle 0
    120 U001e		       00	   ENAM1      ds	1	; $1E	 0000 00x0   Graphics Enable Missle 1
    121 U001f		       00	   ENABL      ds	1	; $1F	 0000 00x0   Graphics Enable Ball
    122 U0020		       00	   HMP0       ds	1	; $20	 xxxx 0000   Horizontal Motion Player 0
    123 U0021		       00	   HMP1       ds	1	; $21	 xxxx 0000   Horizontal Motion Player 1
    124 U0022		       00	   HMM0       ds	1	; $22	 xxxx 0000   Horizontal Motion Missle 0
    125 U0023		       00	   HMM1       ds	1	; $23	 xxxx 0000   Horizontal Motion Missle 1
    126 U0024		       00	   HMBL       ds	1	; $24	 xxxx 0000   Horizontal Motion Ball
    127 U0025		       00	   VDELP0     ds	1	; $25	 0000 000x   Vertical Delay Player 0
    128 U0026		       00	   VDELP1     ds	1	; $26	 0000 000x   Vertical Delay Player 1
    129 U0027		       00	   VDELBL     ds	1	; $27	 0000 000x   Vertical Delay Ball
    130 U0028		       00	   RESMP0     ds	1	; $28	 0000 00x0   Reset Missle 0 to Player 0
    131 U0029		       00	   RESMP1     ds	1	; $29	 0000 00x0   Reset Missle 1 to Player 1
    132 U002a		       00	   HMOVE      ds	1	; $2A	 ---- ----   Apply Horizontal Motion
    133 U002b		       00	   HMCLR      ds	1	; $2B	 ---- ----   Clear Horizontal Move Registers
    134 U002c		       00	   CXCLR      ds	1	; $2C	 ---- ----   Clear Collision Latches
    135 U002d
    136 U002d							;-------------------------------------------------------------------------------
    137 U002d
    138 U000e ????				      SEG.U	TIA_REGISTERS_READ
    139 U0000					      ORG	TIA_BASE_READ_ADDRESS
    140 U0000
    141 U0000							;											bit 7	 bit 6
    142 U0000		       00	   CXM0P      ds	1	; $00	     xx00 0000	     Read Collision  M0-P1   M0-P0
    143 U0001		       00	   CXM1P      ds	1	; $01	     xx00 0000			     M1-P0   M1-P1
    144 U0002		       00	   CXP0FB     ds	1	; $02	     xx00 0000			     P0-PF   P0-BL
    145 U0003		       00	   CXP1FB     ds	1	; $03	     xx00 0000			     P1-PF   P1-BL
    146 U0004		       00	   CXM0FB     ds	1	; $04	     xx00 0000			     M0-PF   M0-BL
    147 U0005		       00	   CXM1FB     ds	1	; $05	     xx00 0000			     M1-PF   M1-BL
    148 U0006		       00	   CXBLPF     ds	1	; $06	     x000 0000			     BL-PF   -----
    149 U0007		       00	   CXPPMM     ds	1	; $07	     xx00 0000			     P0-P1   M0-M1
    150 U0008		       00	   INPT0      ds	1	; $08	     x000 0000	     Read Pot Port 0
    151 U0009		       00	   INPT1      ds	1	; $09	     x000 0000	     Read Pot Port 1
    152 U000a		       00	   INPT2      ds	1	; $0A	     x000 0000	     Read Pot Port 2
    153 U000b		       00	   INPT3      ds	1	; $0B	     x000 0000	     Read Pot Port 3
    154 U000c		       00	   INPT4      ds	1	; $0C		x000 0000	 Read Input (Trigger) 0
    155 U000d		       00	   INPT5      ds	1	; $0D		x000 0000	 Read Input (Trigger) 1
    156 U000e
    157 U000e							;-------------------------------------------------------------------------------
    158 U000e
    159 U0298 ????				      SEG.U	RIOT
    160 U0280					      ORG	$280
    161 U0280
    162 U0280							; RIOT MEMORY MAP
    163 U0280
    164 U0280		       00	   SWCHA      ds	1	; $280      Port A data register for joysticks:
    165 U0281							;			Bits 4-7 for player 1.  Bits 0-3 for player 2.
    166 U0281
    167 U0281		       00	   SWACNT     ds	1	; $281      Port A data direction register (DDR)
    168 U0282		       00	   SWCHB      ds	1	; $282		Port B data (console switches)
    169 U0283		       00	   SWBCNT     ds	1	; $283      Port B DDR
    170 U0284		       00	   INTIM      ds	1	; $284		Timer output
    171 U0285
    172 U0285		       00	   TIMINT     ds	1	; $285
    173 U0286
    174 U0286							; Unused/undefined registers ($285-$294)
    175 U0286
    176 U0286		       00		      ds	1	; $286
    177 U0287		       00		      ds	1	; $287
    178 U0288		       00		      ds	1	; $288
    179 U0289		       00		      ds	1	; $289
    180 U028a		       00		      ds	1	; $28A
    181 U028b		       00		      ds	1	; $28B
    182 U028c		       00		      ds	1	; $28C
    183 U028d		       00		      ds	1	; $28D
    184 U028e		       00		      ds	1	; $28E
    185 U028f		       00		      ds	1	; $28F
    186 U0290		       00		      ds	1	; $290
    187 U0291		       00		      ds	1	; $291
    188 U0292		       00		      ds	1	; $292
    189 U0293		       00		      ds	1	; $293
    190 U0294
    191 U0294		       00	   TIM1T      ds	1	; $294		set 1 clock interval
    192 U0295		       00	   TIM8T      ds	1	; $295      set 8 clock interval
    193 U0296		       00	   TIM64T     ds	1	; $296      set 64 clock interval
    194 U0297		       00	   T1024T     ds	1	; $297      set 1024 clock interval
    195 U0298
    196 U0298							;-------------------------------------------------------------------------------
    197 U0298							; The following required for back-compatibility with code which does not use
    198 U0298							; segments.
    199 U0298
    200  8400 ????				      SEG
    201  8400 ????
    202  8400 ????						; EOF
------- FILE c:\Users\Jag\Desktop\github\Nibiru Reaction-Atari2600\Nibiru Reaction 22-11-30.bas.asm
------- FILE macro.h LEVEL 2 PASS 3
      0  8400 ????				      include	"macro.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????						; MACRO.H
      4  8400 ????						; Version 1.05, 13/NOVEMBER/2003
      5  8400 ????
      6  8400 ????	       00 69	   VERSION_MACRO =	105
      7  8400 ????
      8  8400 ????						;
      9  8400 ????						; THIS FILE IS EXPLICITLY SUPPORTED AS A DASM-PREFERRED COMPANION FILE
     10  8400 ????						; PLEASE DO *NOT* REDISTRIBUTE MODIFIED VERSIONS OF THIS FILE!
     11  8400 ????						;
     12  8400 ????						; This file defines DASM macros useful for development for the Atari 2600.
     13  8400 ????						; It is distributed as a companion machine-specific support package
     14  8400 ????						; for the DASM compiler. Updates to this file, DASM, and associated tools are
     15  8400 ????						; available at at http://www.atari2600.org/dasm
     16  8400 ????						;
     17  8400 ????						; Many thanks to the people who have contributed.  If you take issue with the
     18  8400 ????						; contents, or would like to add something, please write to me
     19  8400 ????						; (atari2600@taswegian.com) with your contribution.
     20  8400 ????						;
     21  8400 ????						; Latest Revisions...
     22  8400 ????						;
     23  8400 ????						; 1.05  14/NOV/2003	  - Added VERSION_MACRO equate (which will reflect 100x version #)
     24  8400 ????						;			    This will allow conditional code to verify MACRO.H being
     25  8400 ????						;			    used for code assembly.
     26  8400 ????						; 1.04  13/NOV/2003	 - SET_POINTER macro added (16-bit address load)
     27  8400 ????						;
     28  8400 ????						; 1.03  23/JUN/2003	 - CLEAN_START macro added - clears TIA, RAM, registers
     29  8400 ????						;
     30  8400 ????						; 1.02  14/JUN/2003	 - VERTICAL_SYNC macro added
     31  8400 ????						;			   (standardised macro for vertical synch code)
     32  8400 ????						; 1.01  22/MAR/2003	 - SLEEP macro added. 
     33  8400 ????						;			 - NO_ILLEGAL_OPCODES switch implemented
     34  8400 ????						; 1.0	22/MAR/2003		Initial release
     35  8400 ????
     36  8400 ????						; Note: These macros use illegal opcodes.  To disable illegal opcode usage, 
     37  8400 ????						;   define the symbol NO_ILLEGAL_OPCODES (-DNO_ILLEGAL_OPCODES=1 on command-line).
     38  8400 ????						;   If you do not allow illegal opcode usage, you must include this file 
     39  8400 ????						;   *after* including VCS.H (as the non-illegal opcodes access hardware
     40  8400 ????						;   registers and require them to be defined first).
     41  8400 ????
     42  8400 ????						; Available macros...
     43  8400 ????						;   SLEEP n		 - sleep for n cycles
     44  8400 ????						;   VERTICAL_SYNC	 - correct 3 scanline vertical synch code
     45  8400 ????						;   CLEAN_START	 - set machine to known state on startup
     46  8400 ????						;   SET_POINTER	 - load a 16-bit absolute to a 16-bit variable
     47  8400 ????
     48  8400 ????						;-------------------------------------------------------------------------------
     49  8400 ????						; SLEEP duration
     50  8400 ????						; Original author: Thomas Jentzsch
     51  8400 ????						; Inserts code which takes the specified number of cycles to execute.	This is
     52  8400 ????						; useful for code where precise timing is required.
     53  8400 ????						; ILLEGAL-OPCODE VERSION DOES NOT AFFECT FLAGS OR REGISTERS.
     54  8400 ????						; LEGAL OPCODE VERSION MAY AFFECT FLAGS
     55  8400 ????						; Uses illegal opcode (DASM 2.20.01 onwards).
     56  8400 ????
     57  8400 ????				      MAC	sleep
     58  8400 ????			   .CYCLES    SET	{1}
     59  8400 ????
     60  8400 ????				      IF	.CYCLES < 2
     61  8400 ????				      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
     62  8400 ????				      ERR
     63  8400 ????				      ENDIF
     64  8400 ????
     65  8400 ????				      IF	.CYCLES & 1
     66  8400 ????				      IFNCONST	NO_ILLEGAL_OPCODES
     67  8400 ????				      nop	0
     68  8400 ????				      ELSE
     69  8400 ????				      bit	VSYNC
     70  8400 ????				      ENDIF
     71  8400 ????			   .CYCLES    SET	.CYCLES - 3
     72  8400 ????				      ENDIF
     73  8400 ????
     74  8400 ????				      REPEAT	.CYCLES / 2
     75  8400 ????				      nop
     76  8400 ????				      REPEND
     77  8400 ????				      ENDM		;usage: SLEEP n (n>1)
     78  8400 ????
     79  8400 ????						;-------------------------------------------------------------------------------
     80  8400 ????						; VERTICAL_SYNC
     81  8400 ????						; Original author: Manuel Polik
     82  8400 ????						; Inserts the code required for a proper 3 scannline 
     83  8400 ????						; vertical sync sequence
     84  8400 ????						;
     85  8400 ????						; Note: Alters the accumulator
     86  8400 ????						;
     87  8400 ????						; IN:
     88  8400 ????						; OUT: A = 1
     89  8400 ????
     90  8400 ????				      MAC	vertical_sync
     91  8400 ????				      LDA	#$02	; A = VSYNC enable
     92  8400 ????				      STA	WSYNC	; Finish current line
     93  8400 ????				      STA	VSYNC	; Start vertical sync
     94  8400 ????				      STA	WSYNC	; 1st line vertical sync
     95  8400 ????				      STA	WSYNC	; 2nd line vertical sync
     96  8400 ????				      LSR		; A = VSYNC disable
     97  8400 ????				      STA	WSYNC	; 3rd line vertical sync
     98  8400 ????				      STA	VSYNC	; Stop vertical sync
     99  8400 ????				      ENDM
    100  8400 ????
    101  8400 ????						;-------------------------------------------------------------------------------
    102  8400 ????						; CLEAN_START
    103  8400 ????						; Original author: Andrew Davie
    104  8400 ????						; Standardised start-up code, clears stack, all TIA registers and RAM to 0
    105  8400 ????						; Sets stack pointer to $FF, and all registers to 0
    106  8400 ????						; Sets decimal mode off, sets interrupt flag (kind of un-necessary)
    107  8400 ????						; Use as very first section of code on boot (ie: at reset)
    108  8400 ????						; Code written to minimise total ROM usage - uses weird 6502 knowledge :)
    109  8400 ????
    110  8400 ????				      MAC	clean_start
    111  8400 ????				      sei
    112  8400 ????				      cld
    113  8400 ????
    114  8400 ????				      ldx	#0
    115  8400 ????				      txa
    116  8400 ????				      tay
    117  8400 ????			   .CLEAR_STACK dex
    118  8400 ????				      txs
    119  8400 ????				      pha
    120  8400 ????				      bne	.CLEAR_STACK	; SP=$FF, X = A = Y = 0
    121  8400 ????
    122  8400 ????				      ENDM
    123  8400 ????
    124  8400 ????						;-------------------------------------------------------
    125  8400 ????						; SET_POINTER
    126  8400 ????						; Original author: Manuel Rotschkar
    127  8400 ????						;
    128  8400 ????						; Sets a 2 byte RAM pointer to an absolute address.
    129  8400 ????						;
    130  8400 ????						; Usage: SET_POINTER pointer, address
    131  8400 ????						; Example: SET_POINTER SpritePTR, SpriteData
    132  8400 ????						;
    133  8400 ????						; Note: Alters the accumulator, NZ flags
    134  8400 ????						; IN 1: 2 byte RAM location reserved for pointer
    135  8400 ????						; IN 2: absolute address
    136  8400 ????
    137  8400 ????				      MAC	set_pointer
    138  8400 ????			   .POINTER   SET	{1}
    139  8400 ????			   .ADDRESS   SET	{2}
    140  8400 ????
    141  8400 ????				      LDA	#<.ADDRESS	; Get Lowbyte of Address
    142  8400 ????				      STA	.POINTER	; Store in pointer
    143  8400 ????				      LDA	#>.ADDRESS	; Get Hibyte of Address
    144  8400 ????				      STA	.POINTER+1	; Store in pointer+1
    145  8400 ????
    146  8400 ????				      ENDM
    147  8400 ????
    148  8400 ????						; EOF
------- FILE c:\Users\Jag\Desktop\github\Nibiru Reaction-Atari2600\Nibiru Reaction 22-11-30.bas.asm
------- FILE DPCplus.h LEVEL 2 PASS 3
      0  8400 ????				      include	"DPCplus.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3  8400 ????						; DPCplus.H - Display Processor Chip Plus Definitions
      4  8400 ????						; Chris Walton, Fred Quimby, Darrell Spice 2010
      5  8400 ????						; Version 0.00
      6  8400 ????
      7  8400 ????						; DPC Base Address
      8  8400 ????			  -	      IFNCONST	DPC_BASE_ADDRESS
      9  8400 ????			  -DPC_BASE_ADDRESS =	$1000
     10  8400 ????				      ENDIF
     11  8400 ????
     12  8400 ????						; DPC Read Base
     13  8400 ????			  -	      IFNCONST	DPC_BASE_READ_ADDRESS
     14  8400 ????			  -DPC_BASE_READ_ADDRESS =	DPC_BASE_ADDRESS
     15  8400 ????				      ENDIF
     16  8400 ????
     17  8400 ????						; DPC Write Base
     18  8400 ????			  -	      IFNCONST	DPC_BASE_WRITE_ADDRESS
     19  8400 ????			  -DPC_BASE_WRITE_ADDRESS =	DPC_BASE_ADDRESS+$28
     20  8400 ????				      ENDIF
     21  8400 ????
     22 U1028 ????				      SEG.U	DPC_REGISTERS_READ
     23 U1000					      ORG	DPC_BASE_READ_ADDRESS
     24 U1000
     25 U1000							;****************************************
     26 U1000							; DPC+ Read Registers
     27 U1000							;****************************************
     28 U1000							;
     29 U1000							;----------------------------------------
     30 U1000							; Random Numbers
     31 U1000							;----------------------------------------
     32 U1000							; DPC+ provides a 32 bit LFSR (Linear feedback shift register)
     33 U1000							; which is used as a random number generator.	Each individual byte of the
     34 U1000							; random number will return values from 0-255.  The random numbers will follow
     35 U1000							; an exact sequence, so it's best to clock them at least once per frame even if 
     36 U1000							; you don't need the value (this allows the amount of time it takes the user to
     37 U1000							; start the game to select a random starting point in the sequence)
     38 U1000							;----------------------------------------
     39 U1000		       00	   RANDOM0NEXT DS	1	; $00 clock next 32 bit number and returns byte 0
     40 U1001		       00	   RANDOM0PRIOR DS	1	; $01 clock prior 32 bit number and returns byte 0
     41 U1002		       00	   RANDOM1    DS	1	; $02 returns byte 1 of random number w/out clock
     42 U1003		       00	   RANDOM2    DS	1	; $03 returns byte 2 of random number w/out clock
     43 U1004		       00	   RANDOM3    DS	1	; $04 returns byte 3 of random number w/out clock
     44 U1005
     45 U1005							;----------------------------------------
     46 U1005							; Music Fetcher
     47 U1005							;----------------------------------------
     48 U1005							; When generating music, this value must be read every single scanline and
     49 U1005							; stored into AUDV0.
     50 U1005							;----------------------------------------
     51 U1005		       00	   AMPLITUDE  DS	1	; $05
     52 U1006
     53 U1006							;----------------------------------------
     54 U1006							; Reserved
     55 U1006							;----------------------------------------
     56 U1006		       00		      DS	1	; $06
     57 U1007		       00		      DS	1	; $07
     58 U1008
     59 U1008							;----------------------------------------
     60 U1008							; Data Fetcher
     61 U1008							;----------------------------------------
     62 U1008							; There are 8 Data Fetchers which are used to access data stored in the Display
     63 U1008							; Data bank.  Before using, you must point the Data Fetcher at the data to read
     64 U1008							; via DFxLOW and DFxHI.  After each read the Data Fetcher will update to point
     65 U1008							; to the next byte of data to return.
     66 U1008							;
     67 U1008							; psuedo code* to point Data Fetcher 1 to the color data
     68 U1008							;	lda #<(ColorDataPosition - HowFarDownScreen)
     69 U1008							;	sta DF1LOW
     70 U1008							;	lda #>(ColorDataPosition - HowFarDownScreen)
     71 U1008							;	sta DF1HI 
     72 U1008							;	....
     73 U1008							; then in the kernel read the Data Fetcher and update the color, takes 7 cycles
     74 U1008							;	LDA DF1DATA
     75 U1008							;	STA COLUP0
     76 U1008							;
     77 U1008							; * see DPCplus.asm for actual code
     78 U1008							;----------------------------------------
     79 U1008		       00	   DF0DATA    DS	1	; $08
     80 U1009		       00	   DF1DATA    DS	1	; $09
     81 U100a		       00	   DF2DATA    DS	1	; $0A
     82 U100b		       00	   DF3DATA    DS	1	; $0B
     83 U100c		       00	   DF4DATA    DS	1	; $0C
     84 U100d		       00	   DF5DATA    DS	1	; $0D
     85 U100e		       00	   DF6DATA    DS	1	; $0E
     86 U100f		       00	   DF7DATA    DS	1	; $0F
     87 U1010
     88 U1010							;----------------------------------------
     89 U1010							; Data Fetcher, Windowed
     90 U1010							;----------------------------------------
     91 U1010							; The 8 Data Fetchers can also be read in a "windowed" mode, which is most
     92 U1010							; commonly used to update sprites.  To use windowed mode, point the Data
     93 U1010							; Fetcher the same as above, but then also set the Top and Bottom of the
     94 U1010							; Window using DFxTOP and DFxBOT.  When reading via the DFxDATAW registers, a 0
     95 U1010							; value will be returned for anything that's outside of the window.
     96 U1010							;
     97 U1010							; psuedo code to point Data Fetcher0 to the sprite data
     98 U1010							;	lda #<(SpriteDataPosition - HowFarDownScreen)
     99 U1010							;	sta DF0LOW
    100 U1010							;	lda #>(SpriteDataPosition - HowFarDownScreen)
    101 U1010							;	sta DF0HI
    102 U1010							;	
    103 U1010							; set the window for Data Fetcher 0
    104 U1010							;	lda #<(SpriteDataPosition - 1)
    105 U1010							;	sta DF0TOP
    106 U1010							;	lda #<(SpriteDataPosition + ImageHeight)
    107 U1010							;	sta DF0BOT
    108 U1010							;	....
    109 U1010							; then in the kernel read the Data Fetcher and update the sprite, takes 7 cycles
    110 U1010							;	LDA DF0DATAW
    111 U1010							;	STA GRP0
    112 U1010							;----------------------------------------
    113 U1010		       00	   DF0DATAW   DS	1	; $10
    114 U1011		       00	   DF1DATAW   DS	1	; $11
    115 U1012		       00	   DF2DATAW   DS	1	; $12
    116 U1013		       00	   DF3DATAW   DS	1	; $13
    117 U1014		       00	   DF4DATAW   DS	1	; $14
    118 U1015		       00	   DF5DATAW   DS	1	; $15
    119 U1016		       00	   DF6DATAW   DS	1	; $16
    120 U1017		       00	   DF7DATAW   DS	1	; $17
    121 U1018
    122 U1018							;----------------------------------------
    123 U1018							; Fractional Data Fetcher
    124 U1018							;----------------------------------------
    125 U1018							; Another 8 Data Fetchers exist which work differently than the first 8.
    126 U1018							; These allow you to fractionally increment the Data Fetcher so a single
    127 U1018							; value can be read a set number of times before advancing to the next value.
    128 U1018							; This is commonly used to draw asymmetrical playfields without needing to 
    129 U1018							; use 1200 bytes of data (200 scanlines * 6 playfield updates).
    130 U1018							; Before using, you must point the Fractional Data Fetcher at the data to read
    131 U1018							; via DFxFRACLOW and DFxFRACHI.  You must also set the increment value via
    132 U1018							; DFxFRACINC.
    133 U1018							;
    134 U1018							; Set pointer
    135 U1018							;	LDA #<PlayfieldPF0l
    136 U1018							;	STA DF0FRACLOW
    137 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    138 U1018							;	lda #>PlayFieldPF0l
    139 U1018							;	STA DF0FRACHI
    140 U1018							;	... repeat for PF1l, PF2l, PF0r, PF1r and PF2r
    141 U1018							; Set the increment to repeat the value for x reads
    142 U1018							;	LDA #(256/x)
    143 U1018							;	STA DF0FRACINC
    144 U1018							;	 STA DF1FRACINC
    145 U1018							;	... repeat for 2-5
    146 U1018							;
    147 U1018							; Special Condition - IF you want to increment the pointer after every read 
    148 U1018							; (just like the normal Data Fetcher), then use the following to set the
    149 U1018							; increment AND prime the Fractional Data Fetcher
    150 U1018							;	LDA #255
    151 U1018							;	STA DF0FRACINC
    152 U1018							;	 STA DF1FRACINC
    153 U1018							;	... repeat for 2-5
    154 U1018							;	LDA DF0FRACDATA - priming read (first value will be read twice)
    155 U1018							;	LDA DF1FRACDATA - priming read (first value will be read twice)
    156 U1018							;	... repeat for 2-5
    157 U1018							;
    158 U1018							; then in the kernel read the Fractional Data Fetchers and update the playfield
    159 U1018							;	LDA DF0FRACDATA
    160 U1018							;	STA PF0
    161 U1018							;	LDA PF1FRACDATA
    162 U1018							;	STA PF1
    163 U1018							;	... repeat for Data Fetchers 2-5, putting them in PF2, PF0, PF1 and PF2
    164 U1018							;----------------------------------------
    165 U1018		       00	   DF0FRACDATA DS	1	; $18
    166 U1019		       00	   DF1FRACDATA DS	1	; $19
    167 U101a		       00	   DF2FRACDATA DS	1	; $1A
    168 U101b		       00	   DF3FRACDATA DS	1	; $1B
    169 U101c		       00	   DF4FRACDATA DS	1	; $1C
    170 U101d		       00	   DF5FRACDATA DS	1	; $1D
    171 U101e		       00	   DF6FRACDATA DS	1	; $1E
    172 U101f		       00	   DF7FRACDATA DS	1	; $1F
    173 U1020
    174 U1020							;----------------------------------------
    175 U1020							; Data Fetcher Window Flag
    176 U1020							;----------------------------------------
    177 U1020							; The Data Fetcher Window Flag allows you to dual-purpose the first four
    178 U1020							; Data Fetchers.  The Window is not required when a Data Fetcher is used to
    179 U1020							; update a sprite's color.  The Flag will return $FF if it's within the window,
    180 U1020							; or 0 if it's not - this value can be used to control the display of the ball
    181 U1020							; and missiles. The Data Fetcher will NOT increment when reading the flag.
    182 U1020							;
    183 U1020							; psuedo code to point Data Fetcher 1 to the color data
    184 U1020							;	lda #<(ColorDataPosition - HowFarDownScreen)
    185 U1020							;	sta DF1LOW
    186 U1020							;	lda #>(ColorDataPosition - HowFarDownScreen)
    187 U1020							;	sta DF1HI
    188 U1020							;
    189 U1020							; set the window based on the missile's Y position and height (number of
    190 U1020							; scanlines to draw missile on)
    191 U1020							;	lda #<(ColorDataPosition + MissileYposition - 1)
    192 U1020							;	sta DF1TOP
    193 U1020							;	lda #<(ColorDataPosition + MissileYposition + MissileHeight)
    194 U1020							;	sta DF1BOT
    195 U1020							;
    196 U1020							; then in the kernel read the Data Fetcher and update the color, then read the
    197 U1020							; flag and update the missile
    198 U1020							;	LDA DF1DATA
    199 U1020							;	STA COLUP0
    200 U1020							;	LDA DF1FLAG
    201 U1020							;	STA ENAM0
    202 U1020							;----------------------------------------
    203 U1020		       00	   DF0FLAG    DS	1	; $20
    204 U1021		       00	   DF1FLAG    DS	1	; $21
    205 U1022		       00	   DF2FLAG    DS	1	; $22
    206 U1023		       00	   DF3FLAG    DS	1	; $23
    207 U1024
    208 U1024							;----------------------------------------
    209 U1024							; Reserved
    210 U1024							;----------------------------------------
    211 U1024		       00		      DS	1	; $24
    212 U1025		       00		      DS	1	; $25
    213 U1026		       00		      DS	1	; $26
    214 U1027		       00		      DS	1	; $27
    215 U1028
    216 U1028
    217 U1080 ????				      SEG.U	DPC_REGISTERS_WRITE
    218 U1028					      ORG	DPC_BASE_WRITE_ADDRESS
    219 U1028
    220 U1028							;****************************************
    221 U1028							; SECTION 2 - DPC+ Write Registers
    222 U1028							;****************************************
    223 U1028							;
    224 U1028							;----------------------------------------
    225 U1028							; Fractional Data Fetcher, Low Pointer
    226 U1028							;----------------------------------------
    227 U1028							; These are used in conjunction with DFxFRACHI to point a Fractional Data
    228 U1028							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    229 U1028							; in SECTION 1.
    230 U1028							;----------------------------------------
    231 U1028		       00	   DF0FRACLOW DS	1	; $28
    232 U1029		       00	   DF1FRACLOW DS	1	; $29
    233 U102a		       00	   DF2FRACLOW DS	1	; $2A
    234 U102b		       00	   DF3FRACLOW DS	1	; $2B
    235 U102c		       00	   DF4FRACLOW DS	1	; $2C
    236 U102d		       00	   DF5FRACLOW DS	1	; $2D
    237 U102e		       00	   DF6FRACLOW DS	1	; $2E
    238 U102f		       00	   DF7FRACLOW DS	1	; $2F
    239 U1030
    240 U1030							;----------------------------------------
    241 U1030							; Fractional Data Fetcher, High Pointer
    242 U1030							;----------------------------------------
    243 U1030							; These are used in conjunction with DFxFRACLOW to point a Fractional Data
    244 U1030							; Fetcher to the data to read.  For usage, see "Fractional Data Fetcher"
    245 U1030							; in SECTION 1.
    246 U1030							;
    247 U1030							; NOTE: for only the lower 4 bits are used.
    248 U1030							;----------------------------------------
    249 U1030		       00	   DF0FRACHI  DS	1	; $30
    250 U1031		       00	   DF1FRACHI  DS	1	; $31
    251 U1032		       00	   DF2FRACHI  DS	1	; $32
    252 U1033		       00	   DF3FRACHI  DS	1	; $33
    253 U1034		       00	   DF4FRACHI  DS	1	; $34
    254 U1035		       00	   DF5FRACHI  DS	1	; $35 
    255 U1036		       00	   DF6FRACHI  DS	1	; $36 
    256 U1037		       00	   DF7FRACHI  DS	1	; $37 
    257 U1038
    258 U1038							;----------------------------------------
    259 U1038							; Fractional Data Fetcher, Increment
    260 U1038							;----------------------------------------
    261 U1038							; These are used to set the increment amount for the Fractional Data Fetcher.
    262 U1038							; To increment pointer after every Xth read use int(256/X)
    263 U1038							; For usage, see "Fractional Data Fetcher" in SECTION 1.
    264 U1038							;----------------------------------------
    265 U1038		       00	   DF0FRACINC DS	1	; $38
    266 U1039		       00	   DF1FRACINC DS	1	; $39
    267 U103a		       00	   DF2FRACINC DS	1	; $3A
    268 U103b		       00	   DF3FRACINC DS	1	; $3B
    269 U103c		       00	   DF4FRACINC DS	1	; $3C
    270 U103d		       00	   DF5FRACINC DS	1	; $3D
    271 U103e		       00	   DF6FRACINC DS	1	; $3E
    272 U103f		       00	   DF7FRACINC DS	1	; $3F
    273 U1040
    274 U1040							;----------------------------------------
    275 U1040							; Data Fetcher, Window Top
    276 U1040							;----------------------------------------
    277 U1040							; These are used with DFxBOT to define the Data Fetcher Window
    278 U1040							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    279 U1040							;----------------------------------------
    280 U1040		       00	   DF0TOP     DS	1	; $40
    281 U1041		       00	   DF1TOP     DS	1	; $41
    282 U1042		       00	   DF2TOP     DS	1	; $42
    283 U1043		       00	   DF3TOP     DS	1	; $43
    284 U1044		       00	   DF4TOP     DS	1	; $44
    285 U1045		       00	   DF5TOP     DS	1	; $45
    286 U1046		       00	   DF6TOP     DS	1	; $46
    287 U1047		       00	   DF7TOP     DS	1	; $47
    288 U1048
    289 U1048							;----------------------------------------
    290 U1048							; Data Fetcher, Window Bottom
    291 U1048							;----------------------------------------
    292 U1048							; These are used with DFxTOP to define the Data Fetcher Window
    293 U1048							; For usage, see "Data Fetcher, Windowed" in SECTION 1.
    294 U1048							;----------------------------------------
    295 U1048		       00	   DF0BOT     DS	1	; $48
    296 U1049		       00	   DF1BOT     DS	1	; $49
    297 U104a		       00	   DF2BOT     DS	1	; $4A
    298 U104b		       00	   DF3BOT     DS	1	; $4B
    299 U104c		       00	   DF4BOT     DS	1	; $4C
    300 U104d		       00	   DF5BOT     DS	1	; $4D
    301 U104e		       00	   DF6BOT     DS	1	; $4E
    302 U104f		       00	   DF7BOT     DS	1	; $4F
    303 U1050
    304 U1050							;----------------------------------------
    305 U1050							; Data Fetcher, Low Pointer
    306 U1050							;----------------------------------------
    307 U1050							; These are used in conjunction with DFxHI to point a Data Fetcher to the data
    308 U1050							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    309 U1050							;----------------------------------------
    310 U1050		       00	   DF0LOW     DS	1	; $50
    311 U1051		       00	   DF1LOW     DS	1	; $51
    312 U1052		       00	   DF2LOW     DS	1	; $52
    313 U1053		       00	   DF3LOW     DS	1	; $53
    314 U1054		       00	   DF4LOW     DS	1	; $54
    315 U1055		       00	   DF5LOW     DS	1	; $55
    316 U1056		       00	   DF6LOW     DS	1	; $56
    317 U1057		       00	   DF7LOW     DS	1	; $57
    318 U1058
    319 U1058							;----------------------------------------
    320 U1058							; Fast Fetch Mode
    321 U1058							;----------------------------------------
    322 U1058							; Fast Fetch Mode enables the fastest way to read DPC+ registers.  Normal
    323 U1058							; reads use LDA Absolute addressing (LDA DF0DATA) which takes 4 cycles to
    324 U1058							; process.  Fast Fetch Mode intercepts LDA Immediate addressing (LDA #<DF0DATA)
    325 U1058							; which takes only 2 cycles!  Only immediate values < $28 are intercepted
    326 U1058							; 
    327 U1058							; set Fast Fetch Mode
    328 U1058							;	LDA #0
    329 U1058							;	STA FASTFETCH
    330 U1058							;
    331 U1058							; then use immediate mode to read the registers, takes just 5 cycles to update
    332 U1058							; any TIA register
    333 U1058							;
    334 U1058							;	LDA #<DF0DATA
    335 U1058							;	STA GRP0
    336 U1058							;
    337 U1058							; when done, turn off Fast Fetch Mode using any non-zero value
    338 U1058							;	LDA #$FF
    339 U1058							;	STA FASTFETCH
    340 U1058							;
    341 U1058							; NOTE: if you forget to turn off FASTFETCH mode, then code like this will not
    342 U1058							;	 work as you expect
    343 U1058							;	LDA #0	; returns a RANDOM NUMBER, not 0.
    344 U1058							;	STA COLUPF
    345 U1058							;----------------------------------------
    346 U1058		       00	   FASTFETCH  DS	1	; $58
    347 U1059
    348 U1059							;----------------------------------------
    349 U1059							; Function Support
    350 U1059							;----------------------------------------
    351 U1059							; Currently only Function 255 is defined, and it is used to call user
    352 U1059							; written ARM routines (or C code compiled for the ARM processor.)
    353 U1059							;
    354 U1059							; PARAMETER is not used by function 255, it may be used by future functions.
    355 U1059							; 
    356 U1059							; call custom ARM routine
    357 U1059							;	LDA #$FF
    358 U1059							;	STA CALLFUNCTION
    359 U1059							;
    360 U1059							; A custom ARM demo will be released in the near future
    361 U1059							;----------------------------------------
    362 U1059		       00	   PARAMETER  DS	1	; $59
    363 U105a		       00	   CALLFUNCTION DS	1	; $5A
    364 U105b
    365 U105b							;----------------------------------------
    366 U105b							; Reserved
    367 U105b							;----------------------------------------
    368 U105b		       00		      DS	1	; $5B	 ; reserved
    369 U105c		       00		      DS	1	; $5C	 ; reserved
    370 U105d
    371 U105d							;----------------------------------------
    372 U105d							; Waveforms
    373 U105d							;----------------------------------------
    374 U105d							; Waveforms are 32 byte tables that define a waveform.  Waveforms must be 32
    375 U105d							; byte aligned, and can only be stored in the 4K Display Data Bank. You MUST
    376 U105d							; define an "OFF" waveform,  comprised of all zeros.  The sum of all waveforms
    377 U105d							; being played should be <= 15, so typically you'll use a maximum of 5 for any
    378 U105d							; given value.
    379 U105d							;
    380 U105d							; Valid values are 0-127 and point to the 4K Display Data bank.  The formula
    381 U105d							; (* & $1fff)/32 as shown below will calculate the value for you
    382 U105d							;
    383 U105d							;
    384 U105d							; example waveforms
    385 U105d							;	align 32		; forces the waveform to a 32 byte boundary
    386 U105d							;SOUND_OFF = (* & $1fff)/32	; calculates waveform pointer
    387 U105d							;	.byte 0,0,0,0,0,0,0,0
    388 U105d							;	.byte 0,0,0,0,0,0,0,0
    389 U105d							;	.byte 0,0,0,0,0,0,0,0
    390 U105d							;	.byte 0,0,0,0,0,0,0,0 
    391 U105d							; 
    392 U105d							;	align 32
    393 U105d							;SINE_WAVE = (* & $1fff)/32
    394 U105d							;	.byte 3,3,3,4,4,5,5,5
    395 U105d							;	.byte 5,5,5,5,4,4,3,3
    396 U105d							;	.byte 3,2,2,1,1,0,0,0
    397 U105d							;	.byte 0,0,0,0,1,1,2,2 
    398 U105d							;
    399 U105d							; usage, set voice 0 to Sine Wave, set voice 1 & 2 off
    400 U105d							;	LDA #SINE_WAVE
    401 U105d							;	STA WAVEFORM0
    402 U105d							;	LDA #SOUND_OFF
    403 U105d							;	STA WAVEFORM1
    404 U105d							;	STA WAVEFORM2	
    405 U105d							;----------------------------------------
    406 U105d		       00	   WAVEFORM0  DS	1	; $5D
    407 U105e		       00	   WAVEFORM1  DS	1	; $5E
    408 U105f		       00	   WAVEFORM2  DS	1	; $5F
    409 U1060
    410 U1060							;----------------------------------------
    411 U1060							; Data Fetcher Push (stack)
    412 U1060							;----------------------------------------
    413 U1060							; The Data Fetchers can also be used to update the contents of the 4K
    414 U1060							; Display Data bank.  Point the Data Fetcher to the data to change,
    415 U1060							; then Push to it.  The Data Fetcher's pointer will be decremented BEFORE
    416 U1060							; the data is written.
    417 U1060							;
    418 U1060							; point Data Fetcher 1 to the sprite data
    419 U1060							;	lda #<DisplayData
    420 U1060							;	sta DF1LOW
    421 U1060							;	lda #>DisplayData
    422 U1060							;	sta DF1HI 
    423 U1060							;
    424 U1060							; then update it
    425 U1060							;	LDA #$FF
    426 U1060							;	STA DF1PUSH ; changes data at DisplayData - 1
    427 U1060							;	LDA #$81
    428 U1060							;	STA DF1OUSH ; changes data at DisplayData - 2
    429 U1060							;----------------------------------------
    430 U1060		       00	   DF0PUSH    DS	1	; $60
    431 U1061		       00	   DF1PUSH    DS	1	; $61
    432 U1062		       00	   DF2PUSH    DS	1	; $62
    433 U1063		       00	   DF3PUSH    DS	1	; $63
    434 U1064		       00	   DF4PUSH    DS	1	; $64
    435 U1065		       00	   DF5PUSH    DS	1	; $65
    436 U1066		       00	   DF6PUSH    DS	1	; $66
    437 U1067		       00	   DF7PUSH    DS	1	; $67
    438 U1068
    439 U1068							;----------------------------------------
    440 U1068							; Data Fetcher, High Pointer
    441 U1068							;----------------------------------------
    442 U1068							; These are used in conjunction with DFxLOW to point a Data Fetcher to the data
    443 U1068							; to read.  For usage, see "Data Fetcher" in SECTION 1.
    444 U1068							;----------------------------------------
    445 U1068		       00	   DF0HI      DS	1	; $68
    446 U1069		       00	   DF1HI      DS	1	; $69
    447 U106a		       00	   DF2HI      DS	1	; $6A
    448 U106b		       00	   DF3HI      DS	1	; $6B
    449 U106c		       00	   DF4HI      DS	1	; $6C
    450 U106d		       00	   DF5HI      DS	1	; $6D 
    451 U106e		       00	   DF6HI      DS	1	; $6E 
    452 U106f		       00	   DF7HI      DS	1	; $6F 
    453 U1070
    454 U1070							;----------------------------------------
    455 U1070							; Random Number Initialization
    456 U1070							;----------------------------------------
    457 U1070							; The random number generate defaults to a value that spells out DPC+.
    458 U1070							; Store any value to RRESET to set the random number back to DPC+, or you
    459 U1070							; can use RWRITE0-3 to change the 32 bit value to anything you desire.
    460 U1070							;
    461 U1070							; reset random number
    462 U1070							;	LDA #0
    463 U1070							;	STA RRESET
    464 U1070							;
    465 U1070							; set a specific random number (spells out 2600)
    466 U1070							;	LDA #$32
    467 U1070							;	STA RWRITE0
    468 U1070							;	LDA #$36
    469 U1070							;	STA RWRITE1
    470 U1070							;	LDA #$30
    471 U1070							;	STA RWRITE2
    472 U1070							;	STA RWRITE3
    473 U1070							;
    474 U1070							; NOTE: do not set all 4 bytes to 0, as that will disable the generator.
    475 U1070							;----------------------------------------
    476 U1070		       00	   RRESET     DS	1	; $70
    477 U1071		       00	   RWRITE0    DS	1	; $71
    478 U1072		       00	   RWRITE1    DS	1	; $72
    479 U1073		       00	   RWRITE2    DS	1	; $73
    480 U1074		       00	   RWRITE3    DS	1	; $74
    481 U1075
    482 U1075							;----------------------------------------
    483 U1075							; Notes
    484 U1075							;----------------------------------------
    485 U1075							; These are used to select a value from the frequency table to play.
    486 U1075							; The default table, store in DPC_frequencies.h, only defines frequencies
    487 U1075							; for 1-88, which cover the keys of a piano.  You are free to add additional
    488 U1075							; frequencies from 88-255.  Piano keys are defined at the end of this file
    489 U1075							;
    490 U1075							; set voice 0 to middle C
    491 U1075							;	LDA #C4
    492 U1075							;	STA NOTE0
    493 U1075							;
    494 U1075							; Note: if you are using ARM USER CODE then you can only use notes to 128.
    495 U1075							;----------------------------------------
    496 U1075		       00	   NOTE0      DS	1	; $75
    497 U1076		       00	   NOTE1      DS	1	; $76
    498 U1077		       00	   NOTE2      DS	1	; $77
    499 U1078
    500 U1078							;----------------------------------------
    501 U1078							; Data Fetcher Write (queue)
    502 U1078							;----------------------------------------
    503 U1078							; The Data Fetchers can also be used to update the contents of the 4K
    504 U1078							; Display Data bank.  Point the Data Fetcher to the data to change,
    505 U1078							; then Write to it  The Data Fetcher's pointer will be incremented AFTER
    506 U1078							; the data is written.
    507 U1078							;
    508 U1078							; point Data Fetcher 1 to the sprite data
    509 U1078							;	lda #<SpriteData
    510 U1078							;	sta DF1LOW
    511 U1078							;	lda #>SpriteData
    512 U1078							;	sta DF1HI 
    513 U1078							;
    514 U1078							; then update it
    515 U1078							;	LDA #$FF
    516 U1078							;	STA DF1WRITE ; changes data at SpriteData
    517 U1078							;	LDA #$81
    518 U1078							;	STA DF1WRITE ; changes data at SpriteData + 1
    519 U1078							;----------------------------------------
    520 U1078		       00	   DF0WRITE   DS	1	; $78
    521 U1079		       00	   DF1WRITE   DS	1	; $79
    522 U107a		       00	   DF2WRITE   DS	1	; $7A
    523 U107b		       00	   DF3WRITE   DS	1	; $7B
    524 U107c		       00	   DF4WRITE   DS	1	; $7C
    525 U107d		       00	   DF5WRITE   DS	1	; $7D
    526 U107e		       00	   DF6WRITE   DS	1	; $7E
    527 U107f		       00	   DF7WRITE   DS	1	; $7F
    528 U1080
    529 U1080							;-------------------------------------------------------------------------------
    530 U1080							; The following required for back-compatibility with code which does not use
    531 U1080							; segments.
    532 U1080
    533  8400 ????				      SEG
------- FILE c:\Users\Jag\Desktop\github\Nibiru Reaction-Atari2600\Nibiru Reaction 22-11-30.bas.asm
------- FILE DPCplusbB.h LEVEL 2 PASS 3
      0  8400 ????				      include	"DPCplusbB.h"
      1  8400 ????						; Provided under the CC0 license. See the included LICENSE.txt for details.
      2  8400 ????
      3 U00f5 ????				      SEG.U	vars
      4 U0080					      org	$80
      5 U0080		       00	   player0x   ds	1
      6 U0081		       00	   topP1x     ds	1
      7 U0082		       00	   missile0x  ds	1
      8 U0083		       00	   missile1x  ds	1
      9 U0084		       00	   ballx      ds	1
     10 U0085
     11 U0085		       00 00 00 00*SpriteGfxIndex ds	9
     12 U008e
     13 U008e		       00	   spritedisplay ds	1
     14 U008f
     15 U008f		       00	   player0xcoll ds	1	; to detect p0x colls
     16 U0090		       00	   NewSpriteX ds	1	;		X position
     17 U0090		       00 90	   player1x   =	NewSpriteX
     18 U0091		       00	   player2x   ds	1
     19 U0092		       00	   player3x   ds	1
     20 U0093		       00	   player4x   ds	1
     21 U0094		       00	   player5x   ds	1
     22 U0095		       00	   player6x   ds	1
     23 U0096		       00	   player7x   ds	1
     24 U0097		       00	   player8x   ds	1
     25 U0098		       00	   player9x   ds	1
     26 U0099
     27 U0099		       00	   player0y   ds	1
     28 U009a		       00	   NewSpriteY ds	1	;		Y position
     29 U009a		       00 9a	   player1y   =	NewSpriteY
     30 U009b		       00	   player2y   ds	1
     31 U009c		       00	   player3y   ds	1
     32 U009d		       00	   player4y   ds	1
     33 U009e		       00	   player5y   ds	1
     34 U009f		       00	   player6y   ds	1
     35 U00a0		       00	   player7y   ds	1
     36 U00a1		       00	   player8y   ds	1
     37 U00a2		       00	   player9y   ds	1
     38 U00a3
     39 U00a3		       00 00	   player0color ds	2
     40 U00a5
     41 U00a5		       00	   player0height ds	1
     42 U00a6		       00	   player1height ds	1
     43 U00a7		       00	   player2height ds	1
     44 U00a8		       00	   player3height ds	1
     45 U00a9		       00	   player4height ds	1
     46 U00aa		       00	   player5height ds	1
     47 U00ab		       00	   player6height ds	1
     48 U00ac		       00	   player7height ds	1
     49 U00ad		       00	   player8height ds	1
     50 U00ae		       00	   player9height ds	1
     51 U00af
     52 U00af		       00	   _NUSIZ1    ds	1
     53 U00b0		       00	   NUSIZ2     ds	1
     54 U00b1		       00	   NUSIZ3     ds	1
     55 U00b2		       00	   NUSIZ4     ds	1
     56 U00b3		       00	   NUSIZ5     ds	1
     57 U00b4		       00	   NUSIZ6     ds	1
     58 U00b5		       00	   NUSIZ7     ds	1
     59 U00b6		       00	   NUSIZ8     ds	1
     60 U00b7		       00	   NUSIZ9     ds	1
     61 U00b8
     62 U00b8		       00 00 00    score      ds	3
     63 U00bb		       00	   COLUM0     ds	1
     64 U00bc		       00	   COLUM1     ds	1
     65 U00bd		       00	   player0pointerlo ds	1
     66 U00be		       00	   player0pointerhi ds	1
     67 U00bf
     68 U00bf		       00 85	   RAMcopybegin =	SpriteGfxIndex
     69 U00bf		       00 3a	   RAMcopylength =	*-RAMcopybegin
     70 U00bf
     71 U00bf		       00	   missile0y  ds	1
     72 U00c0		       00	   missile1y  ds	1
     73 U00c1		       00	   bally      ds	1
     74 U00c2
     75 U00c2		       00	   missile0height ds	1
     76 U00c3		       00	   missile1height ds	1
     77 U00c4		       00	   ballheight ds	1
     78 U00c5
     79 U00c5		       00	   statusbarlength ds	1	; needed?
     80 U00c5		       00 c5	   aux3       =	statusbarlength
     81 U00c6
     82 U00c6		       00	   lifecolor  ds	1
     83 U00c6		       00 c6	   pfscorecolor =	lifecolor
     84 U00c7		       00	   aux4       ds	1
     85 U00c8
     86 U00c8		       00	   lifepointer ds	1
     87 U00c9		       00	   lives      ds	1
     88 U00c9		       00 c8	   pfscore1   =	lifepointer
     89 U00c9		       00 c9	   pfscore2   =	lives
     90 U00c9		       00 c8	   aux5       =	pfscore1
     91 U00c9		       00 c9	   aux6       =	pfscore2
     92 U00ca
     93 U00ca		       00	   playfieldpos ds	1
     94 U00cb
     95 U00cb		       00	   temp1      ds	1	; used in sprite flickering
     96 U00cc		       00	   temp2      ds	1	;are obliterated when drawscreen is called.
     97 U00cd		       00	   temp3      ds	1
     98 U00ce		       00	   temp4      ds	1
     99 U00cf		       00	   temp5      ds	1
    100 U00d0		       00	   temp6      ds	1
    101 U00d0		       00 81	   temp7      =	topP1x	; This is used to aid in bankswitching
    102 U00d1
    103 U00d1		       00	   A	      ds	1
    104 U00d1		       00 d1	   a	      =	A
    105 U00d2		       00	   B	      ds	1
    106 U00d2		       00 d2	   b	      =	B
    107 U00d3		       00	   C	      ds	1
    108 U00d3		       00 d3	   c	      =	C
    109 U00d4		       00	   D	      ds	1
    110 U00d4		       00 d4	   d	      =	D
    111 U00d5		       00	   E	      ds	1
    112 U00d5		       00 d5	   e	      =	E
    113 U00d6		       00	   F	      ds	1
    114 U00d6		       00 d6	   f	      =	F
    115 U00d7		       00	   G	      ds	1
    116 U00d7		       00 d7	   g	      =	G
    117 U00d8		       00	   H	      ds	1
    118 U00d8		       00 d8	   h	      =	H
    119 U00d9		       00	   I	      ds	1
    120 U00d9		       00 d9	   i	      =	I
    121 U00da		       00	   J	      ds	1
    122 U00da		       00 da	   j	      =	J
    123 U00db		       00	   K	      ds	1
    124 U00db		       00 db	   k	      =	K
    125 U00dc		       00	   L	      ds	1
    126 U00dc		       00 dc	   l	      =	L
    127 U00dd		       00	   M	      ds	1
    128 U00dd		       00 dd	   m	      =	M
    129 U00de		       00	   N	      ds	1
    130 U00de		       00 de	   n	      =	N
    131 U00df		       00	   O	      ds	1
    132 U00df		       00 df	   o	      =	O
    133 U00e0		       00	   P	      ds	1
    134 U00e0		       00 e0	   p	      =	P
    135 U00e1		       00	   Q	      ds	1
    136 U00e1		       00 e1	   q	      =	Q
    137 U00e2		       00	   R	      ds	1
    138 U00e2		       00 e2	   r	      =	R
    139 U00e3		       00	   S	      ds	1
    140 U00e3		       00 e3	   s	      =	S
    141 U00e4		       00	   T	      ds	1
    142 U00e4		       00 e4	   t	      =	T
    143 U00e5		       00	   U	      ds	1
    144 U00e5		       00 e5	   u	      =	U
    145 U00e6		       00	   V	      ds	1
    146 U00e6		       00 e6	   v	      =	V
    147 U00e7		       00	   W	      ds	1
    148 U00e7		       00 e7	   w	      =	W
    149 U00e8		       00	   X	      ds	1
    150 U00e8		       00 e8	   x	      =	X
    151 U00e9		       00	   Y	      ds	1
    152 U00e9		       00 e9	   y	      =	Y
    153 U00ea		       00	   Z	      ds	1
    154 U00ea		       00 ea	   z	      =	Z
    155 U00eb		       00	   scorecolor ds	1
    156 U00ec
    157 U00ec		       00	   var0       ds	1
    158 U00ed		       00	   var1       ds	1
    159 U00ee		       00	   var2       ds	1
    160 U00ef		       00	   var3       ds	1
    161 U00f0		       00	   var4       ds	1
    162 U00f1		       00	   var5       ds	1
    163 U00f2		       00	   var6       ds	1
    164 U00f3		       00	   var7       ds	1
    165 U00f4		       00	   var8       ds	1
    166 U00f5
 free ram: 0
    167 U00f5					      echo	"free ram:",($f5-*)d
    168 U00f5
    169 U00f5		       00 f6	   stack1     =	$f6
    170 U00f5		       00 f7	   stack2     =	$f7
    171 U00f5		       00 f8	   stack3     =	$f8
    172 U00f5		       00 f9	   stack4     =	$f9
    173 U00f5							; the stack bytes above may be used in the kernel
    174 U00f5							; stack = F6-F7, F8-F9, FA-FB, FC-FD, FE-FF
    175 U00f5
    176 U00f5					      MAC	return
    177 U00f5					      ifnconst	bankswitch
    178 U00f5					      rts
    179 U00f5					      else
    180 U00f5					      jmp	BS_return
    181 U00f5					      endif
    182 U00f5					      ENDM		; auto-return from either a regular or bankswitched module
    183  8400 ????				      seg
    184  8400 ????	       10 00	   rand       =	RANDOM0NEXT
    185  8400 ????	       00 d3	   KERNEL_LINES =	178*76/64	; warning: not all values will work
    186  8400 ????	       00 a7	   OVERSCAN_LINES =	128+33*76/64	; again, not all values work
    187  8400 ????	       d1 a4	   C_function =	FETCHER_BEGIN
    188  8400 ????	       d1 a8	   CcodeData  =	C_function + 4
    189  8400 ????	       d1 e2	   playerpointers =	CcodeData + RAMcopylength
    190  8400 ????	       d2 08	   P1GFX      =	playerpointers + 38
    191  8400 ????	       d3 08	   P1COLOR    =	P1GFX + 256
    192  8400 ????	       d4 08	   P0GFX      =	P1COLOR + 256
    193  8400 ????	       d5 08	   P0COLOR    =	P0GFX + 256
    194  8400 ????	       d6 08	   PF1L       =	P0COLOR + 256
    195  8400 ????	       d7 08	   PF2L       =	PF1L + 256
    196  8400 ????	       d8 08	   PF1R       =	PF2L + 256
    197  8400 ????	       d9 08	   PF2R       =	PF1R + 256
    198  8400 ????	       da 08	   PFCOLS     =	PF2R + 256
    199  8400 ????	       db 08	   JUMPTABLELO =	PFCOLS + 256
    200  8400 ????	       db 14	   JUMPTABLEHI =	JUMPTABLELO + 12
    201  8400 ????	       db 20	   P1HMP      =	JUMPTABLEHI + 12
    202  8400 ????	       db 2d	   P1SKIP     =	P1HMP + 13
    203  8400 ????	       db 39	   NUSIZREFP  =	P1SKIP + 12
    204  8400 ????	       db 45	   scoredata  =	NUSIZREFP + 12
    205  8400 ????	       db a5	   BKCOLS     =	scoredata + 96
    206  8400 ????	       dc a5	   STACKbegin =	BKCOLS + 256
    207  8400 ????	       dd a5	   USERSTACK  =	STACKbegin + 256	; stack starts here and goes down!!!!
 DPC free RAM= 603
    208  8400 ????				      echo	"DPC free RAM=",($1000-(USERSTACK&$0FFF))d
------- FILE c:\Users\Jag\Desktop\github\Nibiru Reaction-Atari2600\Nibiru Reaction 22-11-30.bas.asm
------- FILE 2600basic_variable_redefs.h LEVEL 2 PASS 3
      0  8400 ????				      include	"2600basic_variable_redefs.h"
      1  8400 ????						; This file contains variable mapping and other information for the current project.
      2  8400 ????
      3  8400 ????	       00 20	   _scoretable2_length =	.skipL0268-_scoretable2
      4  8400 ????
      5  8400 ????	       00 2c	   _color_length =	.skipL0238-_color
      6  8400 ????
      7  8400 ????	       00 20	   timerLengthTable_length =	.skipL0237-timerLengthTable
      8  8400 ????
      9  8400 ????	       00 09	   starColor_length =	.skipL0236-starColor
     10  8400 ????
     11  8400 ????	       00 04	   starY_length =	.skipL0235-starY
     12  8400 ????
     13  8400 ????	       00 04	   starX_length =	.skipL0234-starX
     14  8400 ????
     15  8400 ????	       00 ef	   displayNumber =	var3
     16  8400 ????	       00 83	   m1x	      =	missile1x
     17  8400 ????	       00 f0	   hole4x     =	var4
     18  8400 ????
     19  8400 ????	       00 ef	   hole3x     =	var3
     20  8400 ????
     21  8400 ????	       00 ee	   hole2x     =	var2
     22  8400 ????
     23  8400 ????	       00 ed	   hole1x     =	var1
     24  8400 ????
     25  8400 ????	       00 e2	   speedup4   =	r
     26  8400 ????	       00 e1	   speedup3   =	q
     27  8400 ????	       00 e0	   speedup2   =	p
     28  8400 ????	       00 df	   speedup1   =	o
     29  8400 ????	       00 de	   nextRand   =	n
     30  8400 ????
     31  8400 ????	       00 d5	   timerLength =	e
     32  8400 ????
     33  8400 ????	       00 dd	   timer      =	m
     34  8400 ????
     35  8400 ????	       00 d4	   linePos4   =	d
     36  8400 ????	       00 d3	   linePos3   =	c
     37  8400 ????	       00 d2	   linePos2   =	b
     38  8400 ????	       00 d1	   linePosArray =	a
     39  8400 ????
     40  8400 ????	       00 d1	   linePos1   =	a
     41  8400 ????	       00 0b	   BKCOLSHI   =	# ( > BKCOLS ) & $0F
     42  8400 ????
     43  8400 ????	       00 a5	   BKCOLSLOW  =	# < ( BKCOLS )
     44  8400 ????
     45  8400 ????	       00 0a	   PFCOLSHI   =	# ( > PFCOLS ) & $0F
     46  8400 ????
     47  8400 ????	       00 08	   PFCOLSLOW  =	# < ( PFCOLS )
     48  8400 ????
     49  8400 ????	       00 ba	   _sc3       =	score + 2
     50  8400 ????
     51  8400 ????	       00 b9	   _sc2       =	score + 1
     52  8400 ????
     53  8400 ????	       00 20	   bscode_length =	32
     54  8400 ????	       00 2b	   vblank_time =	43
     55  8400 ????	       00 25	   overscan_time =	37
     56  8400 ????	       00 07	   bs_mask    =	7
     57  8400 ????	       00 1c	   bankswitch =	28
     58  8400 ????	       1f f6	   bankswitch_hotspot =	$1FF6
     59  8400 ????	       00 02	   multisprite =	2
------- FILE c:\Users\Jag\Desktop\github\Nibiru Reaction-Atari2600\Nibiru Reaction 22-11-30.bas.asm
      9  0400					      ORG	$400
     10  0400					      RORG	$0
     11  0400					      incbin	DPCplus.arm
     12  1000					      ORG	$1000
     13  1000					      RORG	$1000
     14  1000					      incbin	custom/bin/custom2.bin
     15  1894							; assume custom2.bin > 128 bytes
     16  1894							; repeat $80
     17  1894							; .byte 0
     18  1894							; repend
     19  1894				   ﻿			; feel free to modify the score graphics - just keep each digit 8 high
     20  1894							; and keep the conditional compilation stuff intact
     21  1894				  -	      ifconst	ROM2k
     22  1894				  -	      ORG	$F7AC
     23  1894					      else
     24  1894					      ifconst	bankswitch
     25  1894				  -	      if	bankswitch == 8
     26  1894				  -	      ORG	$2F94-bscode_length
     27  1894				  -	      RORG	$FF94-bscode_length
     28  1894					      endif
     29  1894				  -	      if	bankswitch == 16
     30  1894				  -	      ORG	$4F94-bscode_length
     31  1894				  -	      RORG	$FF94-bscode_length
     32  1894					      endif
     33  1894				  -	      if	bankswitch == 32
     34  1894				  -	      ORG	$8F94-bscode_length
     35  1894				  -	      RORG	$FF94-bscode_length
     36  1894					      endif
     37  1894				  -	      else
     38  1894				  -	      ORG	$FF9C
     39  1894					      endif
     40  1894					      endif
     41  1894
     42  1894
     43  1894				   scoretable
     44  1894		       7e		      .byte.b	%01111110
     45  1895		       42		      .byte.b	%01000010
     46  1896		       42		      .byte.b	%01000010
     47  1897		       42		      .byte.b	%01000010
     48  1898		       42		      .byte.b	%01000010
     49  1899		       42		      .byte.b	%01000010
     50  189a		       42		      .byte.b	%01000010
     51  189b		       7e		      .byte.b	%01111110
     52  189c
     53  189c		       7e		      .byte.b	%01111110
     54  189d		       08		      .byte.b	%00001000
     55  189e		       08		      .byte.b	%00001000
     56  189f		       08		      .byte.b	%00001000
     57  18a0		       08		      .byte.b	%00001000
     58  18a1		       08		      .byte.b	%00001000
     59  18a2		       08		      .byte.b	%00001000
     60  18a3		       38		      .byte.b	%00111000
     61  18a4
     62  18a4		       7e		      .byte.b	%01111110
     63  18a5		       40		      .byte.b	%01000000
     64  18a6		       40		      .byte.b	%01000000
     65  18a7		       40		      .byte.b	%01000000
     66  18a8		       7e		      .byte.b	%01111110
     67  18a9		       02		      .byte.b	%00000010
     68  18aa		       02		      .byte.b	%00000010
     69  18ab		       7e		      .byte.b	%01111110
     70  18ac
     71  18ac		       7e		      .byte.b	%01111110
     72  18ad		       02		      .byte.b	%00000010
     73  18ae		       02		      .byte.b	%00000010
     74  18af		       02		      .byte.b	%00000010
     75  18b0		       7e		      .byte.b	%01111110
     76  18b1		       02		      .byte.b	%00000010
     77  18b2		       02		      .byte.b	%00000010
     78  18b3		       7e		      .byte.b	%01111110
     79  18b4
     80  18b4		       02		      .byte.b	%00000010
     81  18b5		       02		      .byte.b	%00000010
     82  18b6		       02		      .byte.b	%00000010
     83  18b7		       02		      .byte.b	%00000010
     84  18b8		       7e		      .byte.b	%01111110
     85  18b9		       42		      .byte.b	%01000010
     86  18ba		       42		      .byte.b	%01000010
     87  18bb		       42		      .byte.b	%01000010
     88  18bc
     89  18bc		       7e		      .byte.b	%01111110
     90  18bd		       02		      .byte.b	%00000010
     91  18be		       02		      .byte.b	%00000010
     92  18bf		       02		      .byte.b	%00000010
     93  18c0		       7e		      .byte.b	%01111110
     94  18c1		       40		      .byte.b	%01000000
     95  18c2		       40		      .byte.b	%01000000
     96  18c3		       7e		      .byte.b	%01111110
     97  18c4
     98  18c4		       7e		      .byte.b	%01111110
     99  18c5		       42		      .byte.b	%01000010
    100  18c6		       42		      .byte.b	%01000010
    101  18c7		       42		      .byte.b	%01000010
    102  18c8		       7e		      .byte.b	%01111110
    103  18c9		       40		      .byte.b	%01000000
    104  18ca		       40		      .byte.b	%01000000
    105  18cb		       7e		      .byte.b	%01111110
    106  18cc
    107  18cc		       02		      .byte.b	%00000010
    108  18cd		       02		      .byte.b	%00000010
    109  18ce		       02		      .byte.b	%00000010
    110  18cf		       02		      .byte.b	%00000010
    111  18d0		       02		      .byte.b	%00000010
    112  18d1		       02		      .byte.b	%00000010
    113  18d2		       02		      .byte.b	%00000010
    114  18d3		       3e		      .byte.b	%00111110
    115  18d4
    116  18d4		       7e		      .byte.b	%01111110
    117  18d5		       42		      .byte.b	%01000010
    118  18d6		       42		      .byte.b	%01000010
    119  18d7		       42		      .byte.b	%01000010
    120  18d8		       7e		      .byte.b	%01111110
    121  18d9		       42		      .byte.b	%01000010
    122  18da		       42		      .byte.b	%01000010
    123  18db		       7e		      .byte.b	%01111110
    124  18dc
    125  18dc		       02		      .byte.b	%00000010
    126  18dd		       02		      .byte.b	%00000010
    127  18de		       02		      .byte.b	%00000010
    128  18df		       02		      .byte.b	%00000010
    129  18e0		       7e		      .byte.b	%01111110
    130  18e1		       42		      .byte.b	%01000010
    131  18e2		       42		      .byte.b	%01000010
    132  18e3		       7e		      .byte.b	%01111110
    133  18e4
    134  18e4
    135  18e4
    136  18e4
    137  18e4				  -	      ifconst	ROM2k
    138  18e4				  -	      ORG	$F7FC
    139  18e4					      else
    140  18e4					      ifconst	bankswitch
    141  18e4				  -	      if	bankswitch == 8
    142  18e4				  -	      ORG	$2FF4-bscode_length
    143  18e4				  -	      RORG	$FFF4-bscode_length
    144  18e4					      endif
    145  18e4				  -	      if	bankswitch == 16
    146  18e4				  -	      ORG	$4FF4-bscode_length
    147  18e4				  -	      RORG	$FFF4-bscode_length
    148  18e4					      endif
    149  18e4				  -	      if	bankswitch == 32
    150  18e4				  -	      ORG	$8FF4-bscode_length
    151  18e4				  -	      RORG	$FFF4-bscode_length
    152  18e4					      endif
    153  18e4				  -	      else
    154  18e4				  -	      ORG	$FFFC
    155  18e4					      endif
    156  18e4					      endif
    157  18e4							; Provided under the CC0 license. See the included LICENSE.txt for details.
    158  18e4
    159  18e4				   start
    160  18e4		       78		      sei
    161  18e5		       d8		      cld
    162  18e6		       a0 00		      ldy	#0
    163  18e8		       a5 d0		      lda	$D0
    164  18ea		       c9 2c		      cmp	#$2C	;check RAM location #1
    165  18ec		       d0 07		      bne	MachineIs2600
    166  18ee		       a5 d1		      lda	$D1
    167  18f0		       c9 a9		      cmp	#$A9	;check RAM location #2
    168  18f2		       d0 01		      bne	MachineIs2600
    169  18f4		       88		      dey
    170  18f5				   MachineIs2600
    171  18f5		       a2 00		      ldx	#0
    172  18f7		       8a		      txa
    173  18f8				   clearmem
    174  18f8		       e8		      inx
    175  18f9		       9a		      txs
    176  18fa		       48		      pha
    177  18fb		       d0 fb		      bne	clearmem
    178  18fd		       84 cb		      sty	temp1
    179  18ff		       a2 08		      ldx	#8
    180  1901		       86 ca		      stx	playfieldpos
    181  1903		       8e 58 10 	      stx	FASTFETCH
    182  1906		       a2 08		      ldx	#8
    183  1908		       a9 e0		      lda	#224
    184  190a				   inityloop
    185  190a		       95 9a		      sta	player1y,x
    186  190c		       ca		      dex
    187  190d		       10 fb		      bpl	inityloop
    188  190f
    189  190f		       a9 01		      lda	#1
    190  1911		       85 0a		      sta	CTRLPF
    191  1913		       ad 84 02 	      lda	INTIM
    192  1916		       8d 71 10 	      sta	RWRITE0
    193  1919		       a9 00		      lda	#0
    194  191b		       8d 38 10 	      STA	DF0FRACINC
    195  191e		       8d 39 10 	      STA	DF1FRACINC
    196  1921		       8d 3a 10 	      STA	DF2FRACINC
    197  1924		       8d 3b 10 	      STA	DF3FRACINC
    198  1927		       8d 3c 10 	      STA	DF4FRACINC
    199  192a		       8d 3e 10 	      STA	DF6FRACINC
    200  192d		       a9 a5		      lda	#<USERSTACK
    201  192f		       8d 57 10 	      STA	DF7LOW
    202  1932		       a9 0d		      lda	#(>USERSTACK) & $0F
    203  1934		       8d 6f 10 	      STA	DF7HI
    204  1937		       a9 ff		      lda	#255
    205  1939		       8d 5a 10 	      sta	CALLFUNCTION	; zero-fill fetcher
    206  193c
    207  193c		       a9 1f		      lda	#>(game-1)
    208  193e		       48		      pha
    209  193f		       a9 8a		      lda	#<(game-1)
    210  1941		       48		      pha
    211  1942		       48		      pha
    212  1943		       48		      pha
    213  1944		       a2 01		      ldx	#1
    214  1946		       4c ee df 	      jmp	BS_jsr
    215  1949				   drawscreen
    216  1949		       a9 01		      lda	#1
    217  194b		       85 2c		      sta	CXCLR
    218  194d		       85 09		      sta	COLUBK	; REVENG - don't start with the lastline color
    219  194f
    220  194f				   fufu
    221  194f		       ad 84 02 	      lda	INTIM
    222  1952		       30 fb		      bmi	fufu
    223  1954
      0  1954					      VERTICAL_SYNC
      1  1954		       a9 02		      LDA	#$02
      2  1956		       85 02		      STA	WSYNC
      3  1958		       85 00		      STA	VSYNC
      4  195a		       85 02		      STA	WSYNC
      5  195c		       85 02		      STA	WSYNC
      6  195e		       4a		      LSR
      7  195f		       85 02		      STA	WSYNC
      8  1961		       85 00		      STA	VSYNC
    225  1963
    226  1963		       a9 a9		      lda	#41+128	;was 37 - do more w/c code
    227  1965		       8d 96 02 	      sta	TIM64T
    228  1968
    229  1968							; adjust for pfpos?
    230  1968
    231  1968							; set zero to properly enter C code
    232  1968		       a9 a4		      lda	#<C_function
    233  196a		       8d 50 10 	      sta	DF0LOW
    234  196d		       a9 01		      lda	#(>C_function) & $0F
    235  196f		       8d 68 10 	      sta	DF0HI
    236  1972		       a9 00		      lda	#0
    237  1974		       8d 78 10 	      sta	DF0WRITE
    238  1977
    239  1977							; REVENG - pass the number of vsprites we want...
    240  1977					      ifnconst	dpcspritemax
    241  1977				  -	      ifconst	readpaddle
    242  1977				  -	      lda	#8
    243  1977					      else
    244  1977		       a9 09		      lda	#9
    245  1979					      endif
    246  1979				  -	      else
    247  1979				  -	      lda	#dpcspritemax
    248  1979					      endif
    249  1979		       8d 78 10 	      sta	DF0WRITE
    250  197c
    251  197c		       a5 80		      lda	player0x
    252  197e		       85 8f		      sta	player0xcoll	; detect p0x colls
    253  1980
    254  1980							; copy RAM to fetcher for C-code
    255  1980		       a9 e2		      lda	#<(CcodeData + RAMcopylength)
    256  1982		       8d 50 10 	      sta	DF0LOW
    257  1985		       a9 01		      lda	#(>(CcodeData + RAMcopylength)) & $0F
    258  1987		       8d 68 10 	      sta	DF0HI
    259  198a		       a2 39		      ldx	#RAMcopylength-1
    260  198c				   copy2fetcherloop
    261  198c		       b5 85		      lda	RAMcopybegin,x
    262  198e		       8d 60 10 	      sta	DF0PUSH
    263  1991		       ca		      dex
    264  1992		       10 f8		      bpl	copy2fetcherloop
    265  1994
    266  1994		       a9 ff		      lda	#255
    267  1996		       8d 5a 10 	      sta	CALLFUNCTION
    268  1999
    269  1999							; copy modified data back (just need first 6 bytes, which is sprite sort data)
    270  1999		       a2 ed		      ldx	#256-19
    271  199b				   copyfromfetcherloop
    272  199b		       ad 08 10 	      lda	DF0DATA
    273  199e		       95 98		      sta	RAMcopybegin+19,x
    274  19a0		       e8		      inx
    275  19a1		       30 f8		      bmi	copyfromfetcherloop
    276  19a3
    277  19a3		       20 34 1e 	      jsr	kernel_setup
    278  19a6		       85 02		      sta	WSYNC
    279  19a8		       a0 80		      ldy	#$80
    280  19aa		       84 20		      sty	HMP0
    281  19ac		       84 21		      sty	HMP1
    282  19ae		       84 22		      sty	HMM0
    283  19b0		       84 23		      sty	HMM1
    284  19b2		       84 24		      sty	HMBL
    285  19b4
    286  19b4							; run possible vblank bB code
    287  19b4					      ifconst	vblank_bB_code
    288  19b4		       20 9d 1f 	      jsr	vblank_bB_code
    289  19b7					      endif
    290  19b7
    291  19b7		       20 fc 1c 	      jsr	set_fetchers
    292  19ba
    293  19ba		       a2 07		      ldx	#7
    294  19bc				   setloopfrac
    295  19bc		       bd 77 1d 	      lda	dffraclow,x
    296  19bf		       9d 28 10 	      sta	DF0FRACLOW,x
    297  19c2		       bd 7f 1d 	      lda	dffrachi,x
    298  19c5		       9d 30 10 	      sta	DF0FRACHI,x
    299  19c8		       ca		      dex
    300  19c9		       10 f1		      bpl	setloopfrac
    301  19cb							; lda #255
    302  19cb		       8e 3d 10 	      STx	DF5FRACINC	; x=255 right now
    303  19ce		       8e 3f 10 	      STx	DF7FRACINC
    304  19d1		       ad 1d 10 	      lda	DF5FRACDATA	; priming read
    305  19d4		       ad 1f 10 	      lda	DF7FRACDATA	; priming read
    306  19d7
    307  19d7		       a6 85		      ldx	SpriteGfxIndex
    308  19d9		       b5 af		      lda	_NUSIZ1,x	; top NUSIZ/REFP
    309  19db		       85 05		      sta	NUSIZ1
    310  19dd		       85 0c		      sta	REFP1
    311  19df
    312  19df							;REVENG - allow P0 to wrap at the top
    313  19df				   startwrapfix
    314  19df		       a9 ff		      lda	#255
    315  19e1		       85 cc		      sta	temp2
    316  19e3		       18		      clc
    317  19e4		       a5 99		      lda	player0y
    318  19e6		       65 a5		      adc	player0height
    319  19e8		       38		      sec
    320  19e9		       c5 a5		      cmp	player0height
    321  19eb		       90 04		      bcc	skipwrapfix
    322  19ed		       a9 00		      lda	#0
    323  19ef		       85 cc		      sta	temp2
    324  19f1				   skipwrapfix
    325  19f1
    326  19f1		       38		      sec
    327  19f2		       a9 08		      lda	#<P0GFX
    328  19f4		       e5 99		      sbc	player0y
    329  19f6		       8d 52 10 	      sta	DF2LOW
    330  19f9		       a9 d4		      lda	#>P0GFX
    331  19fb							;sbc #0
    332  19fb		       e5 cc		      sbc	temp2
    333  19fd		       8d 6a 10 	      sta	DF2HI
    334  1a00		       a9 07		      lda	#<(P0GFX-1)
    335  1a02		       8d 42 10 	      sta	DF2TOP
    336  1a05		       38		      sec
    337  1a06		       65 a5		      adc	player0height
    338  1a08		       8d 4a 10 	      sta	DF2BOT
    339  1a0b
    340  1a0b							;REVENG - 1/2 of the COLUM0 fix. the rest is in main.c
    341  1a0b		       a9 08		      lda	#<(P0COLOR)
    342  1a0d		       8d 50 10 	      sta	DF0LOW
    343  1a10		       85 cc		      sta	temp2
    344  1a12		       a9 d5		      lda	#>(P0COLOR)
    345  1a14		       8d 68 10 	      sta	DF0HI
    346  1a17
    347  1a17							; ball
    348  1a17		       a9 07		      lda	#<(P1GFX-1)
    349  1a19		       18		      clc
    350  1a1a		       65 c1		      adc	bally
    351  1a1c		       8d 43 10 	      sta	DF3TOP
    352  1a1f		       38		      sec
    353  1a20		       65 c4		      adc	ballheight
    354  1a22		       8d 4b 10 	      sta	DF3BOT
    355  1a25
    356  1a25							; missile0
    357  1a25		       a5 cc		      lda	temp2
    358  1a27		       18		      clc
    359  1a28		       65 bf		      adc	missile0y
    360  1a2a		       8d 40 10 	      sta	DF0TOP
    361  1a2d		       38		      sec
    362  1a2e		       65 c2		      adc	missile0height
    363  1a30		       8d 48 10 	      sta	DF0BOT
    364  1a33
    365  1a33
    366  1a33				   fuu
    367  1a33		       ad 84 02 	      lda	INTIM
    368  1a36		       30 fb		      bmi	fuu
    369  1a38		       85 02		      sta	WSYNC
    370  1a3a							;     ldy #$80
    371  1a3a							;     sty HMP0
    372  1a3a							;     sty HMP1
    373  1a3a							;     sty HMM0 
    374  1a3a							;     sty HMM1
    375  1a3a							;     sty HMBL
    376  1a3a							; relocated code above prior to vblank, to allow for Cosmic Ark starfield
    377  1a3a							; and/or skewed players
      0  1a3a					      sleep	17
      1  1a3a				   .CYCLES    SET	17
      2  1a3a
      3  1a3a				  -	      IF	.CYCLES < 2
      4  1a3a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1a3a				  -	      ERR
      6  1a3a					      ENDIF
      7  1a3a
      8  1a3a					      IF	.CYCLES & 1
      9  1a3a					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1a3a		       04 00		      nop	0
     11  1a3c				  -	      ELSE
     12  1a3c				  -	      bit	VSYNC
     13  1a3c					      ENDIF
     14  1a3c				   .CYCLES    SET	.CYCLES - 3
     15  1a3c					      ENDIF
     16  1a3c
     17  1a3c					      REPEAT	.CYCLES / 2
     18  1a3c		       ea		      nop
     17  1a3c					      REPEND
     18  1a3d		       ea		      nop
     17  1a3d					      REPEND
     18  1a3e		       ea		      nop
     17  1a3e					      REPEND
     18  1a3f		       ea		      nop
     17  1a3f					      REPEND
     18  1a40		       ea		      nop
     17  1a40					      REPEND
     18  1a41		       ea		      nop
     17  1a41					      REPEND
     18  1a42		       ea		      nop
     19  1a43					      REPEND
    379  1a43
    380  1a43		       a9 d3		      lda	#KERNEL_LINES
    381  1a45		       8d 96 02 	      sta	TIM64T
    382  1a48		       a9 01		      lda	#1
    383  1a4a		       85 27		      sta	VDELBL
    384  1a4c		       85 25		      sta	VDELP0
    385  1a4e
    386  1a4e							; missile1
    387  1a4e		       a9 07		      lda	#<(P1COLOR-1)
    388  1a50		       18		      clc
    389  1a51		       65 c0		      adc	missile1y
    390  1a53		       8d 41 10 	      sta	DF1TOP
    391  1a56		       38		      sec
    392  1a57		       65 c3		      adc	missile1height
    393  1a59		       8d 49 10 	      sta	DF1BOT
    394  1a5c
    395  1a5c		       a9 00		      lda	#0
    396  1a5e		       85 01		      sta	VBLANK
    397  1a60		       8d 58 10 	      sta	FASTFETCH
    398  1a63							;sleep 7
    399  1a63		       a9 12		      lda	#<DF2DATAW	; REVENG - added so GRP0 is at TOP
    400  1a65		       85 1b		      STA	GRP0	; 36 (VDEL)   ; ""
      0  1a67					      sleep	2	; ""
      1  1a67				   .CYCLES    SET	2
      2  1a67
      3  1a67				  -	      IF	.CYCLES < 2
      4  1a67				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1a67				  -	      ERR
      6  1a67					      ENDIF
      7  1a67
      8  1a67				  -	      IF	.CYCLES & 1
      9  1a67				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1a67				  -	      nop	0
     11  1a67				  -	      ELSE
     12  1a67				  -	      bit	VSYNC
     13  1a67				  -	      ENDIF
     14  1a67				  -.CYCLES    SET	.CYCLES - 3
     15  1a67					      ENDIF
     16  1a67
     17  1a67					      REPEAT	.CYCLES / 2
     18  1a67		       ea		      nop
     19  1a68					      REPEND
    402  1a68
    403  1a68		       a9 18		      lda	#<DF0FRACDATA
    404  1a6a		       85 0e		      sta	PF1	; (PF1L)
    405  1a6c
    406  1a6c							; enter at cycle ??
    407  1a6c				   loop
    408  1a6c		       a9 08		      lda	#<DF0DATA	;74
    409  1a6e		       85 06		      STA	COLUP0	; 1
    410  1a70		       a9 09		      lda	#<DF1DATA	;3
    411  1a72				   loop2
    412  1a72		       85 07		      STA	COLUP1	; 6
    413  1a74		       a9 0b		      lda	#<DF3DATA
    414  1a76		       85 1c		      STA	GRP1	; 11
    415  1a78		       a9 20		      lda	#<DF0FLAG
    416  1a7a		       85 1d		      STA	ENAM0	; 16
    417  1a7c
    418  1a7c		       a9 1e		      lda	#<DF6FRACDATA
    419  1a7e		       85 09		      sta	COLUBK	; 21
    420  1a80		       a9 1c		      lda	#<DF4FRACDATA
    421  1a82		       85 08		      sta	COLUPF	; 26
    422  1a84		       a9 19		      lda	#<DF1FRACDATA
    423  1a86		       85 0f		      sta	PF2	; 31 (PF2L)
    424  1a88				   loop3
    425  1a88		       a9 12		      lda	#<DF2DATAW
    426  1a8a		       85 1b		      STA	GRP0	; 36 (VDEL)
    427  1a8c		       a9 23		      lda	#<DF3FLAG
    428  1a8e		       85 1f		      STA	ENABL	; 41 (VDEL)
    429  1a90		       a2 70		      ldx	#$70	;in case we get kernel 6
    430  1a92		       a9 1a		      lda	#<DF2FRACDATA	;45
    431  1a94		       85 0f		      sta	PF2	; 48
    432  1a96		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    433  1a98		       a9 1b		      lda	#<DF3FRACDATA	;53
    434  1a9a		       85 0e		      sta	PF1	; 56
    435  1a9c		       a9 0c		      lda	#<DF4DATA	; 58 this is the repos info
    436  1a9e		       f0 44		      beq	repo	;60/61
    437  1aa0				   norepo		; 60
    438  1aa0		       a8		      tay		; 62
    439  1aa1		       a9 08		      lda	#<DF0DATA	; 64
    440  1aa3
    441  1aa3		       ae 84 02 	      ldx	INTIM	; 68 timed for 192 lines
    442  1aa6		       f0 57		      beq	exitkernel	; 70/71
    443  1aa8		       85 2a		      sta	HMOVE	; 73
    444  1aaa
    445  1aaa		       85 06		      STA	COLUP0	; 0
    446  1aac		       a9 09		      lda	#<DF1DATA	;2
    447  1aae		       85 07		      STA	COLUP1	;5
    448  1ab0		       a9 0b		      lda	#<DF3DATA
    449  1ab2		       85 1c		      STA	GRP1	; 10
    450  1ab4		       a9 21		      lda	#<DF1FLAG
    451  1ab6		       85 1e		      STA	ENAM1	; 15
    452  1ab8		       a9 18		      lda	#<DF0FRACDATA
    453  1aba		       85 0e		      sta	PF1	; 20 (PF1L)
    454  1abc		       a9 19		      lda	#<DF1FRACDATA
    455  1abe		       85 0f		      sta	PF2	; 25 (PF2L)
    456  1ac0		       a9 12		      lda	#<DF2DATAW
    457  1ac2		       85 1b		      STA	GRP0	; 30 (VDEL)
    458  1ac4		       a9 23		      lda	#<DF3FLAG
    459  1ac6		       85 1f		      STA	ENABL	; 35 (VDEL)
    460  1ac8		       88		      dey		; 37
    461  1ac9		       8c 64 10 	      STY	DF4PUSH	; 41
    462  1acc		       a0 80		      ldy	#$80	; 43 no movement next line
    463  1ace		       a9 1a		      lda	#<DF2FRACDATA	;45
    464  1ad0		       85 0f		      sta	PF2	; 48
    465  1ad2		       84 21		      sty	HMP1	; 51 ; from prev. cycle: $80=nomove
    466  1ad4		       a9 1b		      lda	#<DF3FRACDATA	;53
    467  1ad6		       85 0e		      sta	PF1	; 56
    468  1ad8					      ifnconst	DPC_kernel_options
    469  1ad8							;sleep 8 ; REVENG - timing is off - results in a garbled screen
      0  1ad8					      sleep	5	; this is better
      1  1ad8				   .CYCLES    SET	5
      2  1ad8
      3  1ad8				  -	      IF	.CYCLES < 2
      4  1ad8				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1ad8				  -	      ERR
      6  1ad8					      ENDIF
      7  1ad8
      8  1ad8					      IF	.CYCLES & 1
      9  1ad8					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1ad8		       04 00		      nop	0
     11  1ada				  -	      ELSE
     12  1ada				  -	      bit	VSYNC
     13  1ada					      ENDIF
     14  1ada				   .CYCLES    SET	.CYCLES - 3
     15  1ada					      ENDIF
     16  1ada
     17  1ada					      REPEAT	.CYCLES / 2
     18  1ada		       ea		      nop
     19  1adb					      REPEND
    471  1adb				  -	      else
    472  1adb				  -	      bit	DPC_kernel_options
    473  1adb				  -	      if	(DPC_kernel_options > $3F)
    474  1adb				  -	      bmi	COLfound
    475  1adb				  -	      else
    476  1adb				  -	      bpl	COLfound
    477  1adb				  -	      endif
    478  1adb					      endif
    479  1adb		       86 ce		      stx	temp4	; +3
    480  1add
    481  1add				   getbackearly
    482  1add		       a9 18		      lda	#<DF0FRACDATA	; +2
    483  1adf		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    484  1ae1		       4c 6c 5a 	      JMP	loop+$4000	; 72
    485  1ae4
    486  1ae4				  -	      ifconst	DPC_kernel_options
    487  1ae4				  -COLfound
    488  1ae4				  -	      lda	DF0FRACDATA
    489  1ae4				  -	      sta	PF1	; 69 (PF1L) too early?
    490  1ae4				  -	      JMP	loop+$4000	; 72
    491  1ae4					      endif
    492  1ae4
    493  1ae4				   repo
    494  1ae4		       ac 1f 10 	      ldy	DF7FRACDATA	; 65
    495  1ae7		       a9 18		      lda	#<DF0FRACDATA	; 67 preload PF1L for next line
    496  1ae9				  -	      if	((>repo) > (>norepo))
    497  1ae9				  -	      STA	PF1
    498  1ae9					      else
    499  1ae9		       8d 0e 00 	      STA.w	PF1	; 71 ; sta.w if page doesn't wrap
    500  1aec					      endif
    501  1aec		       a9 08		      lda	#<DF0DATA	;73
    502  1aee		       85 06		      STA	COLUP0	; 0
    503  1af0		       a9 09		      lda	#<DF1DATA
    504  1af2		       85 07		      STA	COLUP1	;5
    505  1af4		       a9 0b		      lda	#<DF3DATA
    506  1af6		       85 1c		      STA	GRP1	; 10
    507  1af8		       a9 21		      lda	#<DF1FLAG
    508  1afa		       85 1e		      STA	ENAM1	; 15
    509  1afc							; repos info holds HMMx
    510  1afc		       6c 0d 10 	      jmp	(DF5DATA)	; 20 grabs df6/df7=lo/hi
    511  1aff
    512  1aff				   exitkernel		; exit the kernel
    513  1aff		       20 c3 5e 	      jsr	scorekernel+$4000	; 1
    514  1b02				   exit
    515  1b02		       a2 ff		      ldx	#255
    516  1b04		       8e 58 10 	      stx	FASTFETCH
    517  1b07		       85 02		      sta	WSYNC
    518  1b09				  -	      ifconst	qtcontroller
    519  1b09				  -	      lda	qtcontroller
    520  1b09				  -	      lsr		; bit 0 in carry
    521  1b09				  -	      lda	#4
    522  1b09				  -	      ror		; carry into top of A
    523  1b09					      else
    524  1b09		       a9 02		      lda	#2
    525  1b0b					      endif		; qtcontroller
    526  1b0b		       85 01		      STA	VBLANK
    527  1b0d		       a9 a7		      lda	#OVERSCAN_LINES
    528  1b0f		       8d 96 02 	      sta	TIM64T
    529  1b12		       38		      sec
    530  1b13		       a9 d3		      lda	#KERNEL_LINES
    531  1b15		       e5 ce		      sbc	temp4
    532  1b17		       aa		      tax
    533  1b18		       4a		      lsr
    534  1b19		       4a		      lsr
    535  1b1a		       85 cd		      sta	temp3	; div4
    536  1b1c		       4a		      lsr
    537  1b1d		       4a		      lsr
    538  1b1e		       85 cc		      sta	temp2	; div16
    539  1b20		       4a		      lsr
    540  1b21		       85 cb		      sta	temp1	; div32
    541  1b23		       18		      clc
    542  1b24		       8a		      txa
    543  1b25		       65 cc		      adc	temp2
    544  1b27		       65 cb		      adc	temp1
    545  1b29		       38		      sec
    546  1b2a		       e5 cd		      sbc	temp3
    547  1b2c		       85 ce		      sta	temp4	; approx line of first pf coll
      0  1b2e					      RETURN
      1  1b2e				  -	      ifnconst	bankswitch
      2  1b2e				  -	      rts
      3  1b2e					      else
      4  1b2e		       4c e0 df 	      jmp	BS_return
      5  1b31					      endif
    549  1b31
    550  1b31							; jmp exit
    551  1b31
    552  1b31							; kernels resp1 23/28/33/38/43/48/53/58/63/68/73
    553  1b31
    554  1b31				   kernel1
    555  1b31		       85 11		      sta	RESP1	; 23
    556  1b33		       a9 12		      lda	#<DF2DATAW
    557  1b35		       85 1b		      STA	GRP0	; 28 (VDEL)
    558  1b37		       a9 19		      lda	#<DF1FRACDATA
    559  1b39		       85 0f		      STA	PF2	; 33
    560  1b3b		       a9 23		      lda	#<DF3FLAG
    561  1b3d		       85 1f		      STA	ENABL	; 38 (VDEL)
      0  1b3f					      sleep	5
      1  1b3f				   .CYCLES    SET	5
      2  1b3f
      3  1b3f				  -	      IF	.CYCLES < 2
      4  1b3f				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b3f				  -	      ERR
      6  1b3f					      ENDIF
      7  1b3f
      8  1b3f					      IF	.CYCLES & 1
      9  1b3f					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b3f		       04 00		      nop	0
     11  1b41				  -	      ELSE
     12  1b41				  -	      bit	VSYNC
     13  1b41					      ENDIF
     14  1b41				   .CYCLES    SET	.CYCLES - 3
     15  1b41					      ENDIF
     16  1b41
     17  1b41					      REPEAT	.CYCLES / 2
     18  1b41		       ea		      nop
     19  1b42					      REPEND
    563  1b42		       a9 1a		      lda	#<DF2FRACDATA	;45
    564  1b44		       85 0f		      sta	PF2	; 48
    565  1b46		       a9 1b		      lda	#<DF3FRACDATA	;50
    566  1b48		       85 0e		      sta	PF1	; 53
    567  1b4a		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    568  1b4c		       85 05		      STA	NUSIZ1	; 58
    569  1b4e		       85 0c		      STA	REFP1	; 61
    570  1b50		       4c dd 1a 	      jmp	getbackearly	;64
    571  1b53
    572  1b53				   kernel2
    573  1b53		       a9 12		      lda	#<DF2DATAW
    574  1b55		       85 1b		      STA	GRP0	; 25 (VDEL)
    575  1b57		       85 11		      sta	RESP1	;28
    576  1b59		       a9 19		      lda	#<DF1FRACDATA
    577  1b5b		       85 0f		      STA	PF2	; 33
    578  1b5d		       a9 23		      lda	#<DF3FLAG
    579  1b5f		       85 1f		      STA	ENABL	; 38 (VDEL)
      0  1b61					      sleep	5
      1  1b61				   .CYCLES    SET	5
      2  1b61
      3  1b61				  -	      IF	.CYCLES < 2
      4  1b61				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b61				  -	      ERR
      6  1b61					      ENDIF
      7  1b61
      8  1b61					      IF	.CYCLES & 1
      9  1b61					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b61		       04 00		      nop	0
     11  1b63				  -	      ELSE
     12  1b63				  -	      bit	VSYNC
     13  1b63					      ENDIF
     14  1b63				   .CYCLES    SET	.CYCLES - 3
     15  1b63					      ENDIF
     16  1b63
     17  1b63					      REPEAT	.CYCLES / 2
     18  1b63		       ea		      nop
     19  1b64					      REPEND
    581  1b64		       a9 1a		      lda	#<DF2FRACDATA	;45
    582  1b66		       85 0f		      sta	PF2	; 48
    583  1b68		       a9 1b		      lda	#<DF3FRACDATA	;50
    584  1b6a		       85 0e		      sta	PF1	; 53
    585  1b6c		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    586  1b6e		       85 05		      STA	NUSIZ1
    587  1b70		       85 0c		      STA	REFP1
    588  1b72		       4c dd 1a 	      jmp	getbackearly	;64
    589  1b75
    590  1b75				   kernel3
    591  1b75		       a9 12		      lda	#<DF2DATAW
    592  1b77		       85 1b		      STA	GRP0	; 25 (VDEL)
    593  1b79		       a9 19		      lda	#<DF1FRACDATA
    594  1b7b		       85 0f		      STA	PF2	; 30
    595  1b7d		       85 11		      sta	RESP1	;33
    596  1b7f		       a9 23		      lda	#<DF3FLAG
    597  1b81		       85 1f		      STA	ENABL	; 38 (VDEL)
      0  1b83					      sleep	5
      1  1b83				   .CYCLES    SET	5
      2  1b83
      3  1b83				  -	      IF	.CYCLES < 2
      4  1b83				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1b83				  -	      ERR
      6  1b83					      ENDIF
      7  1b83
      8  1b83					      IF	.CYCLES & 1
      9  1b83					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1b83		       04 00		      nop	0
     11  1b85				  -	      ELSE
     12  1b85				  -	      bit	VSYNC
     13  1b85					      ENDIF
     14  1b85				   .CYCLES    SET	.CYCLES - 3
     15  1b85					      ENDIF
     16  1b85
     17  1b85					      REPEAT	.CYCLES / 2
     18  1b85		       ea		      nop
     19  1b86					      REPEND
    599  1b86		       a9 1a		      lda	#<DF2FRACDATA	;45
    600  1b88		       85 0f		      sta	PF2	; 48
    601  1b8a		       a9 1b		      lda	#<DF3FRACDATA	;50
    602  1b8c		       85 0e		      sta	PF1	; 53
    603  1b8e		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    604  1b90		       85 05		      STA	NUSIZ1
    605  1b92		       85 0c		      STA	REFP1
    606  1b94		       4c dd 1a 	      JMP	getbackearly	; 64
    607  1b97
    608  1b97				   kernel4
    609  1b97		       a9 12		      lda	#<DF2DATAW
    610  1b99		       85 1b		      STA	GRP0	; 25 (VDEL)
    611  1b9b		       a9 23		      lda	#<DF3FLAG
    612  1b9d		       85 1f		      STA	ENABL	; 30(VDEL)
    613  1b9f		       a9 19		      lda	#<DF1FRACDATA
    614  1ba1		       85 0f		      STA	PF2	; 35
    615  1ba3		       85 11		      sta	RESP1	;38
      0  1ba5					      sleep	5
      1  1ba5				   .CYCLES    SET	5
      2  1ba5
      3  1ba5				  -	      IF	.CYCLES < 2
      4  1ba5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1ba5				  -	      ERR
      6  1ba5					      ENDIF
      7  1ba5
      8  1ba5					      IF	.CYCLES & 1
      9  1ba5					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1ba5		       04 00		      nop	0
     11  1ba7				  -	      ELSE
     12  1ba7				  -	      bit	VSYNC
     13  1ba7					      ENDIF
     14  1ba7				   .CYCLES    SET	.CYCLES - 3
     15  1ba7					      ENDIF
     16  1ba7
     17  1ba7					      REPEAT	.CYCLES / 2
     18  1ba7		       ea		      nop
     19  1ba8					      REPEND
    617  1ba8		       a9 1a		      lda	#<DF2FRACDATA	;45
    618  1baa		       85 0f		      sta	PF2	; 48
    619  1bac		       a9 1b		      lda	#<DF3FRACDATA	;50
    620  1bae		       85 0e		      sta	PF1	; 53
    621  1bb0		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    622  1bb2		       85 05		      STA	NUSIZ1	; 58
    623  1bb4		       85 0c		      STA	REFP1	; 61
    624  1bb6		       4c dd 1a 	      JMP	getbackearly	; 64
    625  1bb9
    626  1bb9				   kernel5
    627  1bb9		       a9 12		      lda	#<DF2DATAW
    628  1bbb		       85 1b		      STA	GRP0	; (VDEL)
    629  1bbd		       a9 23		      lda	#<DF3FLAG
    630  1bbf		       85 1f		      STA	ENABL	; (VDEL)
    631  1bc1		       a9 19		      lda	#<DF1FRACDATA
    632  1bc3		       85 0f		      STA	PF2	; 35
      0  1bc5					      sleep	5
      1  1bc5				   .CYCLES    SET	5
      2  1bc5
      3  1bc5				  -	      IF	.CYCLES < 2
      4  1bc5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1bc5				  -	      ERR
      6  1bc5					      ENDIF
      7  1bc5
      8  1bc5					      IF	.CYCLES & 1
      9  1bc5					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1bc5		       04 00		      nop	0
     11  1bc7				  -	      ELSE
     12  1bc7				  -	      bit	VSYNC
     13  1bc7					      ENDIF
     14  1bc7				   .CYCLES    SET	.CYCLES - 3
     15  1bc7					      ENDIF
     16  1bc7
     17  1bc7					      REPEAT	.CYCLES / 2
     18  1bc7		       ea		      nop
     19  1bc8					      REPEND
    634  1bc8		       85 11		      sta	RESP1	;43
    635  1bca		       a9 1a		      lda	#<DF2FRACDATA	;45
    636  1bcc		       85 0f		      sta	PF2	; 48
    637  1bce		       a9 1b		      lda	#<DF3FRACDATA	;50
    638  1bd0		       85 0e		      sta	PF1	; 53
    639  1bd2		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    640  1bd4		       85 05		      STA	NUSIZ1
    641  1bd6		       85 0c		      STA	REFP1
    642  1bd8		       4c dd 1a 	      JMP	getbackearly	; 64
    643  1bdb
    644  1bdb				   kernel6
    645  1bdb		       a9 12		      lda	#<DF2DATAW
    646  1bdd		       85 1b		      STA	GRP0	; 25 (VDEL)
    647  1bdf		       a9 23		      lda	#<DF3FLAG
    648  1be1		       85 1f		      STA	ENABL	; 30 (VDEL)
    649  1be3		       a9 19		      lda	#<DF1FRACDATA
    650  1be5		       85 0f		      STA	PF2	; 35
    651  1be7		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    652  1be9		       85 05		      STA	NUSIZ1	; 40
    653  1beb		       85 0c		      STA	REFP1	; 43
    654  1bed		       a9 1a		      lda	#<DF2FRACDATA	;45
    655  1bef		       85 0f		      sta	PF2	; 48
    656  1bf1		       a9 1b		      lda	#<DF3FRACDATA	;50
    657  1bf3		       85 11		      sta	RESP1	;53
    658  1bf5							; do a move right by 15
    659  1bf5		       85 0e		      sta	PF1	; 56
    660  1bf7		       86 21		      stx	HMP1	; 59
    661  1bf9		       a9 19		      lda	#<DF1FRACDATA
    662  1bfb		       85 0f		      sta	PF2	; 64 (PF2L)
    663  1bfd		       a9 18		      lda	#<DF0FRACDATA
    664  1bff		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    665  1c01		       a9 08		      lda	#<DF0DATA	; 71
    666  1c03		       85 2a		      sta	HMOVE	; 74 adjust to +15 right
    667  1c05
    668  1c05		       85 06		      STA	COLUP0	; 1
    669  1c07		       a9 09		      lda	#<DF1DATA
    670  1c09		       85 07		      sta	COLUP1	; 6
    671  1c0b		       a9 0b		      lda	#<DF3DATA
    672  1c0d		       85 1c		      STA	GRP1	; 11
    673  1c0f		       a9 20		      lda	#<DF0FLAG
    674  1c11		       85 1d		      STA	ENAM0	; 16
    675  1c13		       a9 1e		      lda	#<DF6FRACDATA
    676  1c15		       85 09		      STA	COLUBK	; 21
    677  1c17		       a9 1c		      lda	#<DF4FRACDATA
    678  1c19		       85 08		      sta	COLUPF	; 26
      0  1c1b					      sleep	2
      1  1c1b				   .CYCLES    SET	2
      2  1c1b
      3  1c1b				  -	      IF	.CYCLES < 2
      4  1c1b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c1b				  -	      ERR
      6  1c1b					      ENDIF
      7  1c1b
      8  1c1b				  -	      IF	.CYCLES & 1
      9  1c1b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c1b				  -	      nop	0
     11  1c1b				  -	      ELSE
     12  1c1b				  -	      bit	VSYNC
     13  1c1b				  -	      ENDIF
     14  1c1b				  -.CYCLES    SET	.CYCLES - 3
     15  1c1b					      ENDIF
     16  1c1b
     17  1c1b					      REPEAT	.CYCLES / 2
     18  1c1b		       ea		      nop
     19  1c1c					      REPEND
    680  1c1c		       4c 88 1a 	      jmp	loop3	; 31
    681  1c1f
    682  1c1f				   kernel7
    683  1c1f		       a9 12		      lda	#<DF2DATAW
    684  1c21		       85 1b		      STA	GRP0	; 25 (VDEL)
    685  1c23		       a9 23		      lda	#<DF3FLAG
    686  1c25		       85 1f		      STA	ENABL	; 30 (VDEL)
    687  1c27		       a9 19		      lda	#<DF1FRACDATA
    688  1c29		       85 0f		      STA	PF2	; 35
    689  1c2b		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    690  1c2d		       85 05		      STA	NUSIZ1	; 40
    691  1c2f		       85 0c		      STA	REFP1	; 43
    692  1c31		       a9 1a		      lda	#<DF2FRACDATA	;45
    693  1c33		       85 0f		      sta	PF2	; 48
      0  1c35					      sleep	2
      1  1c35				   .CYCLES    SET	2
      2  1c35
      3  1c35				  -	      IF	.CYCLES < 2
      4  1c35				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c35				  -	      ERR
      6  1c35					      ENDIF
      7  1c35
      8  1c35				  -	      IF	.CYCLES & 1
      9  1c35				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c35				  -	      nop	0
     11  1c35				  -	      ELSE
     12  1c35				  -	      bit	VSYNC
     13  1c35				  -	      ENDIF
     14  1c35				  -.CYCLES    SET	.CYCLES - 3
     15  1c35					      ENDIF
     16  1c35
     17  1c35					      REPEAT	.CYCLES / 2
     18  1c35		       ea		      nop
     19  1c36					      REPEND
    695  1c36		       85 11		      sta	RESP1	;53
    696  1c38		       a9 1b		      lda	#<DF3FRACDATA	;55
    697  1c3a		       85 0e		      sta	PF1	; 58
      0  1c3c					      sleep	3
      1  1c3c				   .CYCLES    SET	3
      2  1c3c
      3  1c3c				  -	      IF	.CYCLES < 2
      4  1c3c				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c3c				  -	      ERR
      6  1c3c					      ENDIF
      7  1c3c
      8  1c3c					      IF	.CYCLES & 1
      9  1c3c					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c3c		       04 00		      nop	0
     11  1c3e				  -	      ELSE
     12  1c3e				  -	      bit	VSYNC
     13  1c3e					      ENDIF
     14  1c3e				   .CYCLES    SET	.CYCLES - 3
     15  1c3e					      ENDIF
     16  1c3e
     17  1c3e				  -	      REPEAT	.CYCLES / 2
     18  1c3e				  -	      nop
     19  1c3e					      REPEND
    699  1c3e		       4c dd 1a 	      JMP	getbackearly	; 64
    700  1c41
    701  1c41				   kernel8
    702  1c41		       a9 12		      lda	#<DF2DATAW
    703  1c43		       85 1b		      STA	GRP0	; (VDEL)
    704  1c45		       a9 23		      lda	#<DF3FLAG
    705  1c47		       85 1f		      STA	ENABL	; (VDEL)
    706  1c49		       a9 19		      lda	#<DF1FRACDATA
    707  1c4b		       85 0f		      STA	PF2	; 35
    708  1c4d		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    709  1c4f		       85 05		      STA	NUSIZ1	; 40
    710  1c51		       85 0c		      STA	REFP1	; 43
    711  1c53		       a9 1a		      lda	#<DF2FRACDATA	;45
    712  1c55		       85 0f		      sta	PF2	; 48
    713  1c57		       a9 1b		      lda	#<DF3FRACDATA	;50
    714  1c59		       85 0e		      sta	PF1	; 53
      0  1c5b					      sleep	2
      1  1c5b				   .CYCLES    SET	2
      2  1c5b
      3  1c5b				  -	      IF	.CYCLES < 2
      4  1c5b				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c5b				  -	      ERR
      6  1c5b					      ENDIF
      7  1c5b
      8  1c5b				  -	      IF	.CYCLES & 1
      9  1c5b				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c5b				  -	      nop	0
     11  1c5b				  -	      ELSE
     12  1c5b				  -	      bit	VSYNC
     13  1c5b				  -	      ENDIF
     14  1c5b				  -.CYCLES    SET	.CYCLES - 3
     15  1c5b					      ENDIF
     16  1c5b
     17  1c5b					      REPEAT	.CYCLES / 2
     18  1c5b		       ea		      nop
     19  1c5c					      REPEND
    716  1c5c		       85 11		      sta	RESP1	;58
      0  1c5e					      sleep	3
      1  1c5e				   .CYCLES    SET	3
      2  1c5e
      3  1c5e				  -	      IF	.CYCLES < 2
      4  1c5e				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c5e				  -	      ERR
      6  1c5e					      ENDIF
      7  1c5e
      8  1c5e					      IF	.CYCLES & 1
      9  1c5e					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c5e		       04 00		      nop	0
     11  1c60				  -	      ELSE
     12  1c60				  -	      bit	VSYNC
     13  1c60					      ENDIF
     14  1c60				   .CYCLES    SET	.CYCLES - 3
     15  1c60					      ENDIF
     16  1c60
     17  1c60				  -	      REPEAT	.CYCLES / 2
     18  1c60				  -	      nop
     19  1c60					      REPEND
    718  1c60		       4c dd 1a 	      JMP	getbackearly	; 64
    719  1c63
    720  1c63				   kernel9
    721  1c63		       a9 12		      lda	#<DF2DATAW
    722  1c65		       85 1b		      STA	GRP0	; (VDEL)
    723  1c67		       a9 23		      lda	#<DF3FLAG
    724  1c69		       85 1f		      STA	ENABL	; (VDEL)
    725  1c6b		       a9 19		      lda	#<DF1FRACDATA
    726  1c6d		       85 0f		      STA	PF2	; 35
    727  1c6f		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    728  1c71		       85 05		      STA	NUSIZ1	; 40
    729  1c73		       85 0c		      STA	REFP1	; 43
    730  1c75		       a9 1a		      lda	#<DF2FRACDATA	;45
    731  1c77		       85 0f		      sta	PF2	; 48
    732  1c79		       a9 1b		      lda	#<DF3FRACDATA	;50
    733  1c7b		       85 0e		      sta	PF1	; 53
      0  1c7d					      sleep	5
      1  1c7d				   .CYCLES    SET	5
      2  1c7d
      3  1c7d				  -	      IF	.CYCLES < 2
      4  1c7d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c7d				  -	      ERR
      6  1c7d					      ENDIF
      7  1c7d
      8  1c7d					      IF	.CYCLES & 1
      9  1c7d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c7d		       04 00		      nop	0
     11  1c7f				  -	      ELSE
     12  1c7f				  -	      bit	VSYNC
     13  1c7f					      ENDIF
     14  1c7f				   .CYCLES    SET	.CYCLES - 3
     15  1c7f					      ENDIF
     16  1c7f
     17  1c7f					      REPEAT	.CYCLES / 2
     18  1c7f		       ea		      nop
     19  1c80					      REPEND
    735  1c80		       a9 18		      lda	#<DF0FRACDATA
    736  1c82		       85 11		      sta	RESP1	;63
      0  1c84					      sleep	3
      1  1c84				   .CYCLES    SET	3
      2  1c84
      3  1c84				  -	      IF	.CYCLES < 2
      4  1c84				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1c84				  -	      ERR
      6  1c84					      ENDIF
      7  1c84
      8  1c84					      IF	.CYCLES & 1
      9  1c84					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1c84		       04 00		      nop	0
     11  1c86				  -	      ELSE
     12  1c86				  -	      bit	VSYNC
     13  1c86					      ENDIF
     14  1c86				   .CYCLES    SET	.CYCLES - 3
     15  1c86					      ENDIF
     16  1c86
     17  1c86				  -	      REPEAT	.CYCLES / 2
     18  1c86				  -	      nop
     19  1c86					      REPEND
    738  1c86		       85 0e		      sta	PF1	; 69 (PF1L) too early?
    739  1c88		       4c 6c 1a 	      jmp	loop	;72
    740  1c8b
    741  1c8b				   kernel10
    742  1c8b		       a9 12		      lda	#<DF2DATAW
    743  1c8d		       85 1b		      STA	GRP0	; 25 (VDEL)
    744  1c8f		       a9 23		      lda	#<DF3FLAG
    745  1c91		       85 1f		      STA	ENABL	; 30 (VDEL)
    746  1c93		       a9 19		      lda	#<DF1FRACDATA
    747  1c95		       85 0f		      STA	PF2	; 35
    748  1c97		       a9 1d		      lda	#<DF5FRACDATA	; 37 NUSIZ/RESP info (OK here, GRP1 off)
    749  1c99		       85 05		      STA	NUSIZ1	; 40
    750  1c9b		       85 0c		      STA	REFP1	; 43
    751  1c9d		       a9 1a		      lda	#<DF2FRACDATA	;45
    752  1c9f		       85 0f		      sta	PF2	; 48
    753  1ca1		       a9 1b		      lda	#<DF3FRACDATA	;50
    754  1ca3		       85 0e		      sta	PF1	; 53
      0  1ca5					      sleep	6
      1  1ca5				   .CYCLES    SET	6
      2  1ca5
      3  1ca5				  -	      IF	.CYCLES < 2
      4  1ca5				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1ca5				  -	      ERR
      6  1ca5					      ENDIF
      7  1ca5
      8  1ca5				  -	      IF	.CYCLES & 1
      9  1ca5				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1ca5				  -	      nop	0
     11  1ca5				  -	      ELSE
     12  1ca5				  -	      bit	VSYNC
     13  1ca5				  -	      ENDIF
     14  1ca5				  -.CYCLES    SET	.CYCLES - 3
     15  1ca5					      ENDIF
     16  1ca5
     17  1ca5					      REPEAT	.CYCLES / 2
     18  1ca5		       ea		      nop
     17  1ca5					      REPEND
     18  1ca6		       ea		      nop
     17  1ca6					      REPEND
     18  1ca7		       ea		      nop
     19  1ca8					      REPEND
    756  1ca8		       a9 18		      lda	#<DF0FRACDATA
    757  1caa		       ae 08 10 	      LDX	DF0DATA	; 65
    758  1cad		       85 11		      sta	RESP1	; 68
    759  1caf		       85 0e		      STA	PF1	; 71
    760  1cb1		       a9 09		      lda	#<DF1DATA	; 74
    761  1cb3		       86 06		      STX	COLUP0	; 0
    762  1cb5		       4c 72 1a 	      jmp	loop2	; 3
    763  1cb8
    764  1cb8				   kernel11
    765  1cb8		       a9 12		      lda	#<DF2DATAW
    766  1cba		       85 1b		      STA	GRP0	; (VDEL)
    767  1cbc		       a9 23		      lda	#<DF3FLAG
    768  1cbe		       85 1f		      STA	ENABL	; (VDEL)
    769  1cc0		       a9 19		      lda	#<DF1FRACDATA
    770  1cc2		       85 0f		      STA	PF2	; 35
    771  1cc4		       a9 1d		      lda	#<DF5FRACDATA	; NUSIZ/RESP info (OK here, GRP1 off)
    772  1cc6		       85 05		      STA	NUSIZ1
    773  1cc8		       85 0c		      STA	REFP1
    774  1cca		       a9 1a		      lda	#<DF2FRACDATA	;45
    775  1ccc		       85 0f		      sta	PF2	; 48
    776  1cce		       a9 1b		      lda	#<DF3FRACDATA	;50
    777  1cd0		       85 0e		      sta	PF1	; 53
      0  1cd2					      sleep	3
      1  1cd2				   .CYCLES    SET	3
      2  1cd2
      3  1cd2				  -	      IF	.CYCLES < 2
      4  1cd2				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cd2				  -	      ERR
      6  1cd2					      ENDIF
      7  1cd2
      8  1cd2					      IF	.CYCLES & 1
      9  1cd2					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cd2		       04 00		      nop	0
     11  1cd4				  -	      ELSE
     12  1cd4				  -	      bit	VSYNC
     13  1cd4					      ENDIF
     14  1cd4				   .CYCLES    SET	.CYCLES - 3
     15  1cd4					      ENDIF
     16  1cd4
     17  1cd4				  -	      REPEAT	.CYCLES / 2
     18  1cd4				  -	      nop
     19  1cd4					      REPEND
    779  1cd4		       a9 19		      lda	#<DF1FRACDATA	;45
    780  1cd6		       85 0f		      sta	PF2	; 61
    781  1cd8		       ae 08 10 	      LDX	DF0DATA	; 65
    782  1cdb
    783  1cdb		       a9 18		      lda	#<DF0FRACDATA	; 67
    784  1cdd		       85 0e		      sta	PF1	; 70
    785  1cdf		       85 11		      sta	RESP1	; 73
    786  1ce1		       86 06		      STX	COLUP0	; 0
    787  1ce3		       a9 09		      lda	#<DF1DATA	; 2
    788  1ce5		       85 07		      sta	COLUP1	; 5
    789  1ce7		       a9 0b		      lda	#<DF3DATA
    790  1ce9		       85 1c		      STA	GRP1	; 10
    791  1ceb		       a9 20		      lda	#<DF0FLAG
    792  1ced		       85 1d		      STA	ENAM0	; 25
    793  1cef		       a9 1e		      lda	#<DF6FRACDATA
    794  1cf1		       85 09		      STA	COLUBK	; 20
    795  1cf3		       a9 1c		      lda	#<DF4FRACDATA
    796  1cf5		       85 08		      sta	COLUPF	; 25
      0  1cf7					      sleep	3
      1  1cf7				   .CYCLES    SET	3
      2  1cf7
      3  1cf7				  -	      IF	.CYCLES < 2
      4  1cf7				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1cf7				  -	      ERR
      6  1cf7					      ENDIF
      7  1cf7
      8  1cf7					      IF	.CYCLES & 1
      9  1cf7					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1cf7		       04 00		      nop	0
     11  1cf9				  -	      ELSE
     12  1cf9				  -	      bit	VSYNC
     13  1cf9					      ENDIF
     14  1cf9				   .CYCLES    SET	.CYCLES - 3
     15  1cf9					      ENDIF
     16  1cf9
     17  1cf9				  -	      REPEAT	.CYCLES / 2
     18  1cf9				  -	      nop
     19  1cf9					      REPEND
    798  1cf9		       4c 88 1a 	      jmp	loop3	; 31
    799  1cfc
    800  1cfc				   set_fetchers
    801  1cfc		       ad 67 1d 	      lda	dflow
    802  1cff		       8d 50 10 	      sta	DF0LOW
    803  1d02		       ad 6f 1d 	      lda	dfhigh
    804  1d05		       8d 68 10 	      sta	DF0HI
    805  1d08
    806  1d08		       ad 68 1d 	      lda	dflow+1
    807  1d0b		       8d 51 10 	      sta	DF1LOW
    808  1d0e		       ad 70 1d 	      lda	dfhigh+1
    809  1d11		       8d 69 10 	      sta	DF1HI
    810  1d14
    811  1d14		       ad 69 1d 	      lda	dflow+2
    812  1d17		       8d 52 10 	      sta	DF2LOW
    813  1d1a		       ad 71 1d 	      lda	dfhigh+2
    814  1d1d		       8d 6a 10 	      sta	DF2HI
    815  1d20
    816  1d20				   set_fetchers36		; sets just 3-6
    817  1d20		       ad 6a 1d 	      lda	dflow+3
    818  1d23		       8d 53 10 	      sta	DF3LOW
    819  1d26		       ad 72 1d 	      lda	dfhigh+3
    820  1d29		       8d 6b 10 	      sta	DF3HI
    821  1d2c
    822  1d2c		       ad 6b 1d 	      lda	dflow+4
    823  1d2f		       8d 54 10 	      sta	DF4LOW
    824  1d32		       ad 73 1d 	      lda	dfhigh+4
    825  1d35		       8d 6c 10 	      sta	DF4HI
    826  1d38
    827  1d38		       ad 6c 1d 	      lda	dflow+5
    828  1d3b		       8d 55 10 	      sta	DF5LOW
    829  1d3e		       ad 74 1d 	      lda	dfhigh+5
    830  1d41		       8d 6d 10 	      sta	DF5HI
    831  1d44
    832  1d44		       ad 6d 1d 	      lda	dflow+6
    833  1d47		       8d 56 10 	      sta	DF6LOW
    834  1d4a		       ad 75 1d 	      lda	dfhigh+6
    835  1d4d		       8d 6e 10 	      sta	DF6HI
    836  1d50
    837  1d50		       60		      rts
    838  1d51
    839  1d51							;9d bad
    840  1d51							; the below isn't quite right
    841  1d51							;DF0DATA: COLUP0
    842  1d51							;DF1DATA: COLUP1
    843  1d51							;DF2DATAW: GRP0
    844  1d51							;DF3DATA: GRP1 
    845  1d51							;DF4DATA: 2lk lines until repos/HMP1
    846  1d51							;DF5DATA: low byte of repo kernels (xpos mod 15)
    847  1d51							;DF6DATA: High byte of repo kernels (x pos div 15)
    848  1d51							;DF7DATA: Programmer's stack
    849  1d51							;DF0FRACDATA: PF1L
    850  1d51							;DF1FRACDATA: PF2L
    851  1d51							;DF4FRACDATA: COLUPF
    852  1d51							;DF2FRACDATA: PF2R
    853  1d51							;DF3FRACDATA: PF2L
    854  1d51							;DF5FRACDATA: Sprite NUSIZ1/REFP1 (only during repos)
    855  1d51							;DF6FRACDATA: COLUBK
    856  1d51							;DF7FRACDATA: HMP1
    857  1d51							;DF3FLAG: kernel exit loop ?? (use flags instead?)
    858  1d51							;DF0FLAG: ENAM0
    859  1d51							;DF1FLAG: ENAM1 
    860  1d51							;DF3FLAG: ENABL 
    861  1d51
    862  1d51				   fetcher_address_table
    863  1d51				   kernello
    864  1d51		       31		      .byte.b	<kernel1
    865  1d52		       53		      .byte.b	<kernel2
    866  1d53		       75		      .byte.b	<kernel3
    867  1d54		       97		      .byte.b	<kernel4
    868  1d55		       b9		      .byte.b	<kernel5
    869  1d56		       db		      .byte.b	<kernel6
    870  1d57		       1f		      .byte.b	<kernel7
    871  1d58		       41		      .byte.b	<kernel8
    872  1d59		       63		      .byte.b	<kernel9
    873  1d5a		       8b		      .byte.b	<kernel10
    874  1d5b		       b8		      .byte.b	<kernel11
    875  1d5c				   kernelhi
    876  1d5c		       1b		      .byte.b	>kernel1
    877  1d5d		       1b		      .byte.b	>kernel2
    878  1d5e		       1b		      .byte.b	>kernel3
    879  1d5f		       1b		      .byte.b	>kernel4
    880  1d60		       1b		      .byte.b	>kernel5
    881  1d61		       1b		      .byte.b	>kernel6
    882  1d62		       1c		      .byte.b	>kernel7
    883  1d63		       1c		      .byte.b	>kernel8
    884  1d64		       1c		      .byte.b	>kernel9
    885  1d65		       1c		      .byte.b	>kernel10
    886  1d66		       1c		      .byte.b	>kernel11
    887  1d67				   dflow
    888  1d67		       08		      .byte.b	<P0COLOR
    889  1d68		       08		      .byte.b	<P1COLOR
    890  1d69		       08		      .byte.b	<P0GFX
    891  1d6a		       08		      .byte.b	<P1GFX
    892  1d6b		       2d		      .byte.b	<P1SKIP
    893  1d6c		       08		      .byte.b	<JUMPTABLELO
    894  1d6d		       14		      .byte.b	<JUMPTABLEHI
    895  1d6e		       a5		      .byte.b	<USERSTACK
    896  1d6f				   dfhigh
    897  1d6f		       05		      .byte.b	(>P0COLOR) & $0F
    898  1d70		       03		      .byte.b	(>P1COLOR) & $0F
    899  1d71		       04		      .byte.b	(>P0GFX) & $0F
    900  1d72		       02		      .byte.b	(>P1GFX) & $0F
    901  1d73		       0b		      .byte.b	(>P1SKIP) & $0F
    902  1d74		       0b		      .byte.b	(>JUMPTABLELO) & $0F
    903  1d75		       0b		      .byte.b	(>JUMPTABLEHI) & $0F
    904  1d76		       0d		      .byte.b	(>USERSTACK) & $0F
    905  1d77				   dffraclow
    906  1d77		       08		      .byte.b	<PF1L
    907  1d78		       08		      .byte.b	<PF2L
    908  1d79		       08		      .byte.b	<PF1R
    909  1d7a		       08		      .byte.b	<PF2R
    910  1d7b		       08		      .byte.b	<PFCOLS
    911  1d7c		       39		      .byte.b	<NUSIZREFP
    912  1d7d		       a5		      .byte.b	<BKCOLS
    913  1d7e		       20		      .byte.b	<P1HMP
    914  1d7f				   dffrachi
    915  1d7f		       06		      .byte.b	(>PF1L) & $0F
    916  1d80		       07		      .byte.b	(>PF2L) & $0F
    917  1d81		       08		      .byte.b	(>PF1R) & $0F
    918  1d82		       09		      .byte.b	(>PF2R) & $0F
    919  1d83		       0a		      .byte.b	(>PFCOLS) & $0F
    920  1d84		       0b		      .byte.b	(>NUSIZREFP) & $0F
    921  1d85		       0b		      .byte.b	(>BKCOLS) & $0F
    922  1d86		       0b		      .byte.b	(>P1HMP) & $0F
    923  1d87				   scorepointer
    924  1d87		       94		      .byte.b	<scoretable
    925  1d88		       08		      .byte.b	((>scoretable) & $0f) | (((>scoretable) / 2) & $70)
    926  1d89				   scoresetup		; pointers to digit graphics
    927  1d89		       45		      .byte.b	<scoredata
    928  1d8a		       0b		      .byte.b	(>scoredata) & $0F
    929  1d8b				   Hmval		; 112 wuz first
    930  1d8b		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240
    931  1d93				   Hmval74
    932  1d93		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128
    933  1d9a		       60 50 40 30*	      .byte.b	96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96
    934  1daa		       50 40 30 20*	      .byte.b	80, 64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80
    935  1dba		       40 30 20 10*	      .byte.b	64, 48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64
    936  1dca		       30 20 10 01*	      .byte.b	48, 32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48
    937  1dda		       20 10 01 f0*	      .byte.b	32, 16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32
    938  1dea		       10 01 f0 e0*	      .byte.b	16, 1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16
    939  1dfa		       01 f0 e0 d0*	      .byte.b	1, 240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1
    940  1e0a		       f0 e0 d0 c0*	      .byte.b	240, 224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240
    941  1e1a		       e0 d0 c0 b0*	      .byte.b	224, 208, 192, 176, 160, 144, 128, 96, 80, 64, 48, 32, 16, 1, 240, 224, 208, 192
    942  1e2c		       b0 a0 90 80*	      .byte.b	176,160,144,128,16,1,240,224
    943  1e34
    944  1e34
    945  1e34				   kernel_setup
    946  1e34							;--position P0, top P1, M0, M1, BL
    947  1e34		       a2 00		      ldx	#0	; first sprite displayed
    948  1e36		       b5 85		      lda	SpriteGfxIndex,x
    949  1e38		       aa		      tax
    950  1e39		       b5 90		      lda	player1x,x
    951  1e3b		       c9 a0		      cmp	#160
    952  1e3d		       90 0a		      bcc	nostorep1
    953  1e3f		       c9 d0		      cmp	#208
    954  1e41		       b0 02		      bcs	ksadjustdown
    955  1e43							; 160-208: minus 160
    956  1e43							;add 160 is like minus 96
    957  1e43							; so minus 64
    958  1e43		       e9 3f		      sbc	#63	;cc
    959  1e45				   ksadjustdown
    960  1e45							; 209-255: add 160 
    961  1e45		       69 9f		      adc	#159	; cs
    962  1e47		       95 90		      sta	player1x,x
    963  1e49				   nostorep1
    964  1e49		       85 02		      sta	WSYNC
    965  1e4b		       a2 04		      ldx	#4
    966  1e4d		       85 81		      sta	topP1x	; cache top p1
    967  1e4f				   HorPosLoop
    968  1e4f		       b5 80		      lda	player0x,X
    969  1e51		       38		      sec
    970  1e52				   DivideLoop
    971  1e52		       e9 0f		      sbc	#15
    972  1e54		       b0 fc		      bcs	DivideLoop
      0  1e56					      sleep	4
      1  1e56				   .CYCLES    SET	4
      2  1e56
      3  1e56				  -	      IF	.CYCLES < 2
      4  1e56				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1e56				  -	      ERR
      6  1e56					      ENDIF
      7  1e56
      8  1e56				  -	      IF	.CYCLES & 1
      9  1e56				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1e56				  -	      nop	0
     11  1e56				  -	      ELSE
     12  1e56				  -	      bit	VSYNC
     13  1e56				  -	      ENDIF
     14  1e56				  -.CYCLES    SET	.CYCLES - 3
     15  1e56					      ENDIF
     16  1e56
     17  1e56					      REPEAT	.CYCLES / 2
     18  1e56		       ea		      nop
     17  1e56					      REPEND
     18  1e57		       ea		      nop
     19  1e58					      REPEND
    974  1e58		       95 10		      sta	RESP0,X
    975  1e5a		       85 02		      sta	WSYNC
    976  1e5c		       ca		      dex		;2
    977  1e5d		       10 f0		      bpl	HorPosLoop	;4/5
    978  1e5f
    979  1e5f		       a4 80		      ldy	player0x	; 7
    980  1e61		       b9 8b 1d 	      lda	Hmval,y	; 11
    981  1e64		       85 20		      sta	HMP0	; 14
    982  1e66
    983  1e66		       a4 81		      ldy	player0x+1
    984  1e68		       b9 8b 1d 	      lda	Hmval,y
    985  1e6b		       85 21		      sta	HMP0+1	; 24
    986  1e6d
    987  1e6d		       a4 82		      ldy	player0x+2
    988  1e6f		       b9 8b 1d 	      lda	Hmval,y
    989  1e72		       85 22		      sta	HMP0+2	; 34
    990  1e74
    991  1e74		       a4 83		      ldy	player0x+3
    992  1e76		       b9 8b 1d 	      lda	Hmval,y
    993  1e79		       85 23		      sta	HMP0+3	; 44
    994  1e7b
    995  1e7b		       a4 84		      ldy	player0x+4
    996  1e7d		       b9 8b 1d 	      lda	Hmval,y
    997  1e80		       85 24		      sta	HMP0+4	; 54
    998  1e82
    999  1e82		       85 02		      sta	WSYNC
   1000  1e84		       85 2a		      sta	HMOVE
   1001  1e86
   1002  1e86				   myrts
   1003  1e86		       60		      rts
   1004  1e87
   1005  1e87
   1006  1e87				   pfsetup
   1007  1e87
   1008  1e87		       84 cb		      sty	temp1
   1009  1e89		       85 cc		      sta	temp2
   1010  1e8b		       86 cd		      stx	temp3
   1011  1e8d		       a2 03		      ldx	#3
   1012  1e8f				   pfsetupp
   1013  1e8f		       bd 77 1d 	      lda	dffraclow,x
   1014  1e92		       9d 50 10 	      sta	DF0LOW,x
   1015  1e95		       bd 7f 1d 	      lda	dffrachi,x
   1016  1e98		       9d 68 10 	      sta	DF0HI,x
   1017  1e9b		       a5 cc		      lda	temp2
   1018  1e9d		       8d 59 10 	      sta	PARAMETER
   1019  1ea0		       a5 cd		      lda	temp3
   1020  1ea2		       8d 59 10 	      sta	PARAMETER
   1021  1ea5		       8e 59 10 	      stx	PARAMETER
   1022  1ea8		       8c 59 10 	      sty	PARAMETER
   1023  1eab		       a9 01		      LDA	#1
   1024  1ead		       8d 5a 10 	      sta	CALLFUNCTION
   1025  1eb0		       18		      clc
   1026  1eb1		       a5 cc		      lda	temp2
   1027  1eb3		       65 cb		      adc	temp1
   1028  1eb5		       85 cc		      sta	temp2
   1029  1eb7		       a5 cd		      lda	temp3
   1030  1eb9		       69 00		      adc	#0
   1031  1ebb		       85 cd		      sta	temp3
   1032  1ebd		       ca		      dex
   1033  1ebe		       10 cf		      bpl	pfsetupp
      0  1ec0					      RETURN
      1  1ec0				  -	      ifnconst	bankswitch
      2  1ec0				  -	      rts
      3  1ec0					      else
      4  1ec0		       4c e0 df 	      jmp	BS_return
      5  1ec3					      endif
   1035  1ec3
   1036  1ec3
   1037  1ec3				   scorekernel
   1038  1ec3				  -	      ifconst	minikernel
   1039  1ec3				  -			;; disable fast fetch, call the minikernel, and re-enable fast fetch
   1040  1ec3				  -	      lda	#255
   1041  1ec3				  -	      sta	FASTFETCH
   1042  1ec3				  -	      jsr	minikernel
   1043  1ec3				  -	      lda	#0
   1044  1ec3				  -	      sta.w	FASTFETCH
   1045  1ec3					      endif
   1046  1ec3		       a6 eb		      ldx	scorecolor
   1047  1ec5		       86 06		      stx	COLUP0
   1048  1ec7		       86 07		      stx	COLUP1
   1049  1ec9		       a2 00		      ldx	#0
   1050  1ecb		       86 0e		      STx	PF1
   1051  1ecd		       86 0b		      stx	REFP0
   1052  1ecf		       86 0c		      stx	REFP1
   1053  1ed1		       86 1b		      STx	GRP0
   1054  1ed3		       86 1c		      STx	GRP1
   1055  1ed5		       86 0f		      STx	PF2
   1056  1ed7		       86 2b		      stx	HMCLR
   1057  1ed9		       86 1d		      stx	ENAM0
   1058  1edb		       86 1e		      stx	ENAM1
   1059  1edd		       86 1f		      stx	ENABL
   1060  1edf
   1061  1edf
   1062  1edf				  -	      ifconst	pfscore
   1063  1edf				  -	      lda	pfscorecolor
   1064  1edf				  -	      sta	COLUPF
   1065  1edf					      endif
   1066  1edf
   1067  1edf				  -	      ifconst	noscore
   1068  1edf				  -	      ldx	#10
   1069  1edf				  -noscoreloop
   1070  1edf				  -	      sta	WSYNC
   1071  1edf				  -	      dex
   1072  1edf				  -	      bpl	noscoreloop
   1073  1edf				  -	      rts
   1074  1edf					      else
   1075  1edf
   1076  1edf		       85 2b		      sta	HMCLR
   1077  1ee1		       a2 f0		      ldx	#$f0
   1078  1ee3		       86 20		      stx	HMP0
   1079  1ee5
   1080  1ee5							; set up fetchers 0-5 to handle score digits
   1081  1ee5		       a2 45		      ldx	#<(scoredata)
   1082  1ee7		       8e 56 10 	      stx	DF6LOW
   1083  1eea		       a2 0b		      ldx	#(>(scoredata)) & $0F
   1084  1eec		       8e 6e 10 	      stx	DF6HI
   1085  1eef		       a2 4d		      ldx	#<(scoredata+8)
   1086  1ef1		       8e 50 10 	      stx	DF0LOW
   1087  1ef4		       a2 0b		      ldx	#(>(scoredata+8)) & $0F
   1088  1ef6		       8e 68 10 	      stx	DF0HI
   1089  1ef9		       a2 55		      ldx	#<(scoredata+16)
   1090  1efb		       8e 51 10 	      stx	DF1LOW
   1091  1efe							; cycle 0??
   1092  1efe		       a2 0b		      ldx	#(>(scoredata+16)) & $0F
   1093  1f00		       8e 69 10 	      stx	DF1HI
   1094  1f03		       a2 5d		      ldx	#<(scoredata+24)
   1095  1f05		       8e 52 10 	      stx	DF2LOW
   1096  1f08		       a2 0b		      ldx	#(>(scoredata+24)) & $0F
   1097  1f0a		       8e 6a 10 	      stx	DF2HI
   1098  1f0d
   1099  1f0d		       85 02		      sta	WSYNC
   1100  1f0f		       a2 00		      ldx	#0
   1101  1f11		       86 1b		      STx	GRP0
   1102  1f13		       86 1c		      STx	GRP1	; seems to be needed because of vdel
   1103  1f15
   1104  1f15		       a2 65		      ldx	#<(scoredata+32)
   1105  1f17		       8e 53 10 	      stx	DF3LOW
   1106  1f1a		       a2 0b		      ldx	#(>(scoredata+32)) & $0F
   1107  1f1c		       8e 6b 10 	      stx	DF3HI
   1108  1f1f		       a2 6d		      ldx	#<(scoredata+40)
   1109  1f21		       8e 54 10 	      stx	DF4LOW
   1110  1f24		       a2 0b		      ldx	#(>(scoredata+40)) & $0F
   1111  1f26		       8e 6c 10 	      stx	DF4HI
   1112  1f29
   1113  1f29		       a0 07		      LDY	#7
   1114  1f2b		       a2 03		      LDx	#$03
   1115  1f2d		       84 25		      STY	VDELP0
   1116  1f2f		       85 10		      STA	RESP0
   1117  1f31		       85 11		      STA	RESP1
   1118  1f33		       84 cb		      sty	temp1
   1119  1f35
   1120  1f35		       86 04		      STx	NUSIZ0
   1121  1f37		       86 05		      STx	NUSIZ1
   1122  1f39		       86 26		      STx	VDELP1
   1123  1f3b		       a2 75		      ldx	#<(scoredata+48)
   1124  1f3d		       8e 55 10 	      stx	DF5LOW
   1125  1f40		       a2 0b		      ldx	#(>(scoredata+48)) & $0F
   1126  1f42		       8e 6d 10 	      stx	DF5HI
   1127  1f45		       8d 2a 00 	      STA.w	HMOVE	; cycle 73 ?
   1128  1f48				   scoreloop
   1129  1f48		       a9 0e		      lda	#<DF6DATA	;59
   1130  1f4a		       85 06		      sta	COLUP0	;62
   1131  1f4c		       85 07		      sta	COLUP1	;65
   1132  1f4e		       a9 09		      lda	#<DF1DATA	;75
   1133  1f50		       85 1b		      sta	GRP0	;2
   1134  1f52		       a9 08		      lda	#<DF0DATA	;4
   1135  1f54		       85 1c		      sta	GRP1	;7
   1136  1f56		       a9 0b		      lda	#<DF3DATA	;9
   1137  1f58		       85 1b		      sta	GRP0	;12
   1138  1f5a
   1139  1f5a							; REVENG - rearranged to correct pf write timing and A register overwrite
   1140  1f5a				  -	      ifconst	pfscore
   1141  1f5a				  -	      lda	pfscore1
   1142  1f5a				  -	      sta	PF1
   1143  1f5a					      else
      0  1f5a					      sleep	6
      1  1f5a				   .CYCLES    SET	6
      2  1f5a
      3  1f5a				  -	      IF	.CYCLES < 2
      4  1f5a				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f5a				  -	      ERR
      6  1f5a					      ENDIF
      7  1f5a
      8  1f5a				  -	      IF	.CYCLES & 1
      9  1f5a				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f5a				  -	      nop	0
     11  1f5a				  -	      ELSE
     12  1f5a				  -	      bit	VSYNC
     13  1f5a				  -	      ENDIF
     14  1f5a				  -.CYCLES    SET	.CYCLES - 3
     15  1f5a					      ENDIF
     16  1f5a
     17  1f5a					      REPEAT	.CYCLES / 2
     18  1f5a		       ea		      nop
     17  1f5a					      REPEND
     18  1f5b		       ea		      nop
     17  1f5b					      REPEND
     18  1f5c		       ea		      nop
     19  1f5d					      REPEND
   1145  1f5d					      endif
      0  1f5d					      sleep	5
      1  1f5d				   .CYCLES    SET	5
      2  1f5d
      3  1f5d				  -	      IF	.CYCLES < 2
      4  1f5d				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f5d				  -	      ERR
      6  1f5d					      ENDIF
      7  1f5d
      8  1f5d					      IF	.CYCLES & 1
      9  1f5d					      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f5d		       04 00		      nop	0
     11  1f5f				  -	      ELSE
     12  1f5f				  -	      bit	VSYNC
     13  1f5f					      ENDIF
     14  1f5f				   .CYCLES    SET	.CYCLES - 3
     15  1f5f					      ENDIF
     16  1f5f
     17  1f5f					      REPEAT	.CYCLES / 2
     18  1f5f		       ea		      nop
     19  1f60					      REPEND
   1147  1f60		       ae 0a 10 	      ldx	DF2DATA	;16
   1148  1f63		       ac 0d 10 	      ldy	DF5DATA	;20
   1149  1f66		       a9 0c		      lda	#<DF4DATA	;22 
   1150  1f68
   1151  1f68		       86 1c		      stx	GRP1	;40
   1152  1f6a		       84 1b		      sty	GRP0	;43
   1153  1f6c		       85 1c		      sta	GRP1	;46
   1154  1f6e		       85 1b		      sta	GRP0	;49
   1155  1f70				  -	      ifconst	pfscore
   1156  1f70				  -	      lda	pfscore2
   1157  1f70				  -	      sta	PF1
   1158  1f70					      else
      0  1f70					      sleep	6
      1  1f70				   .CYCLES    SET	6
      2  1f70
      3  1f70				  -	      IF	.CYCLES < 2
      4  1f70				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f70				  -	      ERR
      6  1f70					      ENDIF
      7  1f70
      8  1f70				  -	      IF	.CYCLES & 1
      9  1f70				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f70				  -	      nop	0
     11  1f70				  -	      ELSE
     12  1f70				  -	      bit	VSYNC
     13  1f70				  -	      ENDIF
     14  1f70				  -.CYCLES    SET	.CYCLES - 3
     15  1f70					      ENDIF
     16  1f70
     17  1f70					      REPEAT	.CYCLES / 2
     18  1f70		       ea		      nop
     17  1f70					      REPEND
     18  1f71		       ea		      nop
     17  1f71					      REPEND
     18  1f72		       ea		      nop
     19  1f73					      REPEND
   1160  1f73					      endif
   1161  1f73							; sleep 2 ;57
      0  1f73					      sleep	6
      1  1f73				   .CYCLES    SET	6
      2  1f73
      3  1f73				  -	      IF	.CYCLES < 2
      4  1f73				  -	      ECHO	"MACRO ERROR: 'SLEEP': Duration must be > 1"
      5  1f73				  -	      ERR
      6  1f73					      ENDIF
      7  1f73
      8  1f73				  -	      IF	.CYCLES & 1
      9  1f73				  -	      IFNCONST	NO_ILLEGAL_OPCODES
     10  1f73				  -	      nop	0
     11  1f73				  -	      ELSE
     12  1f73				  -	      bit	VSYNC
     13  1f73				  -	      ENDIF
     14  1f73				  -.CYCLES    SET	.CYCLES - 3
     15  1f73					      ENDIF
     16  1f73
     17  1f73					      REPEAT	.CYCLES / 2
     18  1f73		       ea		      nop
     17  1f73					      REPEND
     18  1f74		       ea		      nop
     17  1f74					      REPEND
     18  1f75		       ea		      nop
     19  1f76					      REPEND
   1163  1f76		       c6 cb		      dec	temp1	;70
   1164  1f78		       10 ce		      bpl	scoreloop	;72/73
   1165  1f7a		       a2 00		      LDx	#0
   1166  1f7c		       86 0e		      stx	PF1
   1167  1f7e		       86 1b		      STx	GRP0
   1168  1f80		       86 1c		      STx	GRP1
   1169  1f82		       86 25		      STx	VDELP0
   1170  1f84		       86 26		      STx	VDELP1	;do we need these
   1171  1f86		       86 04		      STx	NUSIZ0
   1172  1f88		       86 05		      STx	NUSIZ1
   1173  1f8a
   1174  1f8a		       60		      rts
   1175  1f8b
   1176  1f8b
   1177  1f8b					      endif		; noscore
   1178  1f8b				   game
   1179  1f8b				   .L00 		;  set kernel DPC + 
   1180  1f8b
   1181  1f8b				   .L01 		;  set tv ntsc
   1182  1f8b
   1183  1f8b				   .L02 		;  goto _bank2 bank2
   1184  1f8b
   1185  1f8b		       85 81		      sta	temp7
   1186  1f8d		       a9 30		      lda	#>(._bank2-1)
   1187  1f8f		       48		      pha
   1188  1f90		       a9 a3		      lda	#<(._bank2-1)
   1189  1f92		       48		      pha
   1190  1f93		       a5 81		      lda	temp7
   1191  1f95		       48		      pha
   1192  1f96		       8a		      txa
   1193  1f97		       48		      pha
   1194  1f98		       a2 02		      ldx	#2
   1195  1f9a		       4c ee df 	      jmp	BS_jsr
   1196  1f9d				   .
   1197  1f9d							; 
   1198  1f9d
   1199  1f9d				   .
   1200  1f9d							; 
   1201  1f9d
   1202  1f9d				   .L03 		;  vblank
   1203  1f9d
   1204  1f9d				   vblank_bB_code
   1205  1f9d				   .L04 		;  goto DrawStarField bank2
   1206  1f9d
   1207  1f9d		       85 81		      sta	temp7
   1208  1f9f		       a9 39		      lda	#>(.DrawStarField-1)
   1209  1fa1		       48		      pha
   1210  1fa2		       a9 61		      lda	#<(.DrawStarField-1)
   1211  1fa4		       48		      pha
   1212  1fa5		       a5 81		      lda	temp7
   1213  1fa7		       48		      pha
   1214  1fa8		       8a		      txa
   1215  1fa9		       48		      pha
   1216  1faa		       a2 02		      ldx	#2
   1217  1fac		       4c ee df 	      jmp	BS_jsr
   1218  1faf				   .
   1219  1faf							; 
   1220  1faf
   1221  1faf				   .
   1222  1faf							; 
   1223  1faf
   1224  1faf				   .L05 		;  bank 2
   1225  1faf
   1226  1faf					      if	ECHO1
      37 bytes of ROM space left in bank 1
   1227  1faf					      echo	"    ",[(start_bank1 - *)]d , "bytes of ROM space left in bank 1")
   1228  1faf					      endif
   1229  1faf		       00 01	   ECHO1      =	1
   1230  1fd4					      ORG	$1FF4-bscode_length
   1231  1fd4					      RORG	$1FF4-bscode_length
   1232  1fd4		       a2 ff	   start_bank1 ldx	#$ff
   1233  1fd6					      ifconst	FASTFETCH	; using DPC+
   1234  1fd6		       8e 58 10 	      stx	FASTFETCH
   1235  1fd9					      endif
   1236  1fd9		       9a		      txs
   1237  1fda				  -	      if	bankswitch == 64
   1238  1fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   1239  1fda					      else
   1240  1fda		       a9 18		      lda	#>(start-1)
   1241  1fdc					      endif
   1242  1fdc		       48		      pha
   1243  1fdd		       a9 e3		      lda	#<(start-1)
   1244  1fdf		       48		      pha
   1245  1fe0		       48		      pha
   1246  1fe1		       8a		      txa
   1247  1fe2		       48		      pha
   1248  1fe3		       ba		      tsx
   1249  1fe4					      if	bankswitch != 64
   1250  1fe4		       b5 04		      lda	4,x	; get high byte of return address
   1251  1fe6		       2a		      rol
   1252  1fe7		       2a		      rol
   1253  1fe8		       2a		      rol
   1254  1fe9		       2a		      rol
   1255  1fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   1256  1fec		       aa		      tax
   1257  1fed		       e8		      inx
   1258  1fee				  -	      else
   1259  1fee				  -	      lda	4,x	; get high byte of return address
   1260  1fee				  -	      tay
   1261  1fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   1262  1fee				  -	      sta	4,x
   1263  1fee				  -	      tya
   1264  1fee				  -	      lsr
   1265  1fee				  -	      lsr
   1266  1fee				  -	      lsr
   1267  1fee				  -	      lsr
   1268  1fee				  -	      tax
   1269  1fee				  -	      inx
   1270  1fee					      endif
   1271  1fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   1272  1ff1		       68		      pla
   1273  1ff2		       aa		      tax
   1274  1ff3		       68		      pla
   1275  1ff4		       60		      rts
   1276  1ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   1277  1ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   1278  1ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   1279  1ff5					      endif
   1280  1ffc					      ORG	$1FFC
   1281  1ffc					      RORG	$1FFC
   1282  1ffc		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1283  1ffe		       d4 1f		      .word.w	(start_bank1 & $ffff)
   1284  2000					      ORG	$2000
   1285  2000					      RORG	$3000
   1286  2000				   HMdiv
   1287  2000		       00 00 00 00*	      .byte.b	0, 0, 0, 0, 0, 0, 0
   1288  2007		       01 01 01 01*	      .byte.b	1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2
   1289  2017		       02 02 02 02*	      .byte.b	2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3
   1290  2027		       03 03 03 03*	      .byte.b	3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4
   1291  2037		       04 04 04 04*	      .byte.b	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5
   1292  2047		       05 05 05 05*	      .byte.b	5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6
   1293  2057		       06 06 06 06*	      .byte.b	6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7
   1294  2067		       07 07 07 07*	      .byte.b	7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8
   1295  2077		       08 08 08 08*	      .byte.b	8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9
   1296  2087		       09 09 09 09*	      .byte.b	9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10
   1297  2097		       0a 0a 0a 0a*	      .byte.b	10,10,10,10,10,10,0,0,0
   1298  20a0				   .L06 		;  temp1 = temp1
   1299  20a0
   1300  20a0		       a5 cb		      LDA	temp1
   1301  20a2		       85 cb		      STA	temp1
   1302  20a4				   .
   1303  20a4							; 
   1304  20a4
   1305  20a4				   .
   1306  20a4							; 
   1307  20a4
   1308  20a4				   ._bank2
   1309  20a4							; _bank2
   1310  20a4
   1311  20a4				   .
   1312  20a4							; 
   1313  20a4
   1314  20a4				   .init
   1315  20a4							; init
   1316  20a4
   1317  20a4				   .L07 		;  dim _sc2  =  score + 1
   1318  20a4
   1319  20a4				   .L08 		;  dim _sc3  =  score + 2
   1320  20a4
   1321  20a4				   .
   1322  20a4							; 
   1323  20a4
   1324  20a4				   .L09 		;  score  =  000000
   1325  20a4
   1326  20a4		       a9 00		      LDA	#$00
   1327  20a6		       85 ba		      STA	score+2
   1328  20a8		       a9 00		      LDA	#$00
   1329  20aa		       85 b9		      STA	score+1
   1330  20ac		       a9 00		      LDA	#$00
   1331  20ae		       85 b8		      STA	score
   1332  20b0				   .L010		;  pfclear
   1333  20b0
   1334  20b0		       a9 a4		      lda	#<C_function
   1335  20b2		       8d 50 10 	      sta	DF0LOW
   1336  20b5		       a9 01		      lda	#(>C_function) & $0F
   1337  20b7		       8d 68 10 	      sta	DF0HI
   1338  20ba		       a2 1c		      ldx	#28
   1339  20bc		       8e 78 10 	      stx	DF0WRITE
   1340  20bf		       a9 00		      LDA	#0
   1341  20c1		       8d 78 10 	      sta	DF0WRITE
   1342  20c4		       a9 ff		      lda	#255
   1343  20c6		       8d 5a 10 	      sta	CALLFUNCTION
   1344  20c9				   .L011		;  scorecolors:
   1345  20c9
   1346  20c9		       a9 45		      lda	#<scoredata
   1347  20cb		       8d 50 10 	      STA	DF0LOW
   1348  20ce		       a9 0b		      lda	#((>scoredata) & $0f)
   1349  20d0		       8d 68 10 	      STA	DF0HI
   1350  20d3		       a9 3e		      lda	#$3E
   1351  20d5
   1352  20d5		       8d 78 10 	      sta	DF0WRITE
   1353  20d8		       a9 3e		      lda	#$3E
   1354  20da
   1355  20da		       8d 78 10 	      sta	DF0WRITE
   1356  20dd		       a9 3c		      lda	#$3C
   1357  20df
   1358  20df		       8d 78 10 	      sta	DF0WRITE
   1359  20e2		       a9 3c		      lda	#$3C
   1360  20e4
   1361  20e4		       8d 78 10 	      sta	DF0WRITE
   1362  20e7		       a9 3a		      lda	#$3A
   1363  20e9
   1364  20e9		       8d 78 10 	      sta	DF0WRITE
   1365  20ec		       a9 3a		      lda	#$3A
   1366  20ee
   1367  20ee		       8d 78 10 	      sta	DF0WRITE
   1368  20f1		       a9 38		      lda	#$38
   1369  20f3
   1370  20f3		       8d 78 10 	      sta	DF0WRITE
   1371  20f6		       a9 38		      lda	#$38
   1372  20f8
   1373  20f8		       8d 78 10 	      sta	DF0WRITE
   1374  20fb				   .
   1375  20fb							; 
   1376  20fb
   1377  20fb				   .
   1378  20fb							; 
   1379  20fb
   1380  20fb				   .
   1381  20fb							; 
   1382  20fb
   1383  20fb				   .
   1384  20fb							; 
   1385  20fb
   1386  20fb				   .
   1387  20fb							; 
   1388  20fb
   1389  20fb				   .
   1390  20fb							; 
   1391  20fb
   1392  20fb				   .
   1393  20fb							; 
   1394  20fb
   1395  20fb				   .
   1396  20fb							; 
   1397  20fb
   1398  20fb				   .
   1399  20fb							; 
   1400  20fb
   1401  20fb				   .
   1402  20fb							; 
   1403  20fb
   1404  20fb				   .
   1405  20fb							; 
   1406  20fb
   1407  20fb				   .
   1408  20fb							; 
   1409  20fb
   1410  20fb				   .
   1411  20fb							; 
   1412  20fb
   1413  20fb				   .
   1414  20fb							; 
   1415  20fb
   1416  20fb				   .
   1417  20fb							; 
   1418  20fb
   1419  20fb				   .
   1420  20fb							; 
   1421  20fb
   1422  20fb				   .
   1423  20fb							; 
   1424  20fb
   1425  20fb				   .
   1426  20fb							; 
   1427  20fb
   1428  20fb				   .
   1429  20fb							; 
   1430  20fb
   1431  20fb				   .
   1432  20fb							; 
   1433  20fb
   1434  20fb				   .
   1435  20fb							; 
   1436  20fb
   1437  20fb				   .
   1438  20fb							; 
   1439  20fb
   1440  20fb				   .
   1441  20fb							; 
   1442  20fb
   1443  20fb				   .
   1444  20fb							; 
   1445  20fb
   1446  20fb				   .
   1447  20fb							; 
   1448  20fb
   1449  20fb				   .
   1450  20fb							; 
   1451  20fb
   1452  20fb				   .
   1453  20fb							; 
   1454  20fb
   1455  20fb				   .
   1456  20fb							; 
   1457  20fb
   1458  20fb				   .
   1459  20fb							; 
   1460  20fb
   1461  20fb				   .
   1462  20fb							; 
   1463  20fb
   1464  20fb				   .
   1465  20fb							; 
   1466  20fb
   1467  20fb				   .
   1468  20fb							; 
   1469  20fb
   1470  20fb				   .
   1471  20fb							; 
   1472  20fb
   1473  20fb				   .
   1474  20fb							; 
   1475  20fb
   1476  20fb				   .
   1477  20fb							; 
   1478  20fb
   1479  20fb				   .
   1480  20fb							; 
   1481  20fb
   1482  20fb				   .
   1483  20fb							; 
   1484  20fb
   1485  20fb				   .
   1486  20fb							; 
   1487  20fb
   1488  20fb				   .
   1489  20fb							; 
   1490  20fb
   1491  20fb				   .
   1492  20fb							; 
   1493  20fb
   1494  20fb				   .
   1495  20fb							; 
   1496  20fb
   1497  20fb				   .
   1498  20fb							; 
   1499  20fb
   1500  20fb				   .
   1501  20fb							; 
   1502  20fb
   1503  20fb				   .
   1504  20fb							; 
   1505  20fb
   1506  20fb				   .
   1507  20fb							; 
   1508  20fb
   1509  20fb				   .
   1510  20fb							; 
   1511  20fb
   1512  20fb				   .
   1513  20fb							; 
   1514  20fb
   1515  20fb				   .
   1516  20fb							; 
   1517  20fb
   1518  20fb				   .
   1519  20fb							; 
   1520  20fb
   1521  20fb				   .
   1522  20fb							; 
   1523  20fb
   1524  20fb				   .
   1525  20fb							; 
   1526  20fb
   1527  20fb				   .
   1528  20fb							; 
   1529  20fb
   1530  20fb				   .
   1531  20fb							; 
   1532  20fb
   1533  20fb				   .
   1534  20fb							; 
   1535  20fb
   1536  20fb				   .
   1537  20fb							; 
   1538  20fb
   1539  20fb				   .
   1540  20fb							; 
   1541  20fb
   1542  20fb				   .
   1543  20fb							; 
   1544  20fb
   1545  20fb				   .
   1546  20fb							; 
   1547  20fb
   1548  20fb				   .
   1549  20fb							; 
   1550  20fb
   1551  20fb				   .
   1552  20fb							; 
   1553  20fb
   1554  20fb				   .
   1555  20fb							; 
   1556  20fb
   1557  20fb				   .
   1558  20fb							; 
   1559  20fb
   1560  20fb				   .
   1561  20fb							; 
   1562  20fb
   1563  20fb				   .
   1564  20fb							; 
   1565  20fb
   1566  20fb				   .
   1567  20fb							; 
   1568  20fb
   1569  20fb				   .
   1570  20fb							; 
   1571  20fb
   1572  20fb				   .
   1573  20fb							; 
   1574  20fb
   1575  20fb				   .
   1576  20fb							; 
   1577  20fb
   1578  20fb				   .
   1579  20fb							; 
   1580  20fb
   1581  20fb				   .
   1582  20fb							; 
   1583  20fb
   1584  20fb				   .
   1585  20fb							; 
   1586  20fb
   1587  20fb				   .
   1588  20fb							; 
   1589  20fb
   1590  20fb				   .
   1591  20fb							; 
   1592  20fb
   1593  20fb				   .
   1594  20fb							; 
   1595  20fb
   1596  20fb				   .
   1597  20fb							; 
   1598  20fb
   1599  20fb				   .
   1600  20fb							; 
   1601  20fb
   1602  20fb				   .
   1603  20fb							; 
   1604  20fb
   1605  20fb				   .
   1606  20fb							; 
   1607  20fb
   1608  20fb				   .
   1609  20fb							; 
   1610  20fb
   1611  20fb				   .
   1612  20fb							; 
   1613  20fb
   1614  20fb				   .
   1615  20fb							; 
   1616  20fb
   1617  20fb				   .
   1618  20fb							; 
   1619  20fb
   1620  20fb				   .
   1621  20fb							; 
   1622  20fb
   1623  20fb				   .
   1624  20fb							; 
   1625  20fb
   1626  20fb				   .
   1627  20fb							; 
   1628  20fb
   1629  20fb				   .
   1630  20fb							; 
   1631  20fb
   1632  20fb				   .
   1633  20fb							; 
   1634  20fb
   1635  20fb				   .
   1636  20fb							; 
   1637  20fb
   1638  20fb				   .
   1639  20fb							; 
   1640  20fb
   1641  20fb				   .
   1642  20fb							; 
   1643  20fb
   1644  20fb				   .
   1645  20fb							; 
   1646  20fb
   1647  20fb				   .
   1648  20fb							; 
   1649  20fb
   1650  20fb				   .
   1651  20fb							; 
   1652  20fb
   1653  20fb				   .
   1654  20fb							; 
   1655  20fb
   1656  20fb				   .
   1657  20fb							; 
   1658  20fb
   1659  20fb				   .
   1660  20fb							; 
   1661  20fb
   1662  20fb				   .
   1663  20fb							; 
   1664  20fb
   1665  20fb				   .
   1666  20fb							; 
   1667  20fb
   1668  20fb				   .
   1669  20fb							; 
   1670  20fb
   1671  20fb				   .
   1672  20fb							; 
   1673  20fb
   1674  20fb				   .
   1675  20fb							; 
   1676  20fb
   1677  20fb				   .
   1678  20fb							; 
   1679  20fb
   1680  20fb				   .
   1681  20fb							; 
   1682  20fb
   1683  20fb				   .
   1684  20fb							; 
   1685  20fb
   1686  20fb				   .
   1687  20fb							; 
   1688  20fb
   1689  20fb				   .
   1690  20fb							; 
   1691  20fb
   1692  20fb				   .
   1693  20fb							; 
   1694  20fb
   1695  20fb				   .
   1696  20fb							; 
   1697  20fb
   1698  20fb				   .
   1699  20fb							; 
   1700  20fb
   1701  20fb				   .
   1702  20fb							; 
   1703  20fb
   1704  20fb				   .
   1705  20fb							; 
   1706  20fb
   1707  20fb				   .
   1708  20fb							; 
   1709  20fb
   1710  20fb				   .
   1711  20fb							; 
   1712  20fb
   1713  20fb				   .
   1714  20fb							; 
   1715  20fb
   1716  20fb				   .
   1717  20fb							; 
   1718  20fb
   1719  20fb				   .
   1720  20fb							; 
   1721  20fb
   1722  20fb				   .
   1723  20fb							; 
   1724  20fb
   1725  20fb				   .
   1726  20fb							; 
   1727  20fb
   1728  20fb				   .
   1729  20fb							; 
   1730  20fb
   1731  20fb				   .
   1732  20fb							; 
   1733  20fb
   1734  20fb				   .
   1735  20fb							; 
   1736  20fb
   1737  20fb				   .
   1738  20fb							; 
   1739  20fb
   1740  20fb				   .
   1741  20fb							; 
   1742  20fb
   1743  20fb				   .
   1744  20fb							; 
   1745  20fb
   1746  20fb				   .L012		;  const PFCOLSLOW  =	# <  ( PFCOLS ) 
   1747  20fb
   1748  20fb				   .L013		;  const PFCOLSHI  =  # (  > PFCOLS )	 &  $0F
   1749  20fb
   1750  20fb				   .
   1751  20fb							; 
   1752  20fb
   1753  20fb				   .L014		;  const BKCOLSLOW  =	# <  ( BKCOLS ) 
   1754  20fb
   1755  20fb				   .L015		;  const BKCOLSHI  =  # (  > BKCOLS )	 &  $0F
   1756  20fb
   1757  20fb				   .
   1758  20fb							; 
   1759  20fb
   1760  20fb				   .L016		;  for var0  =  0 to 87 step 1
   1761  20fb
   1762  20fb		       a9 00		      LDA	#0
   1763  20fd		       85 ec		      STA	var0
   1764  20ff				   .L016forvar0
   1765  20ff				   .L017		;  DF0LOW  =  BKCOLSLOW  +  var0
   1766  20ff
   1767  20ff		       a9 a5		      LDA	#BKCOLSLOW
   1768  2101		       18		      CLC
   1769  2102		       65 ec		      ADC	var0
   1770  2104		       8d 50 10 	      STA	DF0LOW
   1771  2107				   .L018		;  DF0HI  =  BKCOLSHI
   1772  2107
   1773  2107		       a9 0b		      LDA	#BKCOLSHI
   1774  2109		       8d 68 10 	      STA	DF0HI
   1775  210c				   .L019		;  DF0PUSH  =	$00
   1776  210c
   1777  210c		       a9 00		      LDA	#$00
   1778  210e		       8d 60 10 	      STA	DF0PUSH
   1779  2111				   .L020		;  next
   1780  2111
   1781  2111		       a5 ec		      LDA	var0
   1782  2113		       18		      CLC
   1783  2114		       69 01		      ADC	#1
   1784  2116
   1785  2116		       85 ec		      STA	var0
   1786  2118		       c9 58		      CMP	#87+1
   1787  211a		       90 e3		      bcc	.L016forvar0
   1788  211c				  -	      if	( (((((#>*)&$1f)*256)|(#<.L016forvar0))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.L016forvar0))<=(bankswitch_hotspot+bs_mask)) )
   1789  211c				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   1790  211c					      endif
   1791  211c				   .
   1792  211c							; 
   1793  211c
   1794  211c				   .
   1795  211c							; 
   1796  211c
   1797  211c				   .
   1798  211c							; 
   1799  211c
   1800  211c				   .
   1801  211c							; 
   1802  211c
   1803  211c				   .L021		;  DF6FRACINC	=  255	:  DF4FRACINC  =  255
   1804  211c
   1805  211c		       a9 ff		      LDA	#255
   1806  211e		       8d 3e 10 	      STA	DF6FRACINC
   1807  2121		       8d 3c 10 	      STA	DF4FRACINC
   1808  2124				   .L022		;  DF0FRACINC	=  128	:  DF1FRACINC  =  128  :  DF2FRACINC  =  128  :  DF3FRACINC  =	128
   1809  2124
   1810  2124		       a9 80		      LDA	#128
   1811  2126		       8d 38 10 	      STA	DF0FRACINC
   1812  2129		       8d 39 10 	      STA	DF1FRACINC
   1813  212c		       8d 3a 10 	      STA	DF2FRACINC
   1814  212f		       8d 3b 10 	      STA	DF3FRACINC
   1815  2132				   .L023		;  asm
   1816  2132
   1817  2132		       ad 1e 10 	      LDA	DF6FRACDATA	; bgcolor priming read (first value will be read twice)
   1818  2135
   1819  2135		       ad 1c 10 	      LDA	DF4FRACDATA	; pfcolor priming read (first value will be read twice)
   1820  2138
   1821  2138				   .
   1822  2138							; 
   1823  2138
   1824  2138				   .
   1825  2138							; 
   1826  2138
   1827  2138				   .
   1828  2138							; 
   1829  2138
   1830  2138				   .
   1831  2138							; 
   1832  2138
   1833  2138				   .
   1834  2138							; 
   1835  2138
   1836  2138				   .L024		;  drawscreen
   1837  2138
   1838  2138		       85 81		      sta	temp7
   1839  213a		       a9 31		      lda	#>(ret_point1-1)
   1840  213c		       48		      pha
   1841  213d		       a9 4f		      lda	#<(ret_point1-1)
   1842  213f		       48		      pha
   1843  2140		       a9 19		      lda	#>(drawscreen-1)
   1844  2142		       48		      pha
   1845  2143		       a9 48		      lda	#<(drawscreen-1)
   1846  2145		       48		      pha
   1847  2146		       a5 81		      lda	temp7
   1848  2148		       48		      pha
   1849  2149		       8a		      txa
   1850  214a		       48		      pha
   1851  214b		       a2 01		      ldx	#1
   1852  214d		       4c ee df 	      jmp	BS_jsr
   1853  2150				   ret_point1
   1854  2150				   .
   1855  2150							; 
   1856  2150
   1857  2150				   .L025		;  dim linePos1  =  a.g  :  dim linePosArray  =  a
   1858  2150
   1859  2150				   .L026		;  a = 0 : g = 0
   1860  2150
   1861  2150		       a9 00		      LDA	#0
   1862  2152		       85 d1		      STA	a
   1863  2154		       85 d7		      STA	g
   1864  2156				   .
   1865  2156							; 
   1866  2156
   1867  2156				   .L027		;  dim linePos2  =  b.h
   1868  2156
   1869  2156				   .L028		;  b = 0 : h = 0
   1870  2156
   1871  2156		       a9 00		      LDA	#0
   1872  2158		       85 d2		      STA	b
   1873  215a		       85 d8		      STA	h
   1874  215c				   .
   1875  215c							; 
   1876  215c
   1877  215c				   .L029		;  dim linePos3  =  c.i
   1878  215c
   1879  215c				   .L030		;  c = 0 : i = 0
   1880  215c
   1881  215c		       a9 00		      LDA	#0
   1882  215e		       85 d3		      STA	c
   1883  2160		       85 d9		      STA	i
   1884  2162				   .
   1885  2162							; 
   1886  2162
   1887  2162				   .L031		;  dim linePos4  =  d.j
   1888  2162
   1889  2162				   .L032		;  d = 0 : j = 0
   1890  2162
   1891  2162		       a9 00		      LDA	#0
   1892  2164		       85 d4		      STA	d
   1893  2166		       85 da		      STA	j
   1894  2168				   .
   1895  2168							; 
   1896  2168
   1897  2168				   .
   1898  2168							; 
   1899  2168
   1900  2168				   .
   1901  2168							; 
   1902  2168
   1903  2168				   .
   1904  2168							; 
   1905  2168
   1906  2168				   .
   1907  2168							; 
   1908  2168
   1909  2168				   .
   1910  2168							; 
   1911  2168
   1912  2168				   .
   1913  2168							; 
   1914  2168
   1915  2168				   .
   1916  2168							; 
   1917  2168
   1918  2168				   .
   1919  2168							; 
   1920  2168
   1921  2168				   .
   1922  2168							; 
   1923  2168
   1924  2168				   .L033		;  dim timer  =  m
   1925  2168
   1926  2168				   .L034		;  timer  =  0
   1927  2168
   1928  2168		       a9 00		      LDA	#0
   1929  216a		       85 dd		      STA	timer
   1930  216c				   .
   1931  216c							; 
   1932  216c
   1933  216c				   .L035		;  dim timerLength  =	e
   1934  216c
   1935  216c				   .L036		;  timerLength  =  1
   1936  216c
   1937  216c		       a9 01		      LDA	#1
   1938  216e		       85 d5		      STA	timerLength
   1939  2170				   .
   1940  2170							; 
   1941  2170
   1942  2170				   .L037		;  dim nextRand  =  n
   1943  2170
   1944  2170				   .L038		;  nextRand  =  0
   1945  2170
   1946  2170		       a9 00		      LDA	#0
   1947  2172		       85 de		      STA	nextRand
   1948  2174				   .
   1949  2174							; 
   1950  2174
   1951  2174				   .
   1952  2174							; 
   1953  2174
   1954  2174				   .
   1955  2174							; 
   1956  2174
   1957  2174				   .
   1958  2174							; 
   1959  2174
   1960  2174				   .L039		;  dim speedup1  =  o.u
   1961  2174
   1962  2174				   .L040		;  dim speedup2  =  p.v
   1963  2174
   1964  2174				   .L041		;  dim speedup3  =  q.w
   1965  2174
   1966  2174				   .L042		;  dim speedup4  =  r.x
   1967  2174
   1968  2174				   .
   1969  2174							; 
   1970  2174
   1971  2174				   .
   1972  2174							; 
   1973  2174
   1974  2174				   .L043		;  speedup1  =  0.0
   1975  2174
   1976  2174		       a2 00		      LDX	#0
   1977  2176		       86 e5		      STX	u
   1978  2178		       a9 00		      LDA	#0
   1979  217a		       85 df		      STA	speedup1
   1980  217c				   .L044		;  speedup2  =  0.0
   1981  217c
   1982  217c		       a2 00		      LDX	#0
   1983  217e		       86 e6		      STX	v
   1984  2180		       a9 00		      LDA	#0
   1985  2182		       85 e0		      STA	speedup2
   1986  2184				   .L045		;  speedup3  =  0.0
   1987  2184
   1988  2184		       a2 00		      LDX	#0
   1989  2186		       86 e7		      STX	w
   1990  2188		       a9 00		      LDA	#0
   1991  218a		       85 e1		      STA	speedup3
   1992  218c				   .L046		;  speedup4  =  0.0
   1993  218c
   1994  218c		       a2 00		      LDX	#0
   1995  218e		       86 e8		      STX	x
   1996  2190		       a9 00		      LDA	#0
   1997  2192		       85 e2		      STA	speedup4
   1998  2194				   .
   1999  2194							; 
   2000  2194
   2001  2194				   .
   2002  2194							; 
   2003  2194
   2004  2194				   .
   2005  2194							; 
   2006  2194
   2007  2194				   .
   2008  2194							; 
   2009  2194
   2010  2194							;.rightBit.var0{0}.
   2011  2194				   .L047		;  def rightBit = var0{0}
   2012  2194
   2013  2194							;.leftBit.var0{1}.
   2014  2194				   .L048		;  def leftBit = var0{1}
   2015  2194
   2016  2194							;.flipBit.var0{2}.
   2017  2194				   .L049		;  def flipBit = var0{2}
   2018  2194
   2019  2194							;.resetRestrainer.var0{3}.
   2020  2194				   .L050		;  def resetRestrainer = var0{3}
   2021  2194
   2022  2194							;.gameOverBit.var0{4}.
   2023  2194				   .L051		;  def gameOverBit = var0{4}
   2024  2194
   2025  2194							;.overlapped.var0{5}.
   2026  2194				   .L052		;  def overlapped = var0{5}
   2027  2194
   2028  2194				   .L053		;  var0  =  0
   2029  2194
   2030  2194		       a9 00		      LDA	#0
   2031  2196		       85 ec		      STA	var0
   2032  2198				   .
   2033  2198							; 
   2034  2198
   2035  2198				   .
   2036  2198							; 
   2037  2198
   2038  2198				   .L054		;  dim hole1x	=  var1
   2039  2198
   2040  2198				   .L055		;  dim hole2x	=  var2
   2041  2198
   2042  2198				   .L056		;  dim hole3x	=  var3
   2043  2198
   2044  2198				   .L057		;  dim hole4x	=  var4
   2045  2198
   2046  2198				   .
   2047  2198							; 
   2048  2198
   2049  2198				   .
   2050  2198							; 
   2051  2198
   2052  2198				   .
   2053  2198							; 
   2054  2198
   2055  2198				   .
   2056  2198							; 
   2057  2198
   2058  2198				   .
   2059  2198							; 
   2060  2198
   2061  2198				   .
   2062  2198							; 
   2063  2198
   2064  2198				   .
   2065  2198							; 
   2066  2198
   2067  2198				   .
   2068  2198							; 
   2069  2198
   2070  2198				   .L058		;  DF6FRACINC	=  255	:  DF4FRACINC  =  255
   2071  2198
   2072  2198		       a9 ff		      LDA	#255
   2073  219a		       8d 3e 10 	      STA	DF6FRACINC
   2074  219d		       8d 3c 10 	      STA	DF4FRACINC
   2075  21a0				   .L059		;  DF0FRACINC	=  128	:  DF1FRACINC  =  128  :  DF2FRACINC  =  128  :  DF3FRACINC  =	128
   2076  21a0
   2077  21a0		       a9 80		      LDA	#128
   2078  21a2		       8d 38 10 	      STA	DF0FRACINC
   2079  21a5		       8d 39 10 	      STA	DF1FRACINC
   2080  21a8		       8d 3a 10 	      STA	DF2FRACINC
   2081  21ab		       8d 3b 10 	      STA	DF3FRACINC
   2082  21ae				   .L060		;  asm
   2083  21ae
   2084  21ae							;LDA DF6FRACDATA ; bgcolor priming read (first value will be read twice)
   2085  21ae
   2086  21ae							;LDA DF4FRACDATA ; pfcolor priming read (first value will be read twice)
   2087  21ae
   2088  21ae				   .
   2089  21ae							; 
   2090  21ae
   2091  21ae				   .
   2092  21ae							; 
   2093  21ae
   2094  21ae				   .
   2095  21ae							; 
   2096  21ae
   2097  21ae				   .
   2098  21ae							; 
   2099  21ae
   2100  21ae				   .
   2101  21ae							; 
   2102  21ae
   2103  21ae				   .L061		;  drawscreen
   2104  21ae
   2105  21ae		       85 81		      sta	temp7
   2106  21b0		       a9 31		      lda	#>(ret_point2-1)
   2107  21b2		       48		      pha
   2108  21b3		       a9 c5		      lda	#<(ret_point2-1)
   2109  21b5		       48		      pha
   2110  21b6		       a9 19		      lda	#>(drawscreen-1)
   2111  21b8		       48		      pha
   2112  21b9		       a9 48		      lda	#<(drawscreen-1)
   2113  21bb		       48		      pha
   2114  21bc		       a5 81		      lda	temp7
   2115  21be		       48		      pha
   2116  21bf		       8a		      txa
   2117  21c0		       48		      pha
   2118  21c1		       a2 01		      ldx	#1
   2119  21c3		       4c ee df 	      jmp	BS_jsr
   2120  21c6				   ret_point2
   2121  21c6				   .
   2122  21c6							; 
   2123  21c6
   2124  21c6				   .L062		;  missile0height  =  80
   2125  21c6
   2126  21c6		       a9 50		      LDA	#80
   2127  21c8		       85 c2		      STA	missile0height
   2128  21ca				   .L063		;  missile0x  =  79
   2129  21ca
   2130  21ca		       a9 4f		      LDA	#79
   2131  21cc		       85 82		      STA	missile0x
   2132  21ce				   .L064		;  COLUM0  =  $08
   2133  21ce
   2134  21ce		       a9 08		      LDA	#$08
   2135  21d0		       85 bb		      STA	COLUM0
   2136  21d2				   .
   2137  21d2							; 
   2138  21d2
   2139  21d2				   .
   2140  21d2							; 
   2141  21d2
   2142  21d2				   .L065		;  missile1height  =  4
   2143  21d2
   2144  21d2		       a9 04		      LDA	#4
   2145  21d4		       85 c3		      STA	missile1height
   2146  21d6				   .
   2147  21d6							; 
   2148  21d6
   2149  21d6				   .L066		;  dim m1x  =	missile1x.f
   2150  21d6
   2151  21d6				   .L067		;  m1x  =  80.0
   2152  21d6
   2153  21d6		       a2 00		      LDX	#0
   2154  21d8		       86 d6		      STX	f
   2155  21da		       a9 50		      LDA	#80
   2156  21dc		       85 83		      STA	m1x
   2157  21de				   .
   2158  21de							; 
   2159  21de
   2160  21de				   .L068		;  missile1y  =  149
   2161  21de
   2162  21de		       a9 95		      LDA	#149
   2163  21e0		       85 c0		      STA	missile1y
   2164  21e2				   .
   2165  21e2							; 
   2166  21e2
   2167  21e2				   .L069		;  NUSIZ2  =  $03
   2168  21e2
   2169  21e2		       a9 03		      LDA	#$03
   2170  21e4		       85 b0		      STA	NUSIZ2
   2171  21e6				   .L070		;  _NUSIZ1  =	$10  :	NUSIZ3	=  $10	:  NUSIZ4  =  $10  :  NUSIZ5  =  $10  :  NUSIZ6  =  $10  :  NUSIZ7  =  $10  :  NUSIZ8  =  $10  :  NUSIZ9  =  $10
   2172  21e6
   2173  21e6		       a9 10		      LDA	#$10
   2174  21e8		       85 af		      STA	_NUSIZ1
   2175  21ea		       85 b1		      STA	NUSIZ3
   2176  21ec		       85 b2		      STA	NUSIZ4
   2177  21ee		       85 b3		      STA	NUSIZ5
   2178  21f0		       85 b4		      STA	NUSIZ6
   2179  21f2		       85 b5		      STA	NUSIZ7
   2180  21f4		       85 b6		      STA	NUSIZ8
   2181  21f6		       85 b7		      STA	NUSIZ9
   2182  21f8				   .
   2183  21f8							; 
   2184  21f8
   2185  21f8				   .
   2186  21f8							; 
   2187  21f8
   2188  21f8				   .
   2189  21f8							; 
   2190  21f8
   2191  21f8				   .
   2192  21f8							; 
   2193  21f8
   2194  21f8				   .
   2195  21f8							; 
   2196  21f8
   2197  21f8				   .
   2198  21f8							; 
   2199  21f8
   2200  21f8				   .L071		;  DF0LOW  =  PFCOLSLOW  +  87
   2201  21f8
   2202  21f8		       a9 08		      LDA	#PFCOLSLOW
   2203  21fa		       18		      CLC
   2204  21fb		       69 57		      ADC	#87
   2205  21fd		       8d 50 10 	      STA	DF0LOW
   2206  2200				   .L072		;  DF0HI  =  PFCOLSHI
   2207  2200
   2208  2200		       a9 0a		      LDA	#PFCOLSHI
   2209  2202		       8d 68 10 	      STA	DF0HI
   2210  2205				   .L073		;  DF0PUSH  =	$0e
   2211  2205
   2212  2205		       a9 0e		      LDA	#$0e
   2213  2207		       8d 60 10 	      STA	DF0PUSH
   2214  220a				   .
   2215  220a							; 
   2216  220a
   2217  220a				   .
   2218  220a							; 
   2219  220a
   2220  220a				   .
   2221  220a							; 
   2222  220a
   2223  220a				   .
   2224  220a							; 
   2225  220a
   2226  220a				   .
   2227  220a							; 
   2228  220a
   2229  220a				   .
   2230  220a							; 
   2231  220a
   2232  220a				   .
   2233  220a							; 
   2234  220a
   2235  220a				   .L074		;  player0:
   2236  220a
   2237  220a		       a2 23		      LDX	#<playerL074_0
   2238  220c		       86 bd		      STX	player0pointerlo
   2239  220e		       a9 62		      LDA	#((>playerL074_0) & $0f) | (((>playerL074_0) / 2) & $70)
   2240  2210		       85 be		      STA	player0pointerhi
   2241  2212		       a9 05		      LDA	#5
   2242  2214		       85 a5		      STA	player0height
   2243  2216				   .
   2244  2216							; 
   2245  2216
   2246  2216				   .
   2247  2216							; 
   2248  2216
   2249  2216				   .
   2250  2216							; 
   2251  2216
   2252  2216				   .
   2253  2216							; 
   2254  2216
   2255  2216				   .
   2256  2216							; 
   2257  2216
   2258  2216				   .
   2259  2216							; 
   2260  2216
   2261  2216				   .
   2262  2216							; 
   2263  2216
   2264  2216				   .
   2265  2216							; 
   2266  2216
   2267  2216				   .
   2268  2216							; 
   2269  2216
   2270  2216				   .
   2271  2216							; 
   2272  2216
   2273  2216				   .L075		;  player0color:
   2274  2216
   2275  2216		       a2 28		      LDX	#<playercolorL075_0
   2276  2218		       86 a3		      STX	player0color
   2277  221a		       a9 62		      LDA	#((>playercolorL075_0) & $0f) | (((>playercolorL075_0) / 2) & $70)
   2278  221c		       85 a4		      STA	player0color+1
   2279  221e				   .
   2280  221e							; 
   2281  221e
   2282  221e				   .L076		;  player0y  =  83
   2283  221e
   2284  221e		       a9 53		      LDA	#83
   2285  2220		       85 99		      STA	player0y
   2286  2222				   .L077		;  player0x  =  101
   2287  2222
   2288  2222		       a9 65		      LDA	#101
   2289  2224		       85 80		      STA	player0x
   2290  2226				   .
   2291  2226							; 
   2292  2226
   2293  2226				   .
   2294  2226							; 
   2295  2226
   2296  2226				   .
   2297  2226							; 
   2298  2226
   2299  2226				   .
   2300  2226							; 
   2301  2226
   2302  2226				   .
   2303  2226							; 
   2304  2226
   2305  2226				   .
   2306  2226							; 
   2307  2226
   2308  2226				   .
   2309  2226							; 
   2310  2226
   2311  2226				   .
   2312  2226							; 
   2313  2226
   2314  2226				   .
   2315  2226							; 
   2316  2226
   2317  2226				   .
   2318  2226							; 
   2319  2226
   2320  2226				   .
   2321  2226							; 
   2322  2226
   2323  2226				   .
   2324  2226							; 
   2325  2226
   2326  2226				   .
   2327  2226							; 
   2328  2226
   2329  2226				   .
   2330  2226							; 
   2331  2226
   2332  2226				   .
   2333  2226							; 
   2334  2226
   2335  2226				   .
   2336  2226							; 
   2337  2226
   2338  2226				   .L078		;  player2color:
   2339  2226
   2340  2226		       a9 f6		      lda	#<(playerpointers+20)
   2341  2228		       8d 50 10 	      sta	DF0LOW
   2342  222b		       a9 01		      lda	#(>(playerpointers+20)) & $0F
   2343  222d		       8d 68 10 	      sta	DF0HI
   2344  2230		       a2 2e		      LDX	#<playercolorL078_2
   2345  2232		       8e 78 10 	      STX	DF0WRITE
   2346  2235		       a9 62		      LDA	#((>playercolorL078_2) & $0f) | (((>playercolorL078_2) / 2) & $70)
   2347  2237		       8d 78 10 	      STA	DF0WRITE
   2348  223a				   .
   2349  223a							; 
   2350  223a
   2351  223a				   .L079		;  player2y  =  80
   2352  223a
   2353  223a		       a9 50		      LDA	#80
   2354  223c		       85 9b		      STA	player2y
   2355  223e				   .
   2356  223e							; 
   2357  223e
   2358  223e				   .
   2359  223e							; 
   2360  223e
   2361  223e				   .
   2362  223e							; 
   2363  223e
   2364  223e				   .
   2365  223e							; 
   2366  223e
   2367  223e				   .
   2368  223e							; 
   2369  223e
   2370  223e				   .
   2371  223e							; 
   2372  223e
   2373  223e				   .L080		;  nextRand  =   ( rand & 31 ) 
   2374  223e
   2375  223e							; complex statement detected
   2376  223e		       ad 00 10 	      lda	rand
   2377  2241		       29 1f		      AND	#31
   2378  2243		       85 de		      STA	nextRand
   2379  2245				   .
   2380  2245							; 
   2381  2245
   2382  2245				   .L081		;  for var1  =  0 to 59
   2383  2245
   2384  2245		       a9 00		      LDA	#0
   2385  2247		       85 ed		      STA	var1
   2386  2249				   .L081forvar1
   2387  2249				   .L082		;  gosub reUsed
   2388  2249
   2389  2249		       20 d5 39 	      jsr	.reUsed
   2390  224c
   2391  224c				   .L083		;  next
   2392  224c
   2393  224c		       a5 ed		      LDA	var1
   2394  224e		       c9 3b		      CMP	#59
   2395  2250
   2396  2250		       e6 ed		      INC	var1
   2397  2252		       90 f5		      bcc	.L081forvar1
   2398  2254				  -	      if	( (((((#>*)&$1f)*256)|(#<.L081forvar1))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.L081forvar1))<=(bankswitch_hotspot+bs_mask)) )
   2399  2254				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   2400  2254					      endif
   2401  2254				   .
   2402  2254							; 
   2403  2254
   2404  2254				   .
   2405  2254							; 
   2406  2254
   2407  2254				   .L084		;  player1color:
   2408  2254
   2409  2254		       a9 f4		      lda	#<(playerpointers+18)
   2410  2256		       8d 50 10 	      sta	DF0LOW
   2411  2259		       a9 01		      lda	#(>(playerpointers+18)) & $0F
   2412  225b		       8d 68 10 	      sta	DF0HI
   2413  225e		       a2 36		      LDX	#<playercolorL084_1
   2414  2260		       8e 78 10 	      STX	DF0WRITE
   2415  2263		       a9 62		      LDA	#((>playercolorL084_1) & $0f) | (((>playercolorL084_1) / 2) & $70)
   2416  2265		       8d 78 10 	      STA	DF0WRITE
   2417  2268				   .L085		;  player1y  =  120
   2418  2268
   2419  2268		       a9 78		      LDA	#120
   2420  226a		       85 9a		      STA	player1y
   2421  226c				   .L086		;  player1x  =  76
   2422  226c
   2423  226c		       a9 4c		      LDA	#76
   2424  226e		       85 90		      STA	player1x
   2425  2270				   .L087		;  player1height  =  8
   2426  2270
   2427  2270		       a9 08		      LDA	#8
   2428  2272		       85 a6		      STA	player1height
   2429  2274				   .L088		;  dim displayNumber  =  var3	:  var3  =  3
   2430  2274
   2431  2274		       a9 03		      LDA	#3
   2432  2276		       85 ef		      STA	var3
   2433  2278				   .L089		;  var1  =  0	:  var2  =  0
   2434  2278
   2435  2278		       a9 00		      LDA	#0
   2436  227a		       85 ed		      STA	var1
   2437  227c		       85 ee		      STA	var2
   2438  227e				   .
   2439  227e							; 
   2440  227e
   2441  227e				   .L090		;  ballx  =  90
   2442  227e
   2443  227e		       a9 5a		      LDA	#90
   2444  2280		       85 84		      STA	ballx
   2445  2282				   .L091		;  bally  =  0
   2446  2282
   2447  2282		       a9 00		      LDA	#0
   2448  2284		       85 c1		      STA	bally
   2449  2286				   .L092		;  ballheight	=  0
   2450  2286
   2451  2286		       a9 00		      LDA	#0
   2452  2288		       85 c4		      STA	ballheight
   2453  228a				   .L093		;  CTRLPF  =  11
   2454  228a
   2455  228a		       a9 0b		      LDA	#11
   2456  228c		       85 0a		      STA	CTRLPF
   2457  228e				   .
   2458  228e							; 
   2459  228e
   2460  228e				   .countdownLoop
   2461  228e							; countdownLoop
   2462  228e
   2463  228e				   .L094		;  for temp5  =  1 to 40 step 1
   2464  228e
   2465  228e		       a9 01		      LDA	#1
   2466  2290		       85 cf		      STA	temp5
   2467  2292				   .L094fortemp5
   2468  2292				   .L095		;  DF0LOW  =  PFCOLSLOW  +  temp5
   2469  2292
   2470  2292		       a9 08		      LDA	#PFCOLSLOW
   2471  2294		       18		      CLC
   2472  2295		       65 cf		      ADC	temp5
   2473  2297		       8d 50 10 	      STA	DF0LOW
   2474  229a				   .L096		;  DF0HI  =  PFCOLSHI
   2475  229a
   2476  229a		       a9 0a		      LDA	#PFCOLSHI
   2477  229c		       8d 68 10 	      STA	DF0HI
   2478  229f				   .L097		;  DF0PUSH  =	$0e
   2479  229f
   2480  229f		       a9 0e		      LDA	#$0e
   2481  22a1		       8d 60 10 	      STA	DF0PUSH
   2482  22a4				   .L098		;  next
   2483  22a4
   2484  22a4		       a5 cf		      LDA	temp5
   2485  22a6		       18		      CLC
   2486  22a7		       69 01		      ADC	#1
   2487  22a9
   2488  22a9		       85 cf		      STA	temp5
   2489  22ab		       c9 29		      CMP	#40+1
   2490  22ad		       90 e3		      bcc	.L094fortemp5
   2491  22af				  -	      if	( (((((#>*)&$1f)*256)|(#<.L094fortemp5))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.L094fortemp5))<=(bankswitch_hotspot+bs_mask)) )
   2492  22af				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   2493  22af					      endif
   2494  22af				   .
   2495  22af							; 
   2496  22af
   2497  22af				   .L099		;  if displayNumber  =  2 then ballx  =  ballx  -  2  :  bally  =  bally  +  2  :  ballheight	=  2
   2498  22af
   2499  22af		       a5 ef		      LDA	displayNumber
   2500  22b1		       c9 02		      CMP	#2
   2501  22b3		       d0 12		      BNE	.skipL099
   2502  22b5				   .condpart0
   2503  22b5		       a5 84		      LDA	ballx
   2504  22b7		       38		      SEC
   2505  22b8		       e9 02		      SBC	#2
   2506  22ba		       85 84		      STA	ballx
   2507  22bc		       a5 c1		      LDA	bally
   2508  22be		       18		      CLC
   2509  22bf		       69 02		      ADC	#2
   2510  22c1		       85 c1		      STA	bally
   2511  22c3		       a9 02		      LDA	#2
   2512  22c5		       85 c4		      STA	ballheight
   2513  22c7				   .skipL099
   2514  22c7				   .L0100		;  if bally  >  80 then ballheight  =	0
   2515  22c7
   2516  22c7		       a9 50		      LDA	#80
   2517  22c9		       c5 c1		      CMP	bally
   2518  22cb		       b0 04		      BCS	.skipL0100
   2519  22cd				   .condpart1
   2520  22cd		       a9 00		      LDA	#0
   2521  22cf		       85 c4		      STA	ballheight
   2522  22d1				   .skipL0100
   2523  22d1				   .
   2524  22d1							; 
   2525  22d1
   2526  22d1				   .L0101		;  temp5  =  displayNumber  *	8
   2527  22d1
   2528  22d1		       a5 ef		      LDA	displayNumber
   2529  22d3		       0a		      asl
   2530  22d4		       0a		      asl
   2531  22d5		       0a		      asl
   2532  22d6		       85 cf		      STA	temp5
   2533  22d8				   .L0102		;  asm
   2534  22d8
   2535  22d8		       a9 e2		      lda	#<(playerpointers+0)
   2536  22da
   2537  22da		       8d 50 10 	      sta	DF0LOW
   2538  22dd
   2539  22dd		       a9 01		      lda	#(>(playerpointers+0)) & $0F
   2540  22df
   2541  22df		       8d 68 10 	      sta	DF0HI
   2542  22e2
   2543  22e2
   2544  22e2
   2545  22e2		       18		      clc
   2546  22e3
   2547  22e3		       a9 03		      LDA	#<_scoretable2
   2548  22e5
   2549  22e5		       65 cf		      adc	temp5
   2550  22e7
   2551  22e7		       8d 78 10 	      STA	DF0WRITE
   2552  22ea
   2553  22ea		       a9 62		      LDA	#((>_scoretable2) & $0f) | (((>_scoretable2) / 2) & $70)
   2554  22ec
   2555  22ec		       8d 78 10 	      STA	DF0WRITE
   2556  22ef
   2557  22ef				   .L0103		;  gosub reUsed
   2558  22ef
   2559  22ef		       20 d5 39 	      jsr	.reUsed
   2560  22f2
   2561  22f2				   .L0104		;  var1  =  var1  +  1
   2562  22f2
   2563  22f2		       e6 ed		      INC	var1
   2564  22f4				   .L0105		;  if var1  =	60 then var1  =  0  :  displayNumber  =  displayNumber	-  1
   2565  22f4
   2566  22f4		       a5 ed		      LDA	var1
   2567  22f6		       c9 3c		      CMP	#60
   2568  22f8		       d0 06		      BNE	.skipL0105
   2569  22fa				   .condpart2
   2570  22fa		       a9 00		      LDA	#0
   2571  22fc		       85 ed		      STA	var1
   2572  22fe		       c6 ef		      DEC	displayNumber
   2573  2300				   .skipL0105
   2574  2300				   .L0106		;  if displayNumber  <>  0 then goto countdownLoop
   2575  2300
   2576  2300		       a5 ef		      LDA	displayNumber
   2577  2302		       c9 00		      CMP	#0
   2578  2304		       f0 03		      BEQ	.skipL0106
   2579  2306				   .condpart3
   2580  2306		       4c 8e 32 	      jmp	.countdownLoop
   2581  2309
   2582  2309				   .skipL0106
   2583  2309				   .
   2584  2309							; 
   2585  2309
   2586  2309				   .L0107		;  for temp5  =  0 to 31
   2587  2309
   2588  2309		       a9 00		      LDA	#0
   2589  230b		       85 cf		      STA	temp5
   2590  230d				   .L0107fortemp5
   2591  230d				   .L0108		;  pfpixel temp5 87 on
   2592  230d
   2593  230d		       a9 a4		      lda	#<C_function
   2594  230f		       8d 50 10 	      sta	DF0LOW
   2595  2312		       a9 01		      lda	#(>C_function) & $0F
   2596  2314		       8d 68 10 	      sta	DF0HI
   2597  2317		       a2 0c		      LDX	#12
   2598  2319		       8e 78 10 	      STX	DF0WRITE
   2599  231c		       8e 78 10 	      STX	DF0WRITE
   2600  231f		       a0 57		      LDY	#87
   2601  2321		       8c 78 10 	      STY	DF0WRITE
   2602  2324		       a5 cf		      LDA	temp5
   2603  2326		       8d 78 10 	      STA	DF0WRITE
   2604  2329		       a9 ff		      lda	#255
   2605  232b		       8d 5a 10 	      sta	CALLFUNCTION
   2606  232e				   .L0109		;  next
   2607  232e
   2608  232e		       a5 cf		      LDA	temp5
   2609  2330		       c9 1f		      CMP	#31
   2610  2332
   2611  2332		       e6 cf		      INC	temp5
   2612  2334		       90 d7		      bcc	.L0107fortemp5
   2613  2336				  -	      if	( (((((#>*)&$1f)*256)|(#<.L0107fortemp5))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.L0107fortemp5))<=(bankswitch_hotspot+bs_mask)) )
   2614  2336				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   2615  2336					      endif
   2616  2336				   .
   2617  2336							; 
   2618  2336
   2619  2336				   .
   2620  2336							; 
   2621  2336
   2622  2336				   .L0110		;  for temp5  =  0 to 40 step 1
   2623  2336
   2624  2336		       a9 00		      LDA	#0
   2625  2338		       85 cf		      STA	temp5
   2626  233a				   .L0110fortemp5
   2627  233a				   .L0111		;  DF0LOW  =  PFCOLSLOW  +  temp5
   2628  233a
   2629  233a		       a9 08		      LDA	#PFCOLSLOW
   2630  233c		       18		      CLC
   2631  233d		       65 cf		      ADC	temp5
   2632  233f		       8d 50 10 	      STA	DF0LOW
   2633  2342				   .L0112		;  DF0HI  =  PFCOLSHI
   2634  2342
   2635  2342		       a9 0a		      LDA	#PFCOLSHI
   2636  2344		       8d 68 10 	      STA	DF0HI
   2637  2347				   .L0113		;  DF0PUSH  =	$00
   2638  2347
   2639  2347		       a9 00		      LDA	#$00
   2640  2349		       8d 60 10 	      STA	DF0PUSH
   2641  234c				   .L0114		;  next
   2642  234c
   2643  234c		       a5 cf		      LDA	temp5
   2644  234e		       18		      CLC
   2645  234f		       69 01		      ADC	#1
   2646  2351
   2647  2351		       85 cf		      STA	temp5
   2648  2353		       c9 29		      CMP	#40+1
   2649  2355		       90 e3		      bcc	.L0110fortemp5
   2650  2357				  -	      if	( (((((#>*)&$1f)*256)|(#<.L0110fortemp5))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.L0110fortemp5))<=(bankswitch_hotspot+bs_mask)) )
   2651  2357				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   2652  2357					      endif
   2653  2357				   .L0115		;  var1  =  0	:  var2  =  0
   2654  2357
   2655  2357		       a9 00		      LDA	#0
   2656  2359		       85 ed		      STA	var1
   2657  235b		       85 ee		      STA	var2
   2658  235d				   .
   2659  235d							; 
   2660  235d
   2661  235d				   .L0116		;  player1:
   2662  235d
   2663  235d		       a9 e2		      lda	#<(playerpointers+0)
   2664  235f		       8d 50 10 	      sta	DF0LOW
   2665  2362		       a9 01		      lda	#(>(playerpointers+0)) & $0F
   2666  2364		       8d 68 10 	      sta	DF0HI
   2667  2367		       a2 3e		      LDX	#<playerL0116_1
   2668  2369		       8e 78 10 	      STX	DF0WRITE
   2669  236c		       a9 62		      LDA	#((>playerL0116_1) & $0f) | (((>playerL0116_1) / 2) & $70)
   2670  236e		       8d 78 10 	      STA	DF0WRITE
   2671  2371		       a9 05		      LDA	#5
   2672  2373		       85 a6		      STA	player1height
   2673  2375				   .L0117		;  player1color:
   2674  2375
   2675  2375		       a9 f4		      lda	#<(playerpointers+18)
   2676  2377		       8d 50 10 	      sta	DF0LOW
   2677  237a		       a9 01		      lda	#(>(playerpointers+18)) & $0F
   2678  237c		       8d 68 10 	      sta	DF0HI
   2679  237f		       a2 43		      LDX	#<playercolorL0117_1
   2680  2381		       8e 78 10 	      STX	DF0WRITE
   2681  2384		       a9 62		      LDA	#((>playercolorL0117_1) & $0f) | (((>playercolorL0117_1) / 2) & $70)
   2682  2386		       8d 78 10 	      STA	DF0WRITE
   2683  2389				   .L0118		;  player1y  =  135
   2684  2389
   2685  2389		       a9 87		      LDA	#135
   2686  238b		       85 9a		      STA	player1y
   2687  238d				   .L0119		;  player1x  =  100
   2688  238d
   2689  238d		       a9 64		      LDA	#100
   2690  238f		       85 90		      STA	player1x
   2691  2391				   .introLoop
   2692  2391							; introLoop
   2693  2391
   2694  2391				   .
   2695  2391							; 
   2696  2391
   2697  2391				   .L0120		;  var1  =  var1  +  1
   2698  2391
   2699  2391		       e6 ed		      INC	var1
   2700  2393				   .L0121		;  if var1  =	8 then var1  =	0  :  var2  =  var2  +	1
   2701  2393
   2702  2393		       a5 ed		      LDA	var1
   2703  2395		       c9 08		      CMP	#8
   2704  2397		       d0 06		      BNE	.skipL0121
   2705  2399				   .condpart4
   2706  2399		       a9 00		      LDA	#0
   2707  239b		       85 ed		      STA	var1
   2708  239d		       e6 ee		      INC	var2
   2709  239f				   .skipL0121
   2710  239f				   .
   2711  239f							; 
   2712  239f
   2713  239f				   .L0122		;  ballheight	=  4
   2714  239f
   2715  239f		       a9 04		      LDA	#4
   2716  23a1		       85 c4		      STA	ballheight
   2717  23a3				   .L0123		;  bally  =  starY[var2]
   2718  23a3
   2719  23a3		       a6 ee		      LDX	var2
   2720  23a5		       bd 73 39 	      LDA	starY,x
   2721  23a8		       85 c1		      STA	bally
   2722  23aa				   .L0124		;  ballx  =  starX[var2]
   2723  23aa
   2724  23aa		       a6 ee		      LDX	var2
   2725  23ac		       bd 6c 39 	      LDA	starX,x
   2726  23af		       85 84		      STA	ballx
   2727  23b1				   .L0125		;  CTRLPF  =  $01
   2728  23b1
   2729  23b1		       a9 01		      LDA	#$01
   2730  23b3		       85 0a		      STA	CTRLPF
   2731  23b5				   .
   2732  23b5							; 
   2733  23b5
   2734  23b5				   .
   2735  23b5							; 
   2736  23b5
   2737  23b5				   .
   2738  23b5							; 
   2739  23b5
   2740  23b5				   .
   2741  23b5							; 
   2742  23b5
   2743  23b5				   .
   2744  23b5							; 
   2745  23b5
   2746  23b5				   .
   2747  23b5							; 
   2748  23b5
   2749  23b5				   .
   2750  23b5							; 
   2751  23b5
   2752  23b5				   .
   2753  23b5							; 
   2754  23b5
   2755  23b5				   .
   2756  23b5							; 
   2757  23b5
   2758  23b5				   .L0126		;  temp5  =  starColor[var1]
   2759  23b5
   2760  23b5		       a6 ed		      LDX	var1
   2761  23b7		       bd 7a 39 	      LDA	starColor,x
   2762  23ba		       85 cf		      STA	temp5
   2763  23bc				   .L0127		;  DF0LOW  =  PFCOLSLOW  +  34
   2764  23bc
   2765  23bc		       a9 08		      LDA	#PFCOLSLOW
   2766  23be		       18		      CLC
   2767  23bf		       69 22		      ADC	#34
   2768  23c1		       8d 50 10 	      STA	DF0LOW
   2769  23c4				   .L0128		;  DF0HI  =  PFCOLSHI
   2770  23c4
   2771  23c4		       a9 0a		      LDA	#PFCOLSHI
   2772  23c6		       8d 68 10 	      STA	DF0HI
   2773  23c9				   .L0129		;  DF0PUSH  =	temp5
   2774  23c9
   2775  23c9		       a5 cf		      LDA	temp5
   2776  23cb		       8d 60 10 	      STA	DF0PUSH
   2777  23ce				   .L0130		;  DF0PUSH  =	temp5
   2778  23ce
   2779  23ce		       a5 cf		      LDA	temp5
   2780  23d0		       8d 60 10 	      STA	DF0PUSH
   2781  23d3				   .L0131		;  DF0PUSH  =	temp5
   2782  23d3
   2783  23d3		       a5 cf		      LDA	temp5
   2784  23d5		       8d 60 10 	      STA	DF0PUSH
   2785  23d8				   .L0132		;  DF0PUSH  =	temp5
   2786  23d8
   2787  23d8		       a5 cf		      LDA	temp5
   2788  23da		       8d 60 10 	      STA	DF0PUSH
   2789  23dd				   .
   2790  23dd							; 
   2791  23dd
   2792  23dd				   .L0133		;  gosub reUsed
   2793  23dd
   2794  23dd		       20 d5 39 	      jsr	.reUsed
   2795  23e0
   2796  23e0				   .
   2797  23e0							; 
   2798  23e0
   2799  23e0				   .
   2800  23e0							; 
   2801  23e0
   2802  23e0				   .
   2803  23e0							; 
   2804  23e0
   2805  23e0				   .L0134		;  if var2  <>  4 then goto introLoop
   2806  23e0
   2807  23e0		       a5 ee		      LDA	var2
   2808  23e2		       c9 04		      CMP	#4
   2809  23e4		       f0 03		      BEQ	.skipL0134
   2810  23e6				   .condpart5
   2811  23e6		       4c 91 33 	      jmp	.introLoop
   2812  23e9
   2813  23e9				   .skipL0134
   2814  23e9				   .
   2815  23e9							; 
   2816  23e9
   2817  23e9				   .
   2818  23e9							; 
   2819  23e9
   2820  23e9				   .L0135		;  ballheight	=  6
   2821  23e9
   2822  23e9		       a9 06		      LDA	#6
   2823  23eb		       85 c4		      STA	ballheight
   2824  23ed				   .
   2825  23ed							; 
   2826  23ed
   2827  23ed				   .L0136		;  ballx  =  80
   2828  23ed
   2829  23ed		       a9 50		      LDA	#80
   2830  23ef		       85 84		      STA	ballx
   2831  23f1				   .L0137		;  CTRLPF  =  $31
   2832  23f1
   2833  23f1		       a9 31		      LDA	#$31
   2834  23f3		       85 0a		      STA	CTRLPF
   2835  23f5				   .
   2836  23f5							; 
   2837  23f5
   2838  23f5				   .
   2839  23f5							; 
   2840  23f5
   2841  23f5				   .L0138		;  COLUM1  =  $0e
   2842  23f5
   2843  23f5		       a9 0e		      LDA	#$0e
   2844  23f7		       85 bc		      STA	COLUM1
   2845  23f9				   ._main
   2846  23f9							; _main
   2847  23f9
   2848  23f9				   .
   2849  23f9							; 
   2850  23f9
   2851  23f9				   .
   2852  23f9							; 
   2853  23f9
   2854  23f9				   .L0139		;  if joy0right  &&  !leftBit then rightBit  =  1
   2855  23f9
   2856  23f9		       2c 80 02 	      bit	SWCHA
   2857  23fc		       30 0c		      BMI	.skipL0139
   2858  23fe				   .condpart6
   2859  23fe		       a5 ec		      LDA	var0
   2860  2400		       29 02		      AND	#2
   2861  2402		       d0 06		      BNE	.skip6then
   2862  2404				   .condpart7
   2863  2404		       a5 ec		      LDA	var0
   2864  2406		       09 01		      ORA	#1
   2865  2408		       85 ec		      STA	var0
   2866  240a				   .skip6then
   2867  240a				   .skipL0139
   2868  240a				   .L0140		;  if joy0left  &&  !rightBit then leftBit  =	1
   2869  240a
   2870  240a		       2c 80 02 	      bit	SWCHA
   2871  240d		       70 0b		      BVS	.skipL0140
   2872  240f				   .condpart8
   2873  240f		       a5 ec		      LDA	var0
   2874  2411		       4a		      LSR
   2875  2412		       b0 06		      BCS	.skip8then
   2876  2414				   .condpart9
   2877  2414		       a5 ec		      LDA	var0
   2878  2416		       09 02		      ORA	#2
   2879  2418		       85 ec		      STA	var0
   2880  241a				   .skip8then
   2881  241a				   .skipL0140
   2882  241a				   .
   2883  241a							; 
   2884  241a
   2885  241a				   .L0141		;  if joy0fire then rightBit  =  0  :	leftBit  =  0
   2886  241a
   2887  241a		       24 0c		      bit	INPT4
   2888  241c		       30 0c		      BMI	.skipL0141
   2889  241e				   .condpart10
   2890  241e		       a5 ec		      LDA	var0
   2891  2420		       29 fe		      AND	#254
   2892  2422		       85 ec		      STA	var0
   2893  2424		       a5 ec		      LDA	var0
   2894  2426		       29 fd		      AND	#253
   2895  2428		       85 ec		      STA	var0
   2896  242a				   .skipL0141
   2897  242a				   .
   2898  242a							; 
   2899  242a
   2900  242a				   .L0142		;  if !rightBit then skipRight
   2901  242a
   2902  242a		       a5 ec		      LDA	var0
   2903  242c		       4a		      LSR
   2904  242d		       90 1d		      bcc	.skipRight
   2905  242f				  -	      if	( (((((#>*)&$1f)*256)|(#<.skipRight))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.skipRight))<=(bankswitch_hotspot+bs_mask)) )
   2906  242f				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   2907  242f					      endif
   2908  242f				   .L0143		;  m1x  =  m1x  +  1.5
   2909  242f
   2910  242f		       a5 d6		      LDA	f
   2911  2431		       18		      CLC
   2912  2432		       69 80		      ADC	#128
   2913  2434		       85 d6		      STA	f
   2914  2436		       a5 83		      LDA	m1x
   2915  2438		       69 01		      ADC	#1
   2916  243a		       85 83		      STA	m1x
   2917  243c				   .L0144		;  if missile1x  >=  158 then rightBit  =  0  :  missile1x  =	158
   2918  243c
   2919  243c		       a5 83		      LDA	missile1x
   2920  243e		       c9 9e		      CMP	#158
   2921  2440		       90 0a		      BCC	.skipL0144
   2922  2442				   .condpart11
   2923  2442		       a5 ec		      LDA	var0
   2924  2444		       29 fe		      AND	#254
   2925  2446		       85 ec		      STA	var0
   2926  2448		       a9 9e		      LDA	#158
   2927  244a		       85 83		      STA	missile1x
   2928  244c				   .skipL0144
   2929  244c				   .skipRight
   2930  244c							; skipRight
   2931  244c
   2932  244c				   .
   2933  244c							; 
   2934  244c
   2935  244c				   .L0145		;  if !leftBit then skipLeft
   2936  244c
   2937  244c		       a5 ec		      LDA	var0
   2938  244e		       29 02		      AND	#2
   2939  2450		       f0 1d		      beq	.skipLeft
   2940  2452				  -	      if	( (((((#>*)&$1f)*256)|(#<.skipLeft))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.skipLeft))<=(bankswitch_hotspot+bs_mask)) )
   2941  2452				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   2942  2452					      endif
   2943  2452				   .L0146		;  m1x  =  m1x  -  1.5
   2944  2452
   2945  2452		       a5 d6		      LDA	f
   2946  2454		       38		      SEC
   2947  2455		       e9 80		      SBC	#128
   2948  2457		       85 d6		      STA	f
   2949  2459		       a5 83		      LDA	m1x
   2950  245b		       e9 01		      SBC	#1
   2951  245d		       85 83		      STA	m1x
   2952  245f				   .L0147		;  if missile1x  <=  2 then leftBit  =  0  :  missile1x  =  2
   2953  245f
   2954  245f		       a9 02		      LDA	#2
   2955  2461		       c5 83		      CMP	missile1x
   2956  2463		       90 0a		      BCC	.skipL0147
   2957  2465				   .condpart12
   2958  2465		       a5 ec		      LDA	var0
   2959  2467		       29 fd		      AND	#253
   2960  2469		       85 ec		      STA	var0
   2961  246b		       a9 02		      LDA	#2
   2962  246d		       85 83		      STA	missile1x
   2963  246f				   .skipL0147
   2964  246f				   .skipLeft
   2965  246f							; skipLeft
   2966  246f
   2967  246f				   .
   2968  246f							; 
   2969  246f
   2970  246f				   .
   2971  246f							; 
   2972  246f
   2973  246f				   .
   2974  246f							; 
   2975  246f
   2976  246f				   .
   2977  246f							; 
   2978  246f
   2979  246f				   .
   2980  246f							; 
   2981  246f
   2982  246f				   .
   2983  246f							; 
   2984  246f
   2985  246f				   .
   2986  246f							; 
   2987  246f
   2988  246f				   .
   2989  246f							; 
   2990  246f
   2991  246f				   .L0148		;  timer  =  timer  +	1
   2992  246f
   2993  246f		       e6 dd		      INC	timer
   2994  2471				   .L0149		;  if timer  <>  timerLength then goto skipNewLine
   2995  2471
   2996  2471		       a5 dd		      LDA	timer
   2997  2473		       c5 d5		      CMP	timerLength
   2998  2475		       f0 03		      BEQ	.skipL0149
   2999  2477				   .condpart13
   3000  2477		       4c dc 34 	      jmp	.skipNewLine
   3001  247a
   3002  247a				   .skipL0149
   3003  247a				   .L0150		;  timer  =  0
   3004  247a
   3005  247a		       a9 00		      LDA	#0
   3006  247c		       85 dd		      STA	timer
   3007  247e				   .
   3008  247e							; 
   3009  247e
   3010  247e				   .L0151		;  for var5  =  0 to 3 step 1
   3011  247e
   3012  247e		       a9 00		      LDA	#0
   3013  2480		       85 f1		      STA	var5
   3014  2482				   .L0151forvar5
   3015  2482				   .
   3016  2482							; 
   3017  2482
   3018  2482				   .
   3019  2482							; 
   3020  2482
   3021  2482				   .L0152		;  if linePosArray[var5]  <>  0 then notFreeNext
   3022  2482
   3023  2482		       a6 f1		      LDX	var5
   3024  2484		       b5 d1		      LDA	linePosArray,x
   3025  2486		       c9 00		      CMP	#0
   3026  2488		       d0 15		      bne	.notFreeNext
   3027  248a				  -	      if	( (((((#>*)&$1f)*256)|(#<.notFreeNext))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.notFreeNext))<=(bankswitch_hotspot+bs_mask)) )
   3028  248a				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   3029  248a					      endif
   3030  248a				   .L0153		;  linePosArray[var5]	=  45  :  hole1x[var5]	=  nextRand  :	temp5  =  hole1x[var5]	:  goto found
   3031  248a
   3032  248a		       a9 2d		      LDA	#45
   3033  248c		       a6 f1		      LDX	var5
   3034  248e		       95 d1		      STA	linePosArray,x
   3035  2490		       a5 de		      LDA	nextRand
   3036  2492		       a6 f1		      LDX	var5
   3037  2494		       95 ed		      STA	hole1x,x
   3038  2496		       a6 f1		      LDX	var5
   3039  2498		       b5 ed		      LDA	hole1x,x
   3040  249a		       85 cf		      STA	temp5
   3041  249c		       4c ad 34 	      jmp	.found
   3042  249f
   3043  249f				   .notFreeNext
   3044  249f							; notFreeNext
   3045  249f
   3046  249f				   .L0154		;  next
   3047  249f
   3048  249f		       a5 f1		      LDA	var5
   3049  24a1		       18		      CLC
   3050  24a2		       69 01		      ADC	#1
   3051  24a4
   3052  24a4		       85 f1		      STA	var5
   3053  24a6		       c9 04		      CMP	#3+1
   3054  24a8		       90 d8		      bcc	.L0151forvar5
   3055  24aa				  -	      if	( (((((#>*)&$1f)*256)|(#<.L0151forvar5))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.L0151forvar5))<=(bankswitch_hotspot+bs_mask)) )
   3056  24aa				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   3057  24aa					      endif
   3058  24aa				   .L0155		;  goto skipNewLine
   3059  24aa
   3060  24aa		       4c dc 34 	      jmp	.skipNewLine
   3061  24ad
   3062  24ad				   .found
   3063  24ad							; found
   3064  24ad
   3065  24ad				   .
   3066  24ad							; 
   3067  24ad
   3068  24ad				   .L0156		;  nextRand  =   ( rand & 31 ) 
   3069  24ad
   3070  24ad							; complex statement detected
   3071  24ad		       ad 00 10 	      lda	rand
   3072  24b0		       29 1f		      AND	#31
   3073  24b2		       85 de		      STA	nextRand
   3074  24b4				   .
   3075  24b4							; 
   3076  24b4
   3077  24b4				   .
   3078  24b4							; 
   3079  24b4
   3080  24b4				   .
   3081  24b4							; 
   3082  24b4
   3083  24b4				   .
   3084  24b4							; 
   3085  24b4
   3086  24b4				   .L0157		;  if temp5  <=  nextRand then temp2  =   ( nextRand  -  temp5 )   :  timerLength  =  timerLengthTable[temp2]
   3087  24b4
   3088  24b4		       a5 de		      LDA	nextRand
   3089  24b6		       c5 cf		      CMP	temp5
   3090  24b8		       90 0e		      BCC	.skipL0157
   3091  24ba				   .condpart14
   3092  24ba							; complex statement detected
   3093  24ba		       a5 de		      LDA	nextRand
   3094  24bc		       38		      SEC
   3095  24bd		       e5 cf		      SBC	temp5
   3096  24bf		       85 cc		      STA	temp2
   3097  24c1		       a6 cc		      LDX	temp2
   3098  24c3		       bd 86 39 	      LDA	timerLengthTable,x
   3099  24c6		       85 d5		      STA	timerLength
   3100  24c8				   .skipL0157
   3101  24c8				   .L0158		;  if nextRand  <  temp5 then temp2  =   ( temp5  -  nextRand )   :  timerLength  =  timerLengthTable[temp2]
   3102  24c8
   3103  24c8		       a5 de		      LDA	nextRand
   3104  24ca		       c5 cf		      CMP	temp5
   3105  24cc		       b0 0e		      BCS	.skipL0158
   3106  24ce				   .condpart15
   3107  24ce							; complex statement detected
   3108  24ce		       a5 cf		      LDA	temp5
   3109  24d0		       38		      SEC
   3110  24d1		       e5 de		      SBC	nextRand
   3111  24d3		       85 cc		      STA	temp2
   3112  24d5		       a6 cc		      LDX	temp2
   3113  24d7		       bd 86 39 	      LDA	timerLengthTable,x
   3114  24da		       85 d5		      STA	timerLength
   3115  24dc				   .skipL0158
   3116  24dc				   .skipNewLine
   3117  24dc							; skipNewLine
   3118  24dc
   3119  24dc				   .
   3120  24dc							; 
   3121  24dc
   3122  24dc				   .
   3123  24dc							; 
   3124  24dc
   3125  24dc				   .
   3126  24dc							; 
   3127  24dc
   3128  24dc				   .
   3129  24dc							; 
   3130  24dc
   3131  24dc				   .
   3132  24dc							; 
   3133  24dc
   3134  24dc				   .
   3135  24dc							; 
   3136  24dc
   3137  24dc				   .L0159		;  if linePos1  =  0 then goto skipLine1
   3138  24dc
   3139  24dc		       a5 d1		      LDA	linePos1
   3140  24de		       c9 00		      CMP	#0
   3141  24e0		       d0 03		      BNE	.skipL0159
   3142  24e2				   .condpart16
   3143  24e2		       4c d3 35 	      jmp	.skipLine1
   3144  24e5
   3145  24e5				   .skipL0159
   3146  24e5				   .L0160		;  DF0LOW  =  BKCOLSLOW  +  linePos1
   3147  24e5
   3148  24e5		       a9 a5		      LDA	#BKCOLSLOW
   3149  24e7		       18		      CLC
   3150  24e8		       65 d1		      ADC	linePos1
   3151  24ea		       8d 50 10 	      STA	DF0LOW
   3152  24ed				   .L0161		;  DF0HI  =  BKCOLSHI
   3153  24ed
   3154  24ed		       a9 0b		      LDA	#BKCOLSHI
   3155  24ef		       8d 68 10 	      STA	DF0HI
   3156  24f2				   .L0162		;  DF0PUSH  =	$00
   3157  24f2
   3158  24f2		       a9 00		      LDA	#$00
   3159  24f4		       8d 60 10 	      STA	DF0PUSH
   3160  24f7				   .L0163		;  if linePos1  >  67 then DF0PUSH  =	$00
   3161  24f7
   3162  24f7		       a9 43		      LDA	#67
   3163  24f9		       c5 d1		      CMP	linePos1
   3164  24fb		       b0 05		      BCS	.skipL0163
   3165  24fd				   .condpart17
   3166  24fd		       a9 00		      LDA	#$00
   3167  24ff		       8d 60 10 	      STA	DF0PUSH
   3168  2502				   .skipL0163
   3169  2502				   .L0164		;  pfpixel hole1x linePos1 off
   3170  2502
   3171  2502		       a9 a4		      lda	#<C_function
   3172  2504		       8d 50 10 	      sta	DF0LOW
   3173  2507		       a9 01		      lda	#(>C_function) & $0F
   3174  2509		       8d 68 10 	      sta	DF0HI
   3175  250c		       a2 0d		      LDX	#13
   3176  250e		       8e 78 10 	      STX	DF0WRITE
   3177  2511		       8e 78 10 	      STX	DF0WRITE
   3178  2514		       a4 d1		      LDY	linePos1
   3179  2516		       8c 78 10 	      STY	DF0WRITE
   3180  2519		       a5 ed		      LDA	hole1x
   3181  251b		       8d 78 10 	      STA	DF0WRITE
   3182  251e		       a9 ff		      lda	#255
   3183  2520		       8d 5a 10 	      sta	CALLFUNCTION
   3184  2523				   .
   3185  2523							; 
   3186  2523
   3187  2523				   .L0165		;  linePos1  =  linePos1  +  speedup1
   3188  2523
   3189  2523		       a5 d7		      LDA	g
   3190  2525		       18		      CLC
   3191  2526		       65 e5		      ADC	u
   3192  2528		       85 d7		      STA	g
   3193  252a		       a5 d1		      LDA	linePos1
   3194  252c		       65 df		      ADC	speedup1
   3195  252e		       85 d1		      STA	linePos1
   3196  2530				   .L0166		;  speedup1  =  speedup1  +  0.00390625
   3197  2530
   3198  2530		       a5 e5		      LDA	u
   3199  2532		       18		      CLC
   3200  2533		       69 01		      ADC	#1
   3201  2535		       85 e5		      STA	u
   3202  2537		       a5 df		      LDA	speedup1
   3203  2539		       69 00		      ADC	#0
   3204  253b		       85 df		      STA	speedup1
   3205  253d				   .L0167		;  if linePos1  >=  87 then linePos1  =  0.0  :  speedup1  =  0.0  :  bally  =  0
   3206  253d
   3207  253d		       a5 d1		      LDA	linePos1
   3208  253f		       c9 57		      CMP	#87
   3209  2541		       90 14		      BCC	.skipL0167
   3210  2543				   .condpart18
   3211  2543		       a2 00		      LDX	#0
   3212  2545		       86 d7		      STX	g
   3213  2547		       a9 00		      LDA	#0
   3214  2549		       85 d1		      STA	linePos1
   3215  254b		       a2 00		      LDX	#0
   3216  254d		       86 e5		      STX	u
   3217  254f		       a9 00		      LDA	#0
   3218  2551		       85 df		      STA	speedup1
   3219  2553		       a9 00		      LDA	#0
   3220  2555		       85 c1		      STA	bally
   3221  2557				   .skipL0167
   3222  2557				   .
   3223  2557							; 
   3224  2557
   3225  2557				   .L0168		;  if linePos1  >  54	&&  linePos1  <=  67 then player1y  =	( linePos1  -  1 )   *	2  :  player1x	=   ( hole1x  *  4 )   +  13 else pfpixel hole1x linePos1 on
   3226  2557
   3227  2557		       a9 36		      LDA	#54
   3228  2559		       c5 d1		      CMP	linePos1
   3229  255b		       b0 1a		      BCS	.skipL0168
   3230  255d				   .condpart19
   3231  255d		       a9 43		      LDA	#67
   3232  255f		       c5 d1		      CMP	linePos1
   3233  2561		       90 14		      BCC	.skip19then
   3234  2563				   .condpart20
   3235  2563							; complex statement detected
   3236  2563		       a5 d1		      LDA	linePos1
   3237  2565		       38		      SEC
   3238  2566		       e9 01		      SBC	#1
   3239  2568		       0a		      asl
   3240  2569		       85 9a		      STA	player1y
   3241  256b							; complex statement detected
   3242  256b		       a5 ed		      LDA	hole1x
   3243  256d		       0a		      asl
   3244  256e		       0a		      asl
   3245  256f		       18		      CLC
   3246  2570		       69 0d		      ADC	#13
   3247  2572		       85 90		      STA	player1x
   3248  2574		       4c 98 35 	      jmp	.skipelse0
   3249  2577				   .skip19then
   3250  2577				   .skipL0168
   3251  2577		       a9 a4		      lda	#<C_function
   3252  2579		       8d 50 10 	      sta	DF0LOW
   3253  257c		       a9 01		      lda	#(>C_function) & $0F
   3254  257e		       8d 68 10 	      sta	DF0HI
   3255  2581		       a2 0c		      LDX	#12
   3256  2583		       8e 78 10 	      STX	DF0WRITE
   3257  2586		       8e 78 10 	      STX	DF0WRITE
   3258  2589		       a4 d1		      LDY	linePos1
   3259  258b		       8c 78 10 	      STY	DF0WRITE
   3260  258e		       a5 ed		      LDA	hole1x
   3261  2590		       8d 78 10 	      STA	DF0WRITE
   3262  2593		       a9 ff		      lda	#255
   3263  2595		       8d 5a 10 	      sta	CALLFUNCTION
   3264  2598				   .skipelse0
   3265  2598				   .
   3266  2598							; 
   3267  2598
   3268  2598				   .
   3269  2598							; 
   3270  2598
   3271  2598				   .L0169		;  DF0LOW  =  BKCOLSLOW  +  linePos1
   3272  2598
   3273  2598		       a9 a5		      LDA	#BKCOLSLOW
   3274  259a		       18		      CLC
   3275  259b		       65 d1		      ADC	linePos1
   3276  259d		       8d 50 10 	      STA	DF0LOW
   3277  25a0				   .L0170		;  DF0HI  =  BKCOLSHI
   3278  25a0
   3279  25a0		       a9 0b		      LDA	#BKCOLSHI
   3280  25a2		       8d 68 10 	      STA	DF0HI
   3281  25a5				   .L0171		;  temp5  =  linePos1	-  44
   3282  25a5
   3283  25a5		       a5 d1		      LDA	linePos1
   3284  25a7		       38		      SEC
   3285  25a8		       e9 2c		      SBC	#44
   3286  25aa		       85 cf		      STA	temp5
   3287  25ac				   .L0172		;  DF0PUSH  =	_color[temp5]
   3288  25ac
   3289  25ac		       a6 cf		      LDX	temp5
   3290  25ae		       bd a9 39 	      LDA	_color,x
   3291  25b1		       8d 60 10 	      STA	DF0PUSH
   3292  25b4				   .L0173		;  if linePos1  >  67 then DF0PUSH  =	_color[temp5]  :  ballx  =   ( hole1x  *  4 )	+  15  :  bally  =   ( linePos1  -  2 )   *  2
   3293  25b4
   3294  25b4		       a9 43		      LDA	#67
   3295  25b6		       c5 d1		      CMP	linePos1
   3296  25b8		       b0 19		      BCS	.skipL0173
   3297  25ba				   .condpart21
   3298  25ba		       a6 cf		      LDX	temp5
   3299  25bc		       bd a9 39 	      LDA	_color,x
   3300  25bf		       8d 60 10 	      STA	DF0PUSH
   3301  25c2							; complex statement detected
   3302  25c2		       a5 ed		      LDA	hole1x
   3303  25c4		       0a		      asl
   3304  25c5		       0a		      asl
   3305  25c6		       18		      CLC
   3306  25c7		       69 0f		      ADC	#15
   3307  25c9		       85 84		      STA	ballx
   3308  25cb							; complex statement detected
   3309  25cb		       a5 d1		      LDA	linePos1
   3310  25cd		       38		      SEC
   3311  25ce		       e9 02		      SBC	#2
   3312  25d0		       0a		      asl
   3313  25d1		       85 c1		      STA	bally
   3314  25d3				   .skipL0173
   3315  25d3				   .
   3316  25d3							; 
   3317  25d3
   3318  25d3				   .skipLine1
   3319  25d3							; skipLine1
   3320  25d3
   3321  25d3				   .
   3322  25d3							; 
   3323  25d3
   3324  25d3				   .
   3325  25d3							; 
   3326  25d3
   3327  25d3				   .
   3328  25d3							; 
   3329  25d3
   3330  25d3				   .
   3331  25d3							; 
   3332  25d3
   3333  25d3				   .L0174		;  if linePos2  =  0 then goto skipLine2
   3334  25d3
   3335  25d3		       a5 d2		      LDA	linePos2
   3336  25d5		       c9 00		      CMP	#0
   3337  25d7		       d0 03		      BNE	.skipL0174
   3338  25d9				   .condpart22
   3339  25d9		       4c ca 36 	      jmp	.skipLine2
   3340  25dc
   3341  25dc				   .skipL0174
   3342  25dc				   .L0175		;  DF0LOW  =  BKCOLSLOW  +  linePos2
   3343  25dc
   3344  25dc		       a9 a5		      LDA	#BKCOLSLOW
   3345  25de		       18		      CLC
   3346  25df		       65 d2		      ADC	linePos2
   3347  25e1		       8d 50 10 	      STA	DF0LOW
   3348  25e4				   .L0176		;  DF0HI  =  BKCOLSHI
   3349  25e4
   3350  25e4		       a9 0b		      LDA	#BKCOLSHI
   3351  25e6		       8d 68 10 	      STA	DF0HI
   3352  25e9				   .L0177		;  DF0PUSH  =	$00
   3353  25e9
   3354  25e9		       a9 00		      LDA	#$00
   3355  25eb		       8d 60 10 	      STA	DF0PUSH
   3356  25ee				   .L0178		;  if linePos2  >  67 then DF0PUSH  =	$00
   3357  25ee
   3358  25ee		       a9 43		      LDA	#67
   3359  25f0		       c5 d2		      CMP	linePos2
   3360  25f2		       b0 05		      BCS	.skipL0178
   3361  25f4				   .condpart23
   3362  25f4		       a9 00		      LDA	#$00
   3363  25f6		       8d 60 10 	      STA	DF0PUSH
   3364  25f9				   .skipL0178
   3365  25f9				   .L0179		;  pfpixel hole2x linePos2 off
   3366  25f9
   3367  25f9		       a9 a4		      lda	#<C_function
   3368  25fb		       8d 50 10 	      sta	DF0LOW
   3369  25fe		       a9 01		      lda	#(>C_function) & $0F
   3370  2600		       8d 68 10 	      sta	DF0HI
   3371  2603		       a2 0d		      LDX	#13
   3372  2605		       8e 78 10 	      STX	DF0WRITE
   3373  2608		       8e 78 10 	      STX	DF0WRITE
   3374  260b		       a4 d2		      LDY	linePos2
   3375  260d		       8c 78 10 	      STY	DF0WRITE
   3376  2610		       a5 ee		      LDA	hole2x
   3377  2612		       8d 78 10 	      STA	DF0WRITE
   3378  2615		       a9 ff		      lda	#255
   3379  2617		       8d 5a 10 	      sta	CALLFUNCTION
   3380  261a				   .
   3381  261a							; 
   3382  261a
   3383  261a				   .L0180		;  linePos2  =  linePos2  +  speedup2
   3384  261a
   3385  261a		       a5 d8		      LDA	h
   3386  261c		       18		      CLC
   3387  261d		       65 e6		      ADC	v
   3388  261f		       85 d8		      STA	h
   3389  2621		       a5 d2		      LDA	linePos2
   3390  2623		       65 e0		      ADC	speedup2
   3391  2625		       85 d2		      STA	linePos2
   3392  2627				   .L0181		;  speedup2  =  speedup2  +  0.00390625
   3393  2627
   3394  2627		       a5 e6		      LDA	v
   3395  2629		       18		      CLC
   3396  262a		       69 01		      ADC	#1
   3397  262c		       85 e6		      STA	v
   3398  262e		       a5 e0		      LDA	speedup2
   3399  2630		       69 00		      ADC	#0
   3400  2632		       85 e0		      STA	speedup2
   3401  2634				   .L0182		;  if linePos2  >=  87 then linePos2  =  0.0  :  speedup2  =  0.0  :  bally  =  0
   3402  2634
   3403  2634		       a5 d2		      LDA	linePos2
   3404  2636		       c9 57		      CMP	#87
   3405  2638		       90 14		      BCC	.skipL0182
   3406  263a				   .condpart24
   3407  263a		       a2 00		      LDX	#0
   3408  263c		       86 d8		      STX	h
   3409  263e		       a9 00		      LDA	#0
   3410  2640		       85 d2		      STA	linePos2
   3411  2642		       a2 00		      LDX	#0
   3412  2644		       86 e6		      STX	v
   3413  2646		       a9 00		      LDA	#0
   3414  2648		       85 e0		      STA	speedup2
   3415  264a		       a9 00		      LDA	#0
   3416  264c		       85 c1		      STA	bally
   3417  264e				   .skipL0182
   3418  264e				   .
   3419  264e							; 
   3420  264e
   3421  264e				   .L0183		;  if linePos2  >  54	&&  linePos2  <=  67 then player1y  =	( linePos2  -  1 )   *	2  :  player1x	=   ( hole2x  *  4 )   +  13 else pfpixel hole2x linePos2 on
   3422  264e
   3423  264e		       a9 36		      LDA	#54
   3424  2650		       c5 d2		      CMP	linePos2
   3425  2652		       b0 1a		      BCS	.skipL0183
   3426  2654				   .condpart25
   3427  2654		       a9 43		      LDA	#67
   3428  2656		       c5 d2		      CMP	linePos2
   3429  2658		       90 14		      BCC	.skip25then
   3430  265a				   .condpart26
   3431  265a							; complex statement detected
   3432  265a		       a5 d2		      LDA	linePos2
   3433  265c		       38		      SEC
   3434  265d		       e9 01		      SBC	#1
   3435  265f		       0a		      asl
   3436  2660		       85 9a		      STA	player1y
   3437  2662							; complex statement detected
   3438  2662		       a5 ee		      LDA	hole2x
   3439  2664		       0a		      asl
   3440  2665		       0a		      asl
   3441  2666		       18		      CLC
   3442  2667		       69 0d		      ADC	#13
   3443  2669		       85 90		      STA	player1x
   3444  266b		       4c 8f 36 	      jmp	.skipelse1
   3445  266e				   .skip25then
   3446  266e				   .skipL0183
   3447  266e		       a9 a4		      lda	#<C_function
   3448  2670		       8d 50 10 	      sta	DF0LOW
   3449  2673		       a9 01		      lda	#(>C_function) & $0F
   3450  2675		       8d 68 10 	      sta	DF0HI
   3451  2678		       a2 0c		      LDX	#12
   3452  267a		       8e 78 10 	      STX	DF0WRITE
   3453  267d		       8e 78 10 	      STX	DF0WRITE
   3454  2680		       a4 d2		      LDY	linePos2
   3455  2682		       8c 78 10 	      STY	DF0WRITE
   3456  2685		       a5 ee		      LDA	hole2x
   3457  2687		       8d 78 10 	      STA	DF0WRITE
   3458  268a		       a9 ff		      lda	#255
   3459  268c		       8d 5a 10 	      sta	CALLFUNCTION
   3460  268f				   .skipelse1
   3461  268f				   .
   3462  268f							; 
   3463  268f
   3464  268f				   .L0184		;  DF0LOW  =  BKCOLSLOW  +  linePos2
   3465  268f
   3466  268f		       a9 a5		      LDA	#BKCOLSLOW
   3467  2691		       18		      CLC
   3468  2692		       65 d2		      ADC	linePos2
   3469  2694		       8d 50 10 	      STA	DF0LOW
   3470  2697				   .L0185		;  DF0HI  =  BKCOLSHI
   3471  2697
   3472  2697		       a9 0b		      LDA	#BKCOLSHI
   3473  2699		       8d 68 10 	      STA	DF0HI
   3474  269c				   .L0186		;  temp5  =  linePos2	-  44
   3475  269c
   3476  269c		       a5 d2		      LDA	linePos2
   3477  269e		       38		      SEC
   3478  269f		       e9 2c		      SBC	#44
   3479  26a1		       85 cf		      STA	temp5
   3480  26a3				   .L0187		;  DF0PUSH  =	_color[temp5]
   3481  26a3
   3482  26a3		       a6 cf		      LDX	temp5
   3483  26a5		       bd a9 39 	      LDA	_color,x
   3484  26a8		       8d 60 10 	      STA	DF0PUSH
   3485  26ab				   .L0188		;  if linePos2  >  67 then DF0PUSH  =	_color[temp5]  :  ballx  =   ( hole2x  *  4 )	+  15  :  bally  =   ( linePos2  -  2 )   *  2
   3486  26ab
   3487  26ab		       a9 43		      LDA	#67
   3488  26ad		       c5 d2		      CMP	linePos2
   3489  26af		       b0 19		      BCS	.skipL0188
   3490  26b1				   .condpart27
   3491  26b1		       a6 cf		      LDX	temp5
   3492  26b3		       bd a9 39 	      LDA	_color,x
   3493  26b6		       8d 60 10 	      STA	DF0PUSH
   3494  26b9							; complex statement detected
   3495  26b9		       a5 ee		      LDA	hole2x
   3496  26bb		       0a		      asl
   3497  26bc		       0a		      asl
   3498  26bd		       18		      CLC
   3499  26be		       69 0f		      ADC	#15
   3500  26c0		       85 84		      STA	ballx
   3501  26c2							; complex statement detected
   3502  26c2		       a5 d2		      LDA	linePos2
   3503  26c4		       38		      SEC
   3504  26c5		       e9 02		      SBC	#2
   3505  26c7		       0a		      asl
   3506  26c8		       85 c1		      STA	bally
   3507  26ca				   .skipL0188
   3508  26ca				   .
   3509  26ca							; 
   3510  26ca
   3511  26ca				   .skipLine2
   3512  26ca							; skipLine2
   3513  26ca
   3514  26ca				   .
   3515  26ca							; 
   3516  26ca
   3517  26ca				   .
   3518  26ca							; 
   3519  26ca
   3520  26ca				   .
   3521  26ca							; 
   3522  26ca
   3523  26ca				   .
   3524  26ca							; 
   3525  26ca
   3526  26ca				   .L0189		;  if linePos3  =  0 then goto skipLine3
   3527  26ca
   3528  26ca		       a5 d3		      LDA	linePos3
   3529  26cc		       c9 00		      CMP	#0
   3530  26ce		       d0 03		      BNE	.skipL0189
   3531  26d0				   .condpart28
   3532  26d0		       4c bd 37 	      jmp	.skipLine3
   3533  26d3
   3534  26d3				   .skipL0189
   3535  26d3				   .L0190		;  DF0LOW  =  BKCOLSLOW  +  linePos3
   3536  26d3
   3537  26d3		       a9 a5		      LDA	#BKCOLSLOW
   3538  26d5		       18		      CLC
   3539  26d6		       65 d3		      ADC	linePos3
   3540  26d8		       8d 50 10 	      STA	DF0LOW
   3541  26db				   .L0191		;  DF0HI  =  BKCOLSHI
   3542  26db
   3543  26db		       a9 0b		      LDA	#BKCOLSHI
   3544  26dd		       8d 68 10 	      STA	DF0HI
   3545  26e0				   .L0192		;  DF0PUSH  =	$00
   3546  26e0
   3547  26e0		       a9 00		      LDA	#$00
   3548  26e2		       8d 60 10 	      STA	DF0PUSH
   3549  26e5				   .L0193		;  if linePos3  >  67 then DF0PUSH  =	$00
   3550  26e5
   3551  26e5		       a9 43		      LDA	#67
   3552  26e7		       c5 d3		      CMP	linePos3
   3553  26e9		       b0 05		      BCS	.skipL0193
   3554  26eb				   .condpart29
   3555  26eb		       a9 00		      LDA	#$00
   3556  26ed		       8d 60 10 	      STA	DF0PUSH
   3557  26f0				   .skipL0193
   3558  26f0				   .L0194		;  pfpixel hole3x linePos3 off
   3559  26f0
   3560  26f0		       a9 a4		      lda	#<C_function
   3561  26f2		       8d 50 10 	      sta	DF0LOW
   3562  26f5		       a9 01		      lda	#(>C_function) & $0F
   3563  26f7		       8d 68 10 	      sta	DF0HI
   3564  26fa		       a2 0d		      LDX	#13
   3565  26fc		       8e 78 10 	      STX	DF0WRITE
   3566  26ff		       8e 78 10 	      STX	DF0WRITE
   3567  2702		       a4 d3		      LDY	linePos3
   3568  2704		       8c 78 10 	      STY	DF0WRITE
   3569  2707		       a5 ef		      LDA	hole3x
   3570  2709		       8d 78 10 	      STA	DF0WRITE
   3571  270c		       a9 ff		      lda	#255
   3572  270e		       8d 5a 10 	      sta	CALLFUNCTION
   3573  2711				   .
   3574  2711							; 
   3575  2711
   3576  2711				   .L0195		;  linePos3  =  linePos3  +  speedup3
   3577  2711
   3578  2711		       a5 d9		      LDA	i
   3579  2713		       18		      CLC
   3580  2714		       65 e7		      ADC	w
   3581  2716		       85 d9		      STA	i
   3582  2718		       a5 d3		      LDA	linePos3
   3583  271a		       65 e1		      ADC	speedup3
   3584  271c		       85 d3		      STA	linePos3
   3585  271e				   .L0196		;  speedup3  =  speedup3  +  0.00390625
   3586  271e
   3587  271e		       a5 e7		      LDA	w
   3588  2720		       18		      CLC
   3589  2721		       69 01		      ADC	#1
   3590  2723		       85 e7		      STA	w
   3591  2725		       a5 e1		      LDA	speedup3
   3592  2727		       69 00		      ADC	#0
   3593  2729		       85 e1		      STA	speedup3
   3594  272b				   .L0197		;  if linePos3  >=  87 then linePos3  =  0.0  :  speedup3  =  0.0
   3595  272b
   3596  272b		       a5 d3		      LDA	linePos3
   3597  272d		       c9 57		      CMP	#87
   3598  272f		       90 10		      BCC	.skipL0197
   3599  2731				   .condpart30
   3600  2731		       a2 00		      LDX	#0
   3601  2733		       86 d9		      STX	i
   3602  2735		       a9 00		      LDA	#0
   3603  2737		       85 d3		      STA	linePos3
   3604  2739		       a2 00		      LDX	#0
   3605  273b		       86 e7		      STX	w
   3606  273d		       a9 00		      LDA	#0
   3607  273f		       85 e1		      STA	speedup3
   3608  2741				   .skipL0197
   3609  2741				   .
   3610  2741							; 
   3611  2741
   3612  2741				   .L0198		;  if linePos3  >  54	&&  linePos3  <=  67 then player1y  =	( linePos3  -  1 )   *	2  :  player1x	=   ( hole3x  *  4 )   +  13 else pfpixel hole3x linePos3 on
   3613  2741
   3614  2741		       a9 36		      LDA	#54
   3615  2743		       c5 d3		      CMP	linePos3
   3616  2745		       b0 1a		      BCS	.skipL0198
   3617  2747				   .condpart31
   3618  2747		       a9 43		      LDA	#67
   3619  2749		       c5 d3		      CMP	linePos3
   3620  274b		       90 14		      BCC	.skip31then
   3621  274d				   .condpart32
   3622  274d							; complex statement detected
   3623  274d		       a5 d3		      LDA	linePos3
   3624  274f		       38		      SEC
   3625  2750		       e9 01		      SBC	#1
   3626  2752		       0a		      asl
   3627  2753		       85 9a		      STA	player1y
   3628  2755							; complex statement detected
   3629  2755		       a5 ef		      LDA	hole3x
   3630  2757		       0a		      asl
   3631  2758		       0a		      asl
   3632  2759		       18		      CLC
   3633  275a		       69 0d		      ADC	#13
   3634  275c		       85 90		      STA	player1x
   3635  275e		       4c 82 37 	      jmp	.skipelse2
   3636  2761				   .skip31then
   3637  2761				   .skipL0198
   3638  2761		       a9 a4		      lda	#<C_function
   3639  2763		       8d 50 10 	      sta	DF0LOW
   3640  2766		       a9 01		      lda	#(>C_function) & $0F
   3641  2768		       8d 68 10 	      sta	DF0HI
   3642  276b		       a2 0c		      LDX	#12
   3643  276d		       8e 78 10 	      STX	DF0WRITE
   3644  2770		       8e 78 10 	      STX	DF0WRITE
   3645  2773		       a4 d3		      LDY	linePos3
   3646  2775		       8c 78 10 	      STY	DF0WRITE
   3647  2778		       a5 ef		      LDA	hole3x
   3648  277a		       8d 78 10 	      STA	DF0WRITE
   3649  277d		       a9 ff		      lda	#255
   3650  277f		       8d 5a 10 	      sta	CALLFUNCTION
   3651  2782				   .skipelse2
   3652  2782				   .
   3653  2782							; 
   3654  2782
   3655  2782				   .L0199		;  DF0LOW  =  BKCOLSLOW  +  linePos3
   3656  2782
   3657  2782		       a9 a5		      LDA	#BKCOLSLOW
   3658  2784		       18		      CLC
   3659  2785		       65 d3		      ADC	linePos3
   3660  2787		       8d 50 10 	      STA	DF0LOW
   3661  278a				   .L0200		;  DF0HI  =  BKCOLSHI
   3662  278a
   3663  278a		       a9 0b		      LDA	#BKCOLSHI
   3664  278c		       8d 68 10 	      STA	DF0HI
   3665  278f				   .L0201		;  temp5  =  linePos3	-  44
   3666  278f
   3667  278f		       a5 d3		      LDA	linePos3
   3668  2791		       38		      SEC
   3669  2792		       e9 2c		      SBC	#44
   3670  2794		       85 cf		      STA	temp5
   3671  2796				   .L0202		;  DF0PUSH  =	_color[temp5]
   3672  2796
   3673  2796		       a6 cf		      LDX	temp5
   3674  2798		       bd a9 39 	      LDA	_color,x
   3675  279b		       8d 60 10 	      STA	DF0PUSH
   3676  279e				   .L0203		;  if linePos3  >  67 then DF0PUSH  =	_color[temp5] :  ballx	=   ( hole3x  *  4 )   +  15  :  bally	=   ( linePos3	-  2 )	 *  2
   3677  279e
   3678  279e		       a9 43		      LDA	#67
   3679  27a0		       c5 d3		      CMP	linePos3
   3680  27a2		       b0 19		      BCS	.skipL0203
   3681  27a4				   .condpart33
   3682  27a4		       a6 cf		      LDX	temp5
   3683  27a6		       bd a9 39 	      LDA	_color,x
   3684  27a9		       8d 60 10 	      STA	DF0PUSH
   3685  27ac							; complex statement detected
   3686  27ac		       a5 ef		      LDA	hole3x
   3687  27ae		       0a		      asl
   3688  27af		       0a		      asl
   3689  27b0		       18		      CLC
   3690  27b1		       69 0f		      ADC	#15
   3691  27b3		       85 84		      STA	ballx
   3692  27b5							; complex statement detected
   3693  27b5		       a5 d3		      LDA	linePos3
   3694  27b7		       38		      SEC
   3695  27b8		       e9 02		      SBC	#2
   3696  27ba		       0a		      asl
   3697  27bb		       85 c1		      STA	bally
   3698  27bd				   .skipL0203
   3699  27bd				   .
   3700  27bd							; 
   3701  27bd
   3702  27bd				   .skipLine3
   3703  27bd							; skipLine3
   3704  27bd
   3705  27bd				   .
   3706  27bd							; 
   3707  27bd
   3708  27bd				   .
   3709  27bd							; 
   3710  27bd
   3711  27bd				   .
   3712  27bd							; 
   3713  27bd
   3714  27bd				   .
   3715  27bd							; 
   3716  27bd
   3717  27bd				   .L0204		;  if linePos4  =  0 then goto skipLine4
   3718  27bd
   3719  27bd		       a5 d4		      LDA	linePos4
   3720  27bf		       c9 00		      CMP	#0
   3721  27c1		       d0 03		      BNE	.skipL0204
   3722  27c3				   .condpart34
   3723  27c3		       4c b0 38 	      jmp	.skipLine4
   3724  27c6
   3725  27c6				   .skipL0204
   3726  27c6				   .L0205		;  DF0LOW  =  BKCOLSLOW  +  linePos4
   3727  27c6
   3728  27c6		       a9 a5		      LDA	#BKCOLSLOW
   3729  27c8		       18		      CLC
   3730  27c9		       65 d4		      ADC	linePos4
   3731  27cb		       8d 50 10 	      STA	DF0LOW
   3732  27ce				   .L0206		;  DF0HI  =  BKCOLSHI
   3733  27ce
   3734  27ce		       a9 0b		      LDA	#BKCOLSHI
   3735  27d0		       8d 68 10 	      STA	DF0HI
   3736  27d3				   .L0207		;  DF0PUSH  =	$00
   3737  27d3
   3738  27d3		       a9 00		      LDA	#$00
   3739  27d5		       8d 60 10 	      STA	DF0PUSH
   3740  27d8				   .L0208		;  if linePos4  >  67 then DF0PUSH  =	$00
   3741  27d8
   3742  27d8		       a9 43		      LDA	#67
   3743  27da		       c5 d4		      CMP	linePos4
   3744  27dc		       b0 05		      BCS	.skipL0208
   3745  27de				   .condpart35
   3746  27de		       a9 00		      LDA	#$00
   3747  27e0		       8d 60 10 	      STA	DF0PUSH
   3748  27e3				   .skipL0208
   3749  27e3				   .L0209		;  pfpixel hole4x linePos4 off
   3750  27e3
   3751  27e3		       a9 a4		      lda	#<C_function
   3752  27e5		       8d 50 10 	      sta	DF0LOW
   3753  27e8		       a9 01		      lda	#(>C_function) & $0F
   3754  27ea		       8d 68 10 	      sta	DF0HI
   3755  27ed		       a2 0d		      LDX	#13
   3756  27ef		       8e 78 10 	      STX	DF0WRITE
   3757  27f2		       8e 78 10 	      STX	DF0WRITE
   3758  27f5		       a4 d4		      LDY	linePos4
   3759  27f7		       8c 78 10 	      STY	DF0WRITE
   3760  27fa		       a5 f0		      LDA	hole4x
   3761  27fc		       8d 78 10 	      STA	DF0WRITE
   3762  27ff		       a9 ff		      lda	#255
   3763  2801		       8d 5a 10 	      sta	CALLFUNCTION
   3764  2804				   .
   3765  2804							; 
   3766  2804
   3767  2804				   .L0210		;  linePos4  =  linePos4  +  speedup4
   3768  2804
   3769  2804		       a5 da		      LDA	j
   3770  2806		       18		      CLC
   3771  2807		       65 e8		      ADC	x
   3772  2809		       85 da		      STA	j
   3773  280b		       a5 d4		      LDA	linePos4
   3774  280d		       65 e2		      ADC	speedup4
   3775  280f		       85 d4		      STA	linePos4
   3776  2811				   .L0211		;  speedup4  =  speedup4  +  0.00390625
   3777  2811
   3778  2811		       a5 e8		      LDA	x
   3779  2813		       18		      CLC
   3780  2814		       69 01		      ADC	#1
   3781  2816		       85 e8		      STA	x
   3782  2818		       a5 e2		      LDA	speedup4
   3783  281a		       69 00		      ADC	#0
   3784  281c		       85 e2		      STA	speedup4
   3785  281e				   .L0212		;  if linePos4  >=  87 then linePos4  =  0.0  :  speedup4  =  0.0
   3786  281e
   3787  281e		       a5 d4		      LDA	linePos4
   3788  2820		       c9 57		      CMP	#87
   3789  2822		       90 10		      BCC	.skipL0212
   3790  2824				   .condpart36
   3791  2824		       a2 00		      LDX	#0
   3792  2826		       86 da		      STX	j
   3793  2828		       a9 00		      LDA	#0
   3794  282a		       85 d4		      STA	linePos4
   3795  282c		       a2 00		      LDX	#0
   3796  282e		       86 e8		      STX	x
   3797  2830		       a9 00		      LDA	#0
   3798  2832		       85 e2		      STA	speedup4
   3799  2834				   .skipL0212
   3800  2834				   .
   3801  2834							; 
   3802  2834
   3803  2834				   .L0213		;  if linePos4  >  54	&&  linePos4  <=  67 then player1y  =	( linePos4  -  1 )   *	2  :  player1x	=   ( hole4x  *  4 )   +  13 else pfpixel hole4x linePos4 on
   3804  2834
   3805  2834		       a9 36		      LDA	#54
   3806  2836		       c5 d4		      CMP	linePos4
   3807  2838		       b0 1a		      BCS	.skipL0213
   3808  283a				   .condpart37
   3809  283a		       a9 43		      LDA	#67
   3810  283c		       c5 d4		      CMP	linePos4
   3811  283e		       90 14		      BCC	.skip37then
   3812  2840				   .condpart38
   3813  2840							; complex statement detected
   3814  2840		       a5 d4		      LDA	linePos4
   3815  2842		       38		      SEC
   3816  2843		       e9 01		      SBC	#1
   3817  2845		       0a		      asl
   3818  2846		       85 9a		      STA	player1y
   3819  2848							; complex statement detected
   3820  2848		       a5 f0		      LDA	hole4x
   3821  284a		       0a		      asl
   3822  284b		       0a		      asl
   3823  284c		       18		      CLC
   3824  284d		       69 0d		      ADC	#13
   3825  284f		       85 90		      STA	player1x
   3826  2851		       4c 75 38 	      jmp	.skipelse3
   3827  2854				   .skip37then
   3828  2854				   .skipL0213
   3829  2854		       a9 a4		      lda	#<C_function
   3830  2856		       8d 50 10 	      sta	DF0LOW
   3831  2859		       a9 01		      lda	#(>C_function) & $0F
   3832  285b		       8d 68 10 	      sta	DF0HI
   3833  285e		       a2 0c		      LDX	#12
   3834  2860		       8e 78 10 	      STX	DF0WRITE
   3835  2863		       8e 78 10 	      STX	DF0WRITE
   3836  2866		       a4 d4		      LDY	linePos4
   3837  2868		       8c 78 10 	      STY	DF0WRITE
   3838  286b		       a5 f0		      LDA	hole4x
   3839  286d		       8d 78 10 	      STA	DF0WRITE
   3840  2870		       a9 ff		      lda	#255
   3841  2872		       8d 5a 10 	      sta	CALLFUNCTION
   3842  2875				   .skipelse3
   3843  2875				   .
   3844  2875							; 
   3845  2875
   3846  2875				   .L0214		;  DF0LOW  =  BKCOLSLOW  +  linePos4
   3847  2875
   3848  2875		       a9 a5		      LDA	#BKCOLSLOW
   3849  2877		       18		      CLC
   3850  2878		       65 d4		      ADC	linePos4
   3851  287a		       8d 50 10 	      STA	DF0LOW
   3852  287d				   .L0215		;  DF0HI  =  BKCOLSHI
   3853  287d
   3854  287d		       a9 0b		      LDA	#BKCOLSHI
   3855  287f		       8d 68 10 	      STA	DF0HI
   3856  2882				   .L0216		;  temp5  =  linePos4	-  44
   3857  2882
   3858  2882		       a5 d4		      LDA	linePos4
   3859  2884		       38		      SEC
   3860  2885		       e9 2c		      SBC	#44
   3861  2887		       85 cf		      STA	temp5
   3862  2889				   .L0217		;  DF0PUSH  =	_color[temp5]
   3863  2889
   3864  2889		       a6 cf		      LDX	temp5
   3865  288b		       bd a9 39 	      LDA	_color,x
   3866  288e		       8d 60 10 	      STA	DF0PUSH
   3867  2891				   .L0218		;  if linePos4  >  67 then DF0PUSH  =	_color[temp5]  :  ballx  =   ( hole4x  *  4 )	+  15  :  bally  =   ( linePos4  -  2 )   *  2
   3868  2891
   3869  2891		       a9 43		      LDA	#67
   3870  2893		       c5 d4		      CMP	linePos4
   3871  2895		       b0 19		      BCS	.skipL0218
   3872  2897				   .condpart39
   3873  2897		       a6 cf		      LDX	temp5
   3874  2899		       bd a9 39 	      LDA	_color,x
   3875  289c		       8d 60 10 	      STA	DF0PUSH
   3876  289f							; complex statement detected
   3877  289f		       a5 f0		      LDA	hole4x
   3878  28a1		       0a		      asl
   3879  28a2		       0a		      asl
   3880  28a3		       18		      CLC
   3881  28a4		       69 0f		      ADC	#15
   3882  28a6		       85 84		      STA	ballx
   3883  28a8							; complex statement detected
   3884  28a8		       a5 d4		      LDA	linePos4
   3885  28aa		       38		      SEC
   3886  28ab		       e9 02		      SBC	#2
   3887  28ad		       0a		      asl
   3888  28ae		       85 c1		      STA	bally
   3889  28b0				   .skipL0218
   3890  28b0				   .
   3891  28b0							; 
   3892  28b0
   3893  28b0				   .skipLine4
   3894  28b0							; skipLine4
   3895  28b0
   3896  28b0				   .
   3897  28b0							; 
   3898  28b0
   3899  28b0				   .
   3900  28b0							; 
   3901  28b0
   3902  28b0				   .
   3903  28b0							; 
   3904  28b0
   3905  28b0				   .
   3906  28b0							; 
   3907  28b0
   3908  28b0				   .
   3909  28b0							; 
   3910  28b0
   3911  28b0				   .
   3912  28b0							; 
   3913  28b0
   3914  28b0				   .
   3915  28b0							; 
   3916  28b0
   3917  28b0				   .
   3918  28b0							; 
   3919  28b0
   3920  28b0				   .
   3921  28b0							; 
   3922  28b0
   3923  28b0				   .
   3924  28b0							; 
   3925  28b0
   3926  28b0				   .
   3927  28b0							; 
   3928  28b0
   3929  28b0				   .
   3930  28b0							; 
   3931  28b0
   3932  28b0				   .
   3933  28b0							; 
   3934  28b0
   3935  28b0				   .
   3936  28b0							; 
   3937  28b0
   3938  28b0				   .
   3939  28b0							; 
   3940  28b0
   3941  28b0				   .
   3942  28b0							; 
   3943  28b0
   3944  28b0				   .
   3945  28b0							; 
   3946  28b0
   3947  28b0				   .
   3948  28b0							; 
   3949  28b0
   3950  28b0				   .
   3951  28b0							; 
   3952  28b0
   3953  28b0				   .L0219		;  for temp5  =  0 to 3 step 1
   3954  28b0
   3955  28b0		       a9 00		      LDA	#0
   3956  28b2		       85 cf		      STA	temp5
   3957  28b4				   .L0219fortemp5
   3958  28b4				   .L0220		;  temp1  =  linePosArray[temp5]
   3959  28b4
   3960  28b4		       a6 cf		      LDX	temp5
   3961  28b6		       b5 d1		      LDA	linePosArray,x
   3962  28b8		       85 cb		      STA	temp1
   3963  28ba				   .L0221		;  temp2  =  temp1  *	2
   3964  28ba
   3965  28ba		       a5 cb		      LDA	temp1
   3966  28bc		       0a		      asl
   3967  28bd		       85 cc		      STA	temp2
   3968  28bf				   .L0222		;  temp3  =  0
   3969  28bf
   3970  28bf		       a9 00		      LDA	#0
   3971  28c1		       85 cd		      STA	temp3
   3972  28c3				   .L0223		;  if	( missile1y  +	4 )   >=  temp2  &&  missile1y	<=   ( temp2  +  2 )  then overlapped  =  1  :	goto collisionCheck else temp3	=  1
   3973  28c3
   3974  28c3							; complex condition detected
   3975  28c3							; complex statement detected
   3976  28c3		       a5 c0		      LDA	missile1y
   3977  28c5		       18		      CLC
   3978  28c6		       69 04		      ADC	#4
   3979  28c8							; todo: this LDA is spurious and should be prevented ->	LDA  1,x
   3980  28c8		       c5 cc		      CMP	temp2
   3981  28ca		       90 15		      BCC	.skipL0223
   3982  28cc				   .condpart40
   3983  28cc							; complex condition detected
   3984  28cc							; complex statement detected
   3985  28cc		       a5 cc		      LDA	temp2
   3986  28ce		       18		      CLC
   3987  28cf		       69 02		      ADC	#2
   3988  28d1		       c5 c0		      CMP	missile1y
   3989  28d3		       90 0c		      BCC	.skip40then
   3990  28d5				   .condpart41
   3991  28d5		       a5 ec		      LDA	var0
   3992  28d7		       09 20		      ORA	#32
   3993  28d9		       85 ec		      STA	var0
   3994  28db		       4c 3d 39 	      jmp	.collisionCheck
   3995  28de		       4c e5 38 	      jmp	.skipelse4
   3996  28e1				   .skip40then
   3997  28e1				   .skipL0223
   3998  28e1		       a9 01		      LDA	#1
   3999  28e3		       85 cd		      STA	temp3
   4000  28e5				   .skipelse4
   4001  28e5				   .L0224		;  next
   4002  28e5
   4003  28e5		       a5 cf		      LDA	temp5
   4004  28e7		       18		      CLC
   4005  28e8		       69 01		      ADC	#1
   4006  28ea
   4007  28ea		       85 cf		      STA	temp5
   4008  28ec		       c9 04		      CMP	#3+1
   4009  28ee		       90 c4		      bcc	.L0219fortemp5
   4010  28f0				  -	      if	( (((((#>*)&$1f)*256)|(#<.L0219fortemp5))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.L0219fortemp5))<=(bankswitch_hotspot+bs_mask)) )
   4011  28f0				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   4012  28f0					      endif
   4013  28f0				   .
   4014  28f0							; 
   4015  28f0
   4016  28f0				   .L0225		;  if overlapped  &&  temp3 then score  =  score  +  1  :  overlapped	=  0
   4017  28f0
   4018  28f0		       a5 ec		      LDA	var0
   4019  28f2		       29 20		      AND	#32
   4020  28f4		       f0 1f		      BEQ	.skipL0225
   4021  28f6				   .condpart42
   4022  28f6		       a5 cd		      LDA	temp3
   4023  28f8		       f0 1b		      BEQ	.skip42then
   4024  28fa				   .condpart43
   4025  28fa		       f8		      SED
   4026  28fb		       18		      CLC
   4027  28fc		       a5 ba		      LDA	score+2
   4028  28fe		       69 01		      ADC	#$01
   4029  2900		       85 ba		      STA	score+2
   4030  2902		       a5 b9		      LDA	score+1
   4031  2904		       69 00		      ADC	#$00
   4032  2906		       85 b9		      STA	score+1
   4033  2908		       a5 b8		      LDA	score
   4034  290a		       69 00		      ADC	#$00
   4035  290c		       85 b8		      STA	score
   4036  290e		       d8		      CLD
   4037  290f		       a5 ec		      LDA	var0
   4038  2911		       29 df		      AND	#223
   4039  2913		       85 ec		      STA	var0
   4040  2915				   .skip42then
   4041  2915				   .skipL0225
   4042  2915				   .back
   4043  2915							; back
   4044  2915
   4045  2915				   .
   4046  2915							; 
   4047  2915
   4048  2915				   .
   4049  2915							; 
   4050  2915
   4051  2915				   .
   4052  2915							; 
   4053  2915
   4054  2915				   .
   4055  2915							; 
   4056  2915
   4057  2915				   .
   4058  2915							; 
   4059  2915
   4060  2915				   .
   4061  2915							; 
   4062  2915
   4063  2915				   .
   4064  2915							; 
   4065  2915
   4066  2915				   .
   4067  2915							; 
   4068  2915
   4069  2915				   .
   4070  2915							; 
   4071  2915
   4072  2915				   .
   4073  2915							; 
   4074  2915
   4075  2915				   .
   4076  2915							; 
   4077  2915
   4078  2915				   .
   4079  2915							; 
   4080  2915
   4081  2915				   .
   4082  2915							; 
   4083  2915
   4084  2915				   .
   4085  2915							; 
   4086  2915
   4087  2915				   .gameOverLoop
   4088  2915							; gameOverLoop
   4089  2915
   4090  2915				   .
   4091  2915							; 
   4092  2915
   4093  2915				   .L0226		;  gosub reUsed
   4094  2915
   4095  2915		       20 d5 39 	      jsr	.reUsed
   4096  2918
   4097  2918				   .
   4098  2918							; 
   4099  2918
   4100  2918				   .
   4101  2918							; 
   4102  2918
   4103  2918				   .L0227		;  if switchreset then resetRestrainer  =  1 else if resetRestrainer then goto init
   4104  2918
   4105  2918		       a9 01		      lda	#1
   4106  291a		       2c 82 02 	      bit	SWCHB
   4107  291d		       d0 09		      BNE	.skipL0227
   4108  291f				   .condpart44
   4109  291f		       a5 ec		      LDA	var0
   4110  2921		       09 08		      ORA	#8
   4111  2923		       85 ec		      STA	var0
   4112  2925		       4c 31 39 	      jmp	.skipelse5
   4113  2928				   .skipL0227
   4114  2928		       a5 ec		      LDA	var0
   4115  292a		       29 08		      AND	#8
   4116  292c		       f0 03		      BEQ	.skipelse
   4117  292e				   .condpart45
   4118  292e		       4c a4 30 	      jmp	.init
   4119  2931
   4120  2931				   .skipelse
   4121  2931				   .skipelse5
   4122  2931				   .L0228		;  if gameOverBit then goto gameOverLoop
   4123  2931
   4124  2931		       a5 ec		      LDA	var0
   4125  2933		       29 10		      AND	#16
   4126  2935		       f0 03		      BEQ	.skipL0228
   4127  2937				   .condpart46
   4128  2937		       4c 15 39 	      jmp	.gameOverLoop
   4129  293a
   4130  293a				   .skipL0228
   4131  293a				   .
   4132  293a							; 
   4133  293a
   4134  293a				   .L0229		;  goto _main
   4135  293a
   4136  293a		       4c f9 33 	      jmp	._main
   4137  293d
   4138  293d				   .
   4139  293d							; 
   4140  293d
   4141  293d				   .
   4142  293d							; 
   4143  293d
   4144  293d				   .
   4145  293d							; 
   4146  293d
   4147  293d				   .
   4148  293d							; 
   4149  293d
   4150  293d				   .
   4151  293d							; 
   4152  293d
   4153  293d				   .collisionCheck
   4154  293d							; collisionCheck
   4155  293d
   4156  293d				   .L0230		;  if missile1x  <  ballx  ||	 ( missile1x  +  2 )   >   ( ballx  +  8 )  then gameOverBit  =  1
   4157  293d
   4158  293d		       a5 83		      LDA	missile1x
   4159  293f		       c5 84		      CMP	ballx
   4160  2941		       b0 03		      BCS	.skipL0230
   4161  2943				   .condpart47
   4162  2943		       4c 59 39 	      jmp	.condpart48
   4163  2946				   .skipL0230
   4164  2946							; complex condition detected
   4165  2946							; complex statement detected
   4166  2946		       a5 84		      LDA	ballx
   4167  2948		       18		      CLC
   4168  2949		       69 08		      ADC	#8
   4169  294b		       48		      PHA
   4170  294c							; complex statement detected
   4171  294c		       a5 83		      LDA	missile1x
   4172  294e		       18		      CLC
   4173  294f		       69 02		      ADC	#2
   4174  2951		       48		      PHA
   4175  2952		       ba		      TSX
   4176  2953		       68		      PLA
   4177  2954		       68		      PLA
   4178  2955		       d5 01		      CMP	1,x
   4179  2957		       b0 06		      BCS	.skip8OR
   4180  2959				   .condpart48
   4181  2959		       a5 ec		      LDA	var0
   4182  295b		       09 10		      ORA	#16
   4183  295d		       85 ec		      STA	var0
   4184  295f				   .skip8OR
   4185  295f				   .L0231		;  goto back
   4186  295f
   4187  295f		       4c 15 39 	      jmp	.back
   4188  2962
   4189  2962				   .
   4190  2962							; 
   4191  2962
   4192  2962				   .DrawStarField
   4193  2962							; DrawStarField
   4194  2962
   4195  2962				   .L0232		;  HMM0 = $70
   4196  2962
   4197  2962		       a9 70		      LDA	#$70
   4198  2964		       85 22		      STA	HMM0
   4199  2966				   .
   4200  2966							; 
   4201  2966
   4202  2966				   .
   4203  2966							; 
   4204  2966
   4205  2966				   .
   4206  2966							; 
   4207  2966
   4208  2966				   .L0233		;  return otherbank
   4209  2966
   4210  2966		       4c e0 df 	      JMP	BS_return
   4211  2969				   .
   4212  2969							; 
   4213  2969
   4214  2969				   .L0234		;  data starX
   4215  2969
   4216  2969		       4c 70 39 	      JMP	.skipL0234
   4217  296c				   starX
   4218  296c		       71 80 8f 00	      .byte.b	113, 128, 143, 0
   4219  2970
   4220  2970				   .skipL0234
   4221  2970				   .
   4222  2970							; 
   4223  2970
   4224  2970				   .L0235		;  data starY
   4225  2970
   4226  2970		       4c 77 39 	      JMP	.skipL0235
   4227  2973				   starY
   4228  2973		       42 40 3e 00	      .byte.b	66, 64, 62, 0
   4229  2977
   4230  2977				   .skipL0235
   4231  2977				   .
   4232  2977							; 
   4233  2977
   4234  2977				   .L0236		;  data starColor
   4235  2977
   4236  2977		       4c 83 39 	      JMP	.skipL0236
   4237  297a				   starColor
   4238  297a		       02		      .byte.b	$02
   4239  297b
   4240  297b		       04		      .byte.b	$04
   4241  297c
   4242  297c		       06		      .byte.b	$06
   4243  297d
   4244  297d		       08		      .byte.b	$08
   4245  297e
   4246  297e		       0a		      .byte.b	$0a
   4247  297f
   4248  297f		       08		      .byte.b	$08
   4249  2980
   4250  2980		       06		      .byte.b	$06
   4251  2981
   4252  2981		       04		      .byte.b	$04
   4253  2982
   4254  2982		       02		      .byte.b	$02
   4255  2983
   4256  2983				   .skipL0236
   4257  2983				   .
   4258  2983							; 
   4259  2983
   4260  2983				   .L0237		;  data timerLengthTable
   4261  2983
   4262  2983		       4c a6 39 	      JMP	.skipL0237
   4263  2986				   timerLengthTable
   4264  2986		       26		      .byte.b	38
   4265  2987
   4266  2987		       26		      .byte.b	38
   4267  2988
   4268  2988		       30		      .byte.b	48
   4269  2989
   4270  2989		       30		      .byte.b	48
   4271  298a
   4272  298a		       30		      .byte.b	48
   4273  298b
   4274  298b		       30		      .byte.b	48
   4275  298c
   4276  298c		       30		      .byte.b	48
   4277  298d
   4278  298d		       30		      .byte.b	48
   4279  298e
   4280  298e		       30		      .byte.b	48
   4281  298f
   4282  298f		       30		      .byte.b	48
   4283  2990
   4284  2990		       30		      .byte.b	48	;
   4285  2991
   4286  2991		       44		      .byte.b	68
   4287  2992
   4288  2992		       44		      .byte.b	68
   4289  2993
   4290  2993		       44		      .byte.b	68
   4291  2994
   4292  2994		       44		      .byte.b	68
   4293  2995
   4294  2995		       44		      .byte.b	68
   4295  2996
   4296  2996		       44		      .byte.b	68
   4297  2997
   4298  2997		       44		      .byte.b	68
   4299  2998
   4300  2998		       44		      .byte.b	68
   4301  2999
   4302  2999		       44		      .byte.b	68
   4303  299a
   4304  299a		       44		      .byte.b	68
   4305  299b
   4306  299b		       44		      .byte.b	68	;
   4307  299c
   4308  299c		       58		      .byte.b	88
   4309  299d
   4310  299d		       58		      .byte.b	88
   4311  299e
   4312  299e		       58		      .byte.b	88
   4313  299f
   4314  299f		       58		      .byte.b	88
   4315  29a0
   4316  29a0		       58		      .byte.b	88
   4317  29a1
   4318  29a1		       58		      .byte.b	88
   4319  29a2
   4320  29a2		       58		      .byte.b	88
   4321  29a3
   4322  29a3		       58		      .byte.b	88
   4323  29a4
   4324  29a4		       62		      .byte.b	98
   4325  29a5
   4326  29a5		       62		      .byte.b	98
   4327  29a6
   4328  29a6				   .skipL0237
   4329  29a6				   .
   4330  29a6							; 
   4331  29a6
   4332  29a6				   .L0238		;  data _color
   4333  29a6
   4334  29a6		       4c d5 39 	      JMP	.skipL0238
   4335  29a9				   _color
   4336  29a9		       80 80 80 80*	      .byte.b	$80, $80, $80, $80, $80, $80
   4337  29af
   4338  29af		       82 82 82 82*	      .byte.b	$82, $82, $82, $82, $82, $82
   4339  29b5
   4340  29b5		       84 84 84 84*	      .byte.b	$84, $84, $84, $84, $84, $84
   4341  29bb
   4342  29bb		       86 86 86 86*	      .byte.b	$86, $86, $86, $86, $86, $86
   4343  29c1
   4344  29c1		       88 88 88 88*	      .byte.b	$88, $88, $88, $88, $88
   4345  29c6
   4346  29c6		       8a 8a 8a 8a*	      .byte.b	$8a, $8a, $8a, $8a, $8a
   4347  29cb
   4348  29cb		       8c 8c 8c 8c*	      .byte.b	$8c, $8c, $8c, $8c, $8c
   4349  29d0
   4350  29d0		       8e 8e 8e 8e*	      .byte.b	$8e, $8e, $8e, $8e, $8e
   4351  29d5
   4352  29d5				   .skipL0238
   4353  29d5				   .
   4354  29d5							; 
   4355  29d5
   4356  29d5				   .
   4357  29d5							; 
   4358  29d5
   4359  29d5				   .
   4360  29d5							; 
   4361  29d5
   4362  29d5				   .
   4363  29d5							; 
   4364  29d5
   4365  29d5				   .
   4366  29d5							; 
   4367  29d5
   4368  29d5				   .
   4369  29d5							; 
   4370  29d5
   4371  29d5				   .
   4372  29d5							; 
   4373  29d5
   4374  29d5				   .
   4375  29d5							; 
   4376  29d5
   4377  29d5				   .
   4378  29d5							; 
   4379  29d5
   4380  29d5				   .
   4381  29d5							; 
   4382  29d5
   4383  29d5				   .
   4384  29d5							; 
   4385  29d5
   4386  29d5				   .
   4387  29d5							; 
   4388  29d5
   4389  29d5				   .
   4390  29d5							; 
   4391  29d5
   4392  29d5				   .
   4393  29d5							; 
   4394  29d5
   4395  29d5				   .
   4396  29d5							; 
   4397  29d5
   4398  29d5				   .
   4399  29d5							; 
   4400  29d5
   4401  29d5				   .
   4402  29d5							; 
   4403  29d5
   4404  29d5				   .
   4405  29d5							; 
   4406  29d5
   4407  29d5				   .
   4408  29d5							; 
   4409  29d5
   4410  29d5				   .
   4411  29d5							; 
   4412  29d5
   4413  29d5				   .
   4414  29d5							; 
   4415  29d5
   4416  29d5				   .
   4417  29d5							; 
   4418  29d5
   4419  29d5				   .
   4420  29d5							; 
   4421  29d5
   4422  29d5				   .
   4423  29d5							; 
   4424  29d5
   4425  29d5				   .reUsed
   4426  29d5							; reUsed
   4427  29d5
   4428  29d5				   .L0239		;  DF0LOW  =  BKCOLSLOW  +  44
   4429  29d5
   4430  29d5		       a9 a5		      LDA	#BKCOLSLOW
   4431  29d7		       18		      CLC
   4432  29d8		       69 2c		      ADC	#44
   4433  29da		       8d 50 10 	      STA	DF0LOW
   4434  29dd				   .L0240		;  DF0HI  =  BKCOLSHI
   4435  29dd
   4436  29dd		       a9 0b		      LDA	#BKCOLSHI
   4437  29df		       8d 68 10 	      STA	DF0HI
   4438  29e2				   .L0241		;  DF0PUSH  =	$80
   4439  29e2
   4440  29e2		       a9 80		      LDA	#$80
   4441  29e4		       8d 60 10 	      STA	DF0PUSH
   4442  29e7				   .
   4443  29e7							; 
   4444  29e7
   4445  29e7				   .L0242		;  DF0LOW  =  BKCOLSLOW  +  87
   4446  29e7
   4447  29e7		       a9 a5		      LDA	#BKCOLSLOW
   4448  29e9		       18		      CLC
   4449  29ea		       69 57		      ADC	#87
   4450  29ec		       8d 50 10 	      STA	DF0LOW
   4451  29ef				   .
   4452  29ef							; 
   4453  29ef
   4454  29ef				   .L0243		;  DF0PUSH  =	$0e
   4455  29ef
   4456  29ef		       a9 0e		      LDA	#$0e
   4457  29f1		       8d 60 10 	      STA	DF0PUSH
   4458  29f4				   .
   4459  29f4							; 
   4460  29f4
   4461  29f4				   .L0244		;  flipBit  =	!flipBit
   4462  29f4
   4463  29f4		       a5 ec		      LDA	var0
   4464  29f6		       29 04		      AND	#4
   4465  29f8		       08		      PHP
   4466  29f9		       a5 ec		      LDA	var0
   4467  29fb		       29 fb		      AND	#251
   4468  29fd		       28		      PLP
   4469  29fe		       d0 02		      .byte.b	$D0, $02
   4470  2a00		       09 04		      ORA	#4
   4471  2a02		       85 ec		      STA	var0
   4472  2a04				   .
   4473  2a04							; 
   4474  2a04
   4475  2a04				   .L0245		;  if flipBit then __1
   4476  2a04
   4477  2a04		       a5 ec		      LDA	var0
   4478  2a06		       29 04		      AND	#4
   4479  2a08		       d0 1f		      bne	.__1
   4480  2a0a				  -	      if	( (((((#>*)&$1f)*256)|(#<.__1))>=bankswitch_hotspot) && (((((#>*)&$1f)*256)|(#<.__1))<=(bankswitch_hotspot+bs_mask)) )
   4481  2a0a				  -	      echo	"WARNING: branch near the end of bank 2 may accidentally trigger a bankswitch. Reposition code there if bad things happen."
   4482  2a0a					      endif
   4483  2a0a				   .L0246		;  player2:
   4484  2a0a
   4485  2a0a		       a9 e4		      lda	#<(playerpointers+2)
   4486  2a0c		       8d 50 10 	      sta	DF0LOW
   4487  2a0f		       a9 01		      lda	#(>(playerpointers+2)) & $0F
   4488  2a11		       8d 68 10 	      sta	DF0HI
   4489  2a14		       a2 48		      LDX	#<playerL0246_2
   4490  2a16		       8e 78 10 	      STX	DF0WRITE
   4491  2a19		       a9 62		      LDA	#((>playerL0246_2) & $0f) | (((>playerL0246_2) / 2) & $70)
   4492  2a1b		       8d 78 10 	      STA	DF0WRITE
   4493  2a1e		       a9 08		      LDA	#8
   4494  2a20		       85 a7		      STA	player2height
   4495  2a22				   .L0247		;  player2x  =  113
   4496  2a22
   4497  2a22		       a9 71		      LDA	#113
   4498  2a24		       85 91		      STA	player2x
   4499  2a26				   .L0248		;  goto __2
   4500  2a26
   4501  2a26		       4c 45 3a 	      jmp	.__2
   4502  2a29
   4503  2a29				   .
   4504  2a29							; 
   4505  2a29
   4506  2a29				   .__1
   4507  2a29							; __1
   4508  2a29
   4509  2a29				   .L0249		;  player2:
   4510  2a29
   4511  2a29		       a9 e4		      lda	#<(playerpointers+2)
   4512  2a2b		       8d 50 10 	      sta	DF0LOW
   4513  2a2e		       a9 01		      lda	#(>(playerpointers+2)) & $0F
   4514  2a30		       8d 68 10 	      sta	DF0HI
   4515  2a33		       a2 50		      LDX	#<playerL0249_2
   4516  2a35		       8e 78 10 	      STX	DF0WRITE
   4517  2a38		       a9 62		      LDA	#((>playerL0249_2) & $0f) | (((>playerL0249_2) / 2) & $70)
   4518  2a3a		       8d 78 10 	      STA	DF0WRITE
   4519  2a3d		       a9 08		      LDA	#8
   4520  2a3f		       85 a7		      STA	player2height
   4521  2a41				   .L0250		;  player2x  =  105
   4522  2a41
   4523  2a41		       a9 69		      LDA	#105
   4524  2a43		       85 91		      STA	player2x
   4525  2a45				   .__2
   4526  2a45							; __2
   4527  2a45
   4528  2a45				   .L0251		;  NUSIZ0  =  $04
   4529  2a45
   4530  2a45		       a9 04		      LDA	#$04
   4531  2a47		       85 04		      STA	NUSIZ0
   4532  2a49				   .
   4533  2a49							; 
   4534  2a49
   4535  2a49				   .
   4536  2a49							; 
   4537  2a49
   4538  2a49				   .
   4539  2a49							; 
   4540  2a49
   4541  2a49				   .
   4542  2a49							; 
   4543  2a49
   4544  2a49				   .L0252		;  DF6FRACINC	=  255	:  DF4FRACINC  =  255
   4545  2a49
   4546  2a49		       a9 ff		      LDA	#255
   4547  2a4b		       8d 3e 10 	      STA	DF6FRACINC
   4548  2a4e		       8d 3c 10 	      STA	DF4FRACINC
   4549  2a51				   .L0253		;  DF0FRACINC	=  128	:  DF1FRACINC  =  128  :  DF2FRACINC  =  128  :  DF3FRACINC  =	128
   4550  2a51
   4551  2a51		       a9 80		      LDA	#128
   4552  2a53		       8d 38 10 	      STA	DF0FRACINC
   4553  2a56		       8d 39 10 	      STA	DF1FRACINC
   4554  2a59		       8d 3a 10 	      STA	DF2FRACINC
   4555  2a5c		       8d 3b 10 	      STA	DF3FRACINC
   4556  2a5f				   .L0254		;  asm
   4557  2a5f
   4558  2a5f							;LDA DF6FRACDATA ; bgcolor priming read (first value will be read twice)
   4559  2a5f
   4560  2a5f							;LDA DF4FRACDATA ; pfcolor priming read (first value will be read twice)
   4561  2a5f
   4562  2a5f
   4563  2a5f
   4564  2a5f							;LDA DF0FRACDATA
   4565  2a5f
   4566  2a5f							;LDA DF1FRACDATA
   4567  2a5f
   4568  2a5f							;LDA DF0FRACDATA
   4569  2a5f
   4570  2a5f							;LDA DF1FRACDATA
   4571  2a5f
   4572  2a5f				   .
   4573  2a5f							; 
   4574  2a5f
   4575  2a5f				   .
   4576  2a5f							; 
   4577  2a5f
   4578  2a5f				   .
   4579  2a5f							; 
   4580  2a5f
   4581  2a5f				   .
   4582  2a5f							; 
   4583  2a5f
   4584  2a5f				   .
   4585  2a5f							; 
   4586  2a5f
   4587  2a5f				   .L0255		;  drawscreen
   4588  2a5f
   4589  2a5f		       85 81		      sta	temp7
   4590  2a61		       a9 3a		      lda	#>(ret_point3-1)
   4591  2a63		       48		      pha
   4592  2a64		       a9 76		      lda	#<(ret_point3-1)
   4593  2a66		       48		      pha
   4594  2a67		       a9 19		      lda	#>(drawscreen-1)
   4595  2a69		       48		      pha
   4596  2a6a		       a9 48		      lda	#<(drawscreen-1)
   4597  2a6c		       48		      pha
   4598  2a6d		       a5 81		      lda	temp7
   4599  2a6f		       48		      pha
   4600  2a70		       8a		      txa
   4601  2a71		       48		      pha
   4602  2a72		       a2 01		      ldx	#1
   4603  2a74		       4c ee df 	      jmp	BS_jsr
   4604  2a77				   ret_point3
   4605  2a77				   .L0256		;  return thisbank
   4606  2a77
   4607  2a77		       60		      RTS
   4608  2a78				   .
   4609  2a78							; 
   4610  2a78
   4611  2a78				   .L0257		;  bank 3
   4612  2a78
   4613  2a78					      if	ECHO2
      1372 bytes of ROM space left in bank 2
   4614  2a78					      echo	"    ",[(start_bank2 - *)]d , "bytes of ROM space left in bank 2")
   4615  2a78					      endif
   4616  2a78		       00 01	   ECHO2      =	1
   4617  2fd4					      ORG	$2FF4-bscode_length
   4618  2fd4					      RORG	$3FF4-bscode_length
   4619  2fd4		       a2 ff	   start_bank2 ldx	#$ff
   4620  2fd6					      ifconst	FASTFETCH	; using DPC+
   4621  2fd6		       8e 58 10 	      stx	FASTFETCH
   4622  2fd9					      endif
   4623  2fd9		       9a		      txs
   4624  2fda				  -	      if	bankswitch == 64
   4625  2fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4626  2fda					      else
   4627  2fda		       a9 18		      lda	#>(start-1)
   4628  2fdc					      endif
   4629  2fdc		       48		      pha
   4630  2fdd		       a9 e3		      lda	#<(start-1)
   4631  2fdf		       48		      pha
   4632  2fe0		       48		      pha
   4633  2fe1		       8a		      txa
   4634  2fe2		       48		      pha
   4635  2fe3		       ba		      tsx
   4636  2fe4					      if	bankswitch != 64
   4637  2fe4		       b5 04		      lda	4,x	; get high byte of return address
   4638  2fe6		       2a		      rol
   4639  2fe7		       2a		      rol
   4640  2fe8		       2a		      rol
   4641  2fe9		       2a		      rol
   4642  2fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4643  2fec		       aa		      tax
   4644  2fed		       e8		      inx
   4645  2fee				  -	      else
   4646  2fee				  -	      lda	4,x	; get high byte of return address
   4647  2fee				  -	      tay
   4648  2fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4649  2fee				  -	      sta	4,x
   4650  2fee				  -	      tya
   4651  2fee				  -	      lsr
   4652  2fee				  -	      lsr
   4653  2fee				  -	      lsr
   4654  2fee				  -	      lsr
   4655  2fee				  -	      tax
   4656  2fee				  -	      inx
   4657  2fee					      endif
   4658  2fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4659  2ff1		       68		      pla
   4660  2ff2		       aa		      tax
   4661  2ff3		       68		      pla
   4662  2ff4		       60		      rts
   4663  2ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4664  2ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4665  2ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4666  2ff5					      endif
   4667  2ffc					      ORG	$2FFC
   4668  2ffc					      RORG	$3FFC
   4669  2ffc		       d4 3f		      .word.w	(start_bank2 & $ffff)
   4670  2ffe		       d4 3f		      .word.w	(start_bank2 & $ffff)
   4671  3000					      ORG	$3000
   4672  3000					      RORG	$5000
   4673  3000					      repeat	129
   4674  3000		       00		      .byte.b	0
   4673  3000					      repend
   4674  3001		       00		      .byte.b	0
   4673  3001					      repend
   4674  3002		       00		      .byte.b	0
   4673  3002					      repend
   4674  3003		       00		      .byte.b	0
   4673  3003					      repend
   4674  3004		       00		      .byte.b	0
   4673  3004					      repend
   4674  3005		       00		      .byte.b	0
   4673  3005					      repend
   4674  3006		       00		      .byte.b	0
   4673  3006					      repend
   4674  3007		       00		      .byte.b	0
   4673  3007					      repend
   4674  3008		       00		      .byte.b	0
   4673  3008					      repend
   4674  3009		       00		      .byte.b	0
   4673  3009					      repend
   4674  300a		       00		      .byte.b	0
   4673  300a					      repend
   4674  300b		       00		      .byte.b	0
   4673  300b					      repend
   4674  300c		       00		      .byte.b	0
   4673  300c					      repend
   4674  300d		       00		      .byte.b	0
   4673  300d					      repend
   4674  300e		       00		      .byte.b	0
   4673  300e					      repend
   4674  300f		       00		      .byte.b	0
   4673  300f					      repend
   4674  3010		       00		      .byte.b	0
   4673  3010					      repend
   4674  3011		       00		      .byte.b	0
   4673  3011					      repend
   4674  3012		       00		      .byte.b	0
   4673  3012					      repend
   4674  3013		       00		      .byte.b	0
   4673  3013					      repend
   4674  3014		       00		      .byte.b	0
   4673  3014					      repend
   4674  3015		       00		      .byte.b	0
   4673  3015					      repend
   4674  3016		       00		      .byte.b	0
   4673  3016					      repend
   4674  3017		       00		      .byte.b	0
   4673  3017					      repend
   4674  3018		       00		      .byte.b	0
   4673  3018					      repend
   4674  3019		       00		      .byte.b	0
   4673  3019					      repend
   4674  301a		       00		      .byte.b	0
   4673  301a					      repend
   4674  301b		       00		      .byte.b	0
   4673  301b					      repend
   4674  301c		       00		      .byte.b	0
   4673  301c					      repend
   4674  301d		       00		      .byte.b	0
   4673  301d					      repend
   4674  301e		       00		      .byte.b	0
   4673  301e					      repend
   4674  301f		       00		      .byte.b	0
   4673  301f					      repend
   4674  3020		       00		      .byte.b	0
   4673  3020					      repend
   4674  3021		       00		      .byte.b	0
   4673  3021					      repend
   4674  3022		       00		      .byte.b	0
   4673  3022					      repend
   4674  3023		       00		      .byte.b	0
   4673  3023					      repend
   4674  3024		       00		      .byte.b	0
   4673  3024					      repend
   4674  3025		       00		      .byte.b	0
   4673  3025					      repend
   4674  3026		       00		      .byte.b	0
   4673  3026					      repend
   4674  3027		       00		      .byte.b	0
   4673  3027					      repend
   4674  3028		       00		      .byte.b	0
   4673  3028					      repend
   4674  3029		       00		      .byte.b	0
   4673  3029					      repend
   4674  302a		       00		      .byte.b	0
   4673  302a					      repend
   4674  302b		       00		      .byte.b	0
   4673  302b					      repend
   4674  302c		       00		      .byte.b	0
   4673  302c					      repend
   4674  302d		       00		      .byte.b	0
   4673  302d					      repend
   4674  302e		       00		      .byte.b	0
   4673  302e					      repend
   4674  302f		       00		      .byte.b	0
   4673  302f					      repend
   4674  3030		       00		      .byte.b	0
   4673  3030					      repend
   4674  3031		       00		      .byte.b	0
   4673  3031					      repend
   4674  3032		       00		      .byte.b	0
   4673  3032					      repend
   4674  3033		       00		      .byte.b	0
   4673  3033					      repend
   4674  3034		       00		      .byte.b	0
   4673  3034					      repend
   4674  3035		       00		      .byte.b	0
   4673  3035					      repend
   4674  3036		       00		      .byte.b	0
   4673  3036					      repend
   4674  3037		       00		      .byte.b	0
   4673  3037					      repend
   4674  3038		       00		      .byte.b	0
   4673  3038					      repend
   4674  3039		       00		      .byte.b	0
   4673  3039					      repend
   4674  303a		       00		      .byte.b	0
   4673  303a					      repend
   4674  303b		       00		      .byte.b	0
   4673  303b					      repend
   4674  303c		       00		      .byte.b	0
   4673  303c					      repend
   4674  303d		       00		      .byte.b	0
   4673  303d					      repend
   4674  303e		       00		      .byte.b	0
   4673  303e					      repend
   4674  303f		       00		      .byte.b	0
   4673  303f					      repend
   4674  3040		       00		      .byte.b	0
   4673  3040					      repend
   4674  3041		       00		      .byte.b	0
   4673  3041					      repend
   4674  3042		       00		      .byte.b	0
   4673  3042					      repend
   4674  3043		       00		      .byte.b	0
   4673  3043					      repend
   4674  3044		       00		      .byte.b	0
   4673  3044					      repend
   4674  3045		       00		      .byte.b	0
   4673  3045					      repend
   4674  3046		       00		      .byte.b	0
   4673  3046					      repend
   4674  3047		       00		      .byte.b	0
   4673  3047					      repend
   4674  3048		       00		      .byte.b	0
   4673  3048					      repend
   4674  3049		       00		      .byte.b	0
   4673  3049					      repend
   4674  304a		       00		      .byte.b	0
   4673  304a					      repend
   4674  304b		       00		      .byte.b	0
   4673  304b					      repend
   4674  304c		       00		      .byte.b	0
   4673  304c					      repend
   4674  304d		       00		      .byte.b	0
   4673  304d					      repend
   4674  304e		       00		      .byte.b	0
   4673  304e					      repend
   4674  304f		       00		      .byte.b	0
   4673  304f					      repend
   4674  3050		       00		      .byte.b	0
   4673  3050					      repend
   4674  3051		       00		      .byte.b	0
   4673  3051					      repend
   4674  3052		       00		      .byte.b	0
   4673  3052					      repend
   4674  3053		       00		      .byte.b	0
   4673  3053					      repend
   4674  3054		       00		      .byte.b	0
   4673  3054					      repend
   4674  3055		       00		      .byte.b	0
   4673  3055					      repend
   4674  3056		       00		      .byte.b	0
   4673  3056					      repend
   4674  3057		       00		      .byte.b	0
   4673  3057					      repend
   4674  3058		       00		      .byte.b	0
   4673  3058					      repend
   4674  3059		       00		      .byte.b	0
   4673  3059					      repend
   4674  305a		       00		      .byte.b	0
   4673  305a					      repend
   4674  305b		       00		      .byte.b	0
   4673  305b					      repend
   4674  305c		       00		      .byte.b	0
   4673  305c					      repend
   4674  305d		       00		      .byte.b	0
   4673  305d					      repend
   4674  305e		       00		      .byte.b	0
   4673  305e					      repend
   4674  305f		       00		      .byte.b	0
   4673  305f					      repend
   4674  3060		       00		      .byte.b	0
   4673  3060					      repend
   4674  3061		       00		      .byte.b	0
   4673  3061					      repend
   4674  3062		       00		      .byte.b	0
   4673  3062					      repend
   4674  3063		       00		      .byte.b	0
   4673  3063					      repend
   4674  3064		       00		      .byte.b	0
   4673  3064					      repend
   4674  3065		       00		      .byte.b	0
   4673  3065					      repend
   4674  3066		       00		      .byte.b	0
   4673  3066					      repend
   4674  3067		       00		      .byte.b	0
   4673  3067					      repend
   4674  3068		       00		      .byte.b	0
   4673  3068					      repend
   4674  3069		       00		      .byte.b	0
   4673  3069					      repend
   4674  306a		       00		      .byte.b	0
   4673  306a					      repend
   4674  306b		       00		      .byte.b	0
   4673  306b					      repend
   4674  306c		       00		      .byte.b	0
   4673  306c					      repend
   4674  306d		       00		      .byte.b	0
   4673  306d					      repend
   4674  306e		       00		      .byte.b	0
   4673  306e					      repend
   4674  306f		       00		      .byte.b	0
   4673  306f					      repend
   4674  3070		       00		      .byte.b	0
   4673  3070					      repend
   4674  3071		       00		      .byte.b	0
   4673  3071					      repend
   4674  3072		       00		      .byte.b	0
   4673  3072					      repend
   4674  3073		       00		      .byte.b	0
   4673  3073					      repend
   4674  3074		       00		      .byte.b	0
   4673  3074					      repend
   4674  3075		       00		      .byte.b	0
   4673  3075					      repend
   4674  3076		       00		      .byte.b	0
   4673  3076					      repend
   4674  3077		       00		      .byte.b	0
   4673  3077					      repend
   4674  3078		       00		      .byte.b	0
   4673  3078					      repend
   4674  3079		       00		      .byte.b	0
   4673  3079					      repend
   4674  307a		       00		      .byte.b	0
   4673  307a					      repend
   4674  307b		       00		      .byte.b	0
   4673  307b					      repend
   4674  307c		       00		      .byte.b	0
   4673  307c					      repend
   4674  307d		       00		      .byte.b	0
   4673  307d					      repend
   4674  307e		       00		      .byte.b	0
   4673  307e					      repend
   4674  307f		       00		      .byte.b	0
   4673  307f					      repend
   4674  3080		       00		      .byte.b	0
   4675  3081					      repend
   4676  3081				   .L0258		;  temp1 = temp1
   4677  3081
   4678  3081		       a5 cb		      LDA	temp1
   4679  3083		       85 cb		      STA	temp1
   4680  3085				   .
   4681  3085							; 
   4682  3085
   4683  3085				   .L0259		;  bank 4
   4684  3085
   4685  3085					      if	ECHO3
      3919 bytes of ROM space left in bank 3
   4686  3085					      echo	"    ",[(start_bank3 - *)]d , "bytes of ROM space left in bank 3")
   4687  3085					      endif
   4688  3085		       00 01	   ECHO3      =	1
   4689  3fd4					      ORG	$3FF4-bscode_length
   4690  3fd4					      RORG	$5FF4-bscode_length
   4691  3fd4		       a2 ff	   start_bank3 ldx	#$ff
   4692  3fd6					      ifconst	FASTFETCH	; using DPC+
   4693  3fd6		       8e 58 10 	      stx	FASTFETCH
   4694  3fd9					      endif
   4695  3fd9		       9a		      txs
   4696  3fda				  -	      if	bankswitch == 64
   4697  3fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4698  3fda					      else
   4699  3fda		       a9 18		      lda	#>(start-1)
   4700  3fdc					      endif
   4701  3fdc		       48		      pha
   4702  3fdd		       a9 e3		      lda	#<(start-1)
   4703  3fdf		       48		      pha
   4704  3fe0		       48		      pha
   4705  3fe1		       8a		      txa
   4706  3fe2		       48		      pha
   4707  3fe3		       ba		      tsx
   4708  3fe4					      if	bankswitch != 64
   4709  3fe4		       b5 04		      lda	4,x	; get high byte of return address
   4710  3fe6		       2a		      rol
   4711  3fe7		       2a		      rol
   4712  3fe8		       2a		      rol
   4713  3fe9		       2a		      rol
   4714  3fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4715  3fec		       aa		      tax
   4716  3fed		       e8		      inx
   4717  3fee				  -	      else
   4718  3fee				  -	      lda	4,x	; get high byte of return address
   4719  3fee				  -	      tay
   4720  3fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4721  3fee				  -	      sta	4,x
   4722  3fee				  -	      tya
   4723  3fee				  -	      lsr
   4724  3fee				  -	      lsr
   4725  3fee				  -	      lsr
   4726  3fee				  -	      lsr
   4727  3fee				  -	      tax
   4728  3fee				  -	      inx
   4729  3fee					      endif
   4730  3fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4731  3ff1		       68		      pla
   4732  3ff2		       aa		      tax
   4733  3ff3		       68		      pla
   4734  3ff4		       60		      rts
   4735  3ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4736  3ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4737  3ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4738  3ff5					      endif
   4739  3ffc					      ORG	$3FFC
   4740  3ffc					      RORG	$5FFC
   4741  3ffc		       d4 5f		      .word.w	(start_bank3 & $ffff)
   4742  3ffe		       d4 5f		      .word.w	(start_bank3 & $ffff)
   4743  4000					      ORG	$4000
   4744  4000					      RORG	$7000
   4745  4000					      repeat	129
   4746  4000		       00		      .byte.b	0
   4745  4000					      repend
   4746  4001		       00		      .byte.b	0
   4745  4001					      repend
   4746  4002		       00		      .byte.b	0
   4745  4002					      repend
   4746  4003		       00		      .byte.b	0
   4745  4003					      repend
   4746  4004		       00		      .byte.b	0
   4745  4004					      repend
   4746  4005		       00		      .byte.b	0
   4745  4005					      repend
   4746  4006		       00		      .byte.b	0
   4745  4006					      repend
   4746  4007		       00		      .byte.b	0
   4745  4007					      repend
   4746  4008		       00		      .byte.b	0
   4745  4008					      repend
   4746  4009		       00		      .byte.b	0
   4745  4009					      repend
   4746  400a		       00		      .byte.b	0
   4745  400a					      repend
   4746  400b		       00		      .byte.b	0
   4745  400b					      repend
   4746  400c		       00		      .byte.b	0
   4745  400c					      repend
   4746  400d		       00		      .byte.b	0
   4745  400d					      repend
   4746  400e		       00		      .byte.b	0
   4745  400e					      repend
   4746  400f		       00		      .byte.b	0
   4745  400f					      repend
   4746  4010		       00		      .byte.b	0
   4745  4010					      repend
   4746  4011		       00		      .byte.b	0
   4745  4011					      repend
   4746  4012		       00		      .byte.b	0
   4745  4012					      repend
   4746  4013		       00		      .byte.b	0
   4745  4013					      repend
   4746  4014		       00		      .byte.b	0
   4745  4014					      repend
   4746  4015		       00		      .byte.b	0
   4745  4015					      repend
   4746  4016		       00		      .byte.b	0
   4745  4016					      repend
   4746  4017		       00		      .byte.b	0
   4745  4017					      repend
   4746  4018		       00		      .byte.b	0
   4745  4018					      repend
   4746  4019		       00		      .byte.b	0
   4745  4019					      repend
   4746  401a		       00		      .byte.b	0
   4745  401a					      repend
   4746  401b		       00		      .byte.b	0
   4745  401b					      repend
   4746  401c		       00		      .byte.b	0
   4745  401c					      repend
   4746  401d		       00		      .byte.b	0
   4745  401d					      repend
   4746  401e		       00		      .byte.b	0
   4745  401e					      repend
   4746  401f		       00		      .byte.b	0
   4745  401f					      repend
   4746  4020		       00		      .byte.b	0
   4745  4020					      repend
   4746  4021		       00		      .byte.b	0
   4745  4021					      repend
   4746  4022		       00		      .byte.b	0
   4745  4022					      repend
   4746  4023		       00		      .byte.b	0
   4745  4023					      repend
   4746  4024		       00		      .byte.b	0
   4745  4024					      repend
   4746  4025		       00		      .byte.b	0
   4745  4025					      repend
   4746  4026		       00		      .byte.b	0
   4745  4026					      repend
   4746  4027		       00		      .byte.b	0
   4745  4027					      repend
   4746  4028		       00		      .byte.b	0
   4745  4028					      repend
   4746  4029		       00		      .byte.b	0
   4745  4029					      repend
   4746  402a		       00		      .byte.b	0
   4745  402a					      repend
   4746  402b		       00		      .byte.b	0
   4745  402b					      repend
   4746  402c		       00		      .byte.b	0
   4745  402c					      repend
   4746  402d		       00		      .byte.b	0
   4745  402d					      repend
   4746  402e		       00		      .byte.b	0
   4745  402e					      repend
   4746  402f		       00		      .byte.b	0
   4745  402f					      repend
   4746  4030		       00		      .byte.b	0
   4745  4030					      repend
   4746  4031		       00		      .byte.b	0
   4745  4031					      repend
   4746  4032		       00		      .byte.b	0
   4745  4032					      repend
   4746  4033		       00		      .byte.b	0
   4745  4033					      repend
   4746  4034		       00		      .byte.b	0
   4745  4034					      repend
   4746  4035		       00		      .byte.b	0
   4745  4035					      repend
   4746  4036		       00		      .byte.b	0
   4745  4036					      repend
   4746  4037		       00		      .byte.b	0
   4745  4037					      repend
   4746  4038		       00		      .byte.b	0
   4745  4038					      repend
   4746  4039		       00		      .byte.b	0
   4745  4039					      repend
   4746  403a		       00		      .byte.b	0
   4745  403a					      repend
   4746  403b		       00		      .byte.b	0
   4745  403b					      repend
   4746  403c		       00		      .byte.b	0
   4745  403c					      repend
   4746  403d		       00		      .byte.b	0
   4745  403d					      repend
   4746  403e		       00		      .byte.b	0
   4745  403e					      repend
   4746  403f		       00		      .byte.b	0
   4745  403f					      repend
   4746  4040		       00		      .byte.b	0
   4745  4040					      repend
   4746  4041		       00		      .byte.b	0
   4745  4041					      repend
   4746  4042		       00		      .byte.b	0
   4745  4042					      repend
   4746  4043		       00		      .byte.b	0
   4745  4043					      repend
   4746  4044		       00		      .byte.b	0
   4745  4044					      repend
   4746  4045		       00		      .byte.b	0
   4745  4045					      repend
   4746  4046		       00		      .byte.b	0
   4745  4046					      repend
   4746  4047		       00		      .byte.b	0
   4745  4047					      repend
   4746  4048		       00		      .byte.b	0
   4745  4048					      repend
   4746  4049		       00		      .byte.b	0
   4745  4049					      repend
   4746  404a		       00		      .byte.b	0
   4745  404a					      repend
   4746  404b		       00		      .byte.b	0
   4745  404b					      repend
   4746  404c		       00		      .byte.b	0
   4745  404c					      repend
   4746  404d		       00		      .byte.b	0
   4745  404d					      repend
   4746  404e		       00		      .byte.b	0
   4745  404e					      repend
   4746  404f		       00		      .byte.b	0
   4745  404f					      repend
   4746  4050		       00		      .byte.b	0
   4745  4050					      repend
   4746  4051		       00		      .byte.b	0
   4745  4051					      repend
   4746  4052		       00		      .byte.b	0
   4745  4052					      repend
   4746  4053		       00		      .byte.b	0
   4745  4053					      repend
   4746  4054		       00		      .byte.b	0
   4745  4054					      repend
   4746  4055		       00		      .byte.b	0
   4745  4055					      repend
   4746  4056		       00		      .byte.b	0
   4745  4056					      repend
   4746  4057		       00		      .byte.b	0
   4745  4057					      repend
   4746  4058		       00		      .byte.b	0
   4745  4058					      repend
   4746  4059		       00		      .byte.b	0
   4745  4059					      repend
   4746  405a		       00		      .byte.b	0
   4745  405a					      repend
   4746  405b		       00		      .byte.b	0
   4745  405b					      repend
   4746  405c		       00		      .byte.b	0
   4745  405c					      repend
   4746  405d		       00		      .byte.b	0
   4745  405d					      repend
   4746  405e		       00		      .byte.b	0
   4745  405e					      repend
   4746  405f		       00		      .byte.b	0
   4745  405f					      repend
   4746  4060		       00		      .byte.b	0
   4745  4060					      repend
   4746  4061		       00		      .byte.b	0
   4745  4061					      repend
   4746  4062		       00		      .byte.b	0
   4745  4062					      repend
   4746  4063		       00		      .byte.b	0
   4745  4063					      repend
   4746  4064		       00		      .byte.b	0
   4745  4064					      repend
   4746  4065		       00		      .byte.b	0
   4745  4065					      repend
   4746  4066		       00		      .byte.b	0
   4745  4066					      repend
   4746  4067		       00		      .byte.b	0
   4745  4067					      repend
   4746  4068		       00		      .byte.b	0
   4745  4068					      repend
   4746  4069		       00		      .byte.b	0
   4745  4069					      repend
   4746  406a		       00		      .byte.b	0
   4745  406a					      repend
   4746  406b		       00		      .byte.b	0
   4745  406b					      repend
   4746  406c		       00		      .byte.b	0
   4745  406c					      repend
   4746  406d		       00		      .byte.b	0
   4745  406d					      repend
   4746  406e		       00		      .byte.b	0
   4745  406e					      repend
   4746  406f		       00		      .byte.b	0
   4745  406f					      repend
   4746  4070		       00		      .byte.b	0
   4745  4070					      repend
   4746  4071		       00		      .byte.b	0
   4745  4071					      repend
   4746  4072		       00		      .byte.b	0
   4745  4072					      repend
   4746  4073		       00		      .byte.b	0
   4745  4073					      repend
   4746  4074		       00		      .byte.b	0
   4745  4074					      repend
   4746  4075		       00		      .byte.b	0
   4745  4075					      repend
   4746  4076		       00		      .byte.b	0
   4745  4076					      repend
   4746  4077		       00		      .byte.b	0
   4745  4077					      repend
   4746  4078		       00		      .byte.b	0
   4745  4078					      repend
   4746  4079		       00		      .byte.b	0
   4745  4079					      repend
   4746  407a		       00		      .byte.b	0
   4745  407a					      repend
   4746  407b		       00		      .byte.b	0
   4745  407b					      repend
   4746  407c		       00		      .byte.b	0
   4745  407c					      repend
   4746  407d		       00		      .byte.b	0
   4745  407d					      repend
   4746  407e		       00		      .byte.b	0
   4745  407e					      repend
   4746  407f		       00		      .byte.b	0
   4745  407f					      repend
   4746  4080		       00		      .byte.b	0
   4747  4081					      repend
   4748  4081				   .L0260		;  temp1 = temp1
   4749  4081
   4750  4081		       a5 cb		      LDA	temp1
   4751  4083		       85 cb		      STA	temp1
   4752  4085				   .
   4753  4085							; 
   4754  4085
   4755  4085				   .L0261		;  bank 5
   4756  4085
   4757  4085					      if	ECHO4
      3919 bytes of ROM space left in bank 4
   4758  4085					      echo	"    ",[(start_bank4 - *)]d , "bytes of ROM space left in bank 4")
   4759  4085					      endif
   4760  4085		       00 01	   ECHO4      =	1
   4761  4fd4					      ORG	$4FF4-bscode_length
   4762  4fd4					      RORG	$7FF4-bscode_length
   4763  4fd4		       a2 ff	   start_bank4 ldx	#$ff
   4764  4fd6					      ifconst	FASTFETCH	; using DPC+
   4765  4fd6		       8e 58 10 	      stx	FASTFETCH
   4766  4fd9					      endif
   4767  4fd9		       9a		      txs
   4768  4fda				  -	      if	bankswitch == 64
   4769  4fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4770  4fda					      else
   4771  4fda		       a9 18		      lda	#>(start-1)
   4772  4fdc					      endif
   4773  4fdc		       48		      pha
   4774  4fdd		       a9 e3		      lda	#<(start-1)
   4775  4fdf		       48		      pha
   4776  4fe0		       48		      pha
   4777  4fe1		       8a		      txa
   4778  4fe2		       48		      pha
   4779  4fe3		       ba		      tsx
   4780  4fe4					      if	bankswitch != 64
   4781  4fe4		       b5 04		      lda	4,x	; get high byte of return address
   4782  4fe6		       2a		      rol
   4783  4fe7		       2a		      rol
   4784  4fe8		       2a		      rol
   4785  4fe9		       2a		      rol
   4786  4fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4787  4fec		       aa		      tax
   4788  4fed		       e8		      inx
   4789  4fee				  -	      else
   4790  4fee				  -	      lda	4,x	; get high byte of return address
   4791  4fee				  -	      tay
   4792  4fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4793  4fee				  -	      sta	4,x
   4794  4fee				  -	      tya
   4795  4fee				  -	      lsr
   4796  4fee				  -	      lsr
   4797  4fee				  -	      lsr
   4798  4fee				  -	      lsr
   4799  4fee				  -	      tax
   4800  4fee				  -	      inx
   4801  4fee					      endif
   4802  4fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4803  4ff1		       68		      pla
   4804  4ff2		       aa		      tax
   4805  4ff3		       68		      pla
   4806  4ff4		       60		      rts
   4807  4ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4808  4ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4809  4ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4810  4ff5					      endif
   4811  4ffc					      ORG	$4FFC
   4812  4ffc					      RORG	$7FFC
   4813  4ffc		       d4 7f		      .word.w	(start_bank4 & $ffff)
   4814  4ffe		       d4 7f		      .word.w	(start_bank4 & $ffff)
   4815  5000					      ORG	$5000
   4816  5000					      RORG	$9000
   4817  5000					      repeat	129
   4818  5000		       00		      .byte.b	0
   4817  5000					      repend
   4818  5001		       00		      .byte.b	0
   4817  5001					      repend
   4818  5002		       00		      .byte.b	0
   4817  5002					      repend
   4818  5003		       00		      .byte.b	0
   4817  5003					      repend
   4818  5004		       00		      .byte.b	0
   4817  5004					      repend
   4818  5005		       00		      .byte.b	0
   4817  5005					      repend
   4818  5006		       00		      .byte.b	0
   4817  5006					      repend
   4818  5007		       00		      .byte.b	0
   4817  5007					      repend
   4818  5008		       00		      .byte.b	0
   4817  5008					      repend
   4818  5009		       00		      .byte.b	0
   4817  5009					      repend
   4818  500a		       00		      .byte.b	0
   4817  500a					      repend
   4818  500b		       00		      .byte.b	0
   4817  500b					      repend
   4818  500c		       00		      .byte.b	0
   4817  500c					      repend
   4818  500d		       00		      .byte.b	0
   4817  500d					      repend
   4818  500e		       00		      .byte.b	0
   4817  500e					      repend
   4818  500f		       00		      .byte.b	0
   4817  500f					      repend
   4818  5010		       00		      .byte.b	0
   4817  5010					      repend
   4818  5011		       00		      .byte.b	0
   4817  5011					      repend
   4818  5012		       00		      .byte.b	0
   4817  5012					      repend
   4818  5013		       00		      .byte.b	0
   4817  5013					      repend
   4818  5014		       00		      .byte.b	0
   4817  5014					      repend
   4818  5015		       00		      .byte.b	0
   4817  5015					      repend
   4818  5016		       00		      .byte.b	0
   4817  5016					      repend
   4818  5017		       00		      .byte.b	0
   4817  5017					      repend
   4818  5018		       00		      .byte.b	0
   4817  5018					      repend
   4818  5019		       00		      .byte.b	0
   4817  5019					      repend
   4818  501a		       00		      .byte.b	0
   4817  501a					      repend
   4818  501b		       00		      .byte.b	0
   4817  501b					      repend
   4818  501c		       00		      .byte.b	0
   4817  501c					      repend
   4818  501d		       00		      .byte.b	0
   4817  501d					      repend
   4818  501e		       00		      .byte.b	0
   4817  501e					      repend
   4818  501f		       00		      .byte.b	0
   4817  501f					      repend
   4818  5020		       00		      .byte.b	0
   4817  5020					      repend
   4818  5021		       00		      .byte.b	0
   4817  5021					      repend
   4818  5022		       00		      .byte.b	0
   4817  5022					      repend
   4818  5023		       00		      .byte.b	0
   4817  5023					      repend
   4818  5024		       00		      .byte.b	0
   4817  5024					      repend
   4818  5025		       00		      .byte.b	0
   4817  5025					      repend
   4818  5026		       00		      .byte.b	0
   4817  5026					      repend
   4818  5027		       00		      .byte.b	0
   4817  5027					      repend
   4818  5028		       00		      .byte.b	0
   4817  5028					      repend
   4818  5029		       00		      .byte.b	0
   4817  5029					      repend
   4818  502a		       00		      .byte.b	0
   4817  502a					      repend
   4818  502b		       00		      .byte.b	0
   4817  502b					      repend
   4818  502c		       00		      .byte.b	0
   4817  502c					      repend
   4818  502d		       00		      .byte.b	0
   4817  502d					      repend
   4818  502e		       00		      .byte.b	0
   4817  502e					      repend
   4818  502f		       00		      .byte.b	0
   4817  502f					      repend
   4818  5030		       00		      .byte.b	0
   4817  5030					      repend
   4818  5031		       00		      .byte.b	0
   4817  5031					      repend
   4818  5032		       00		      .byte.b	0
   4817  5032					      repend
   4818  5033		       00		      .byte.b	0
   4817  5033					      repend
   4818  5034		       00		      .byte.b	0
   4817  5034					      repend
   4818  5035		       00		      .byte.b	0
   4817  5035					      repend
   4818  5036		       00		      .byte.b	0
   4817  5036					      repend
   4818  5037		       00		      .byte.b	0
   4817  5037					      repend
   4818  5038		       00		      .byte.b	0
   4817  5038					      repend
   4818  5039		       00		      .byte.b	0
   4817  5039					      repend
   4818  503a		       00		      .byte.b	0
   4817  503a					      repend
   4818  503b		       00		      .byte.b	0
   4817  503b					      repend
   4818  503c		       00		      .byte.b	0
   4817  503c					      repend
   4818  503d		       00		      .byte.b	0
   4817  503d					      repend
   4818  503e		       00		      .byte.b	0
   4817  503e					      repend
   4818  503f		       00		      .byte.b	0
   4817  503f					      repend
   4818  5040		       00		      .byte.b	0
   4817  5040					      repend
   4818  5041		       00		      .byte.b	0
   4817  5041					      repend
   4818  5042		       00		      .byte.b	0
   4817  5042					      repend
   4818  5043		       00		      .byte.b	0
   4817  5043					      repend
   4818  5044		       00		      .byte.b	0
   4817  5044					      repend
   4818  5045		       00		      .byte.b	0
   4817  5045					      repend
   4818  5046		       00		      .byte.b	0
   4817  5046					      repend
   4818  5047		       00		      .byte.b	0
   4817  5047					      repend
   4818  5048		       00		      .byte.b	0
   4817  5048					      repend
   4818  5049		       00		      .byte.b	0
   4817  5049					      repend
   4818  504a		       00		      .byte.b	0
   4817  504a					      repend
   4818  504b		       00		      .byte.b	0
   4817  504b					      repend
   4818  504c		       00		      .byte.b	0
   4817  504c					      repend
   4818  504d		       00		      .byte.b	0
   4817  504d					      repend
   4818  504e		       00		      .byte.b	0
   4817  504e					      repend
   4818  504f		       00		      .byte.b	0
   4817  504f					      repend
   4818  5050		       00		      .byte.b	0
   4817  5050					      repend
   4818  5051		       00		      .byte.b	0
   4817  5051					      repend
   4818  5052		       00		      .byte.b	0
   4817  5052					      repend
   4818  5053		       00		      .byte.b	0
   4817  5053					      repend
   4818  5054		       00		      .byte.b	0
   4817  5054					      repend
   4818  5055		       00		      .byte.b	0
   4817  5055					      repend
   4818  5056		       00		      .byte.b	0
   4817  5056					      repend
   4818  5057		       00		      .byte.b	0
   4817  5057					      repend
   4818  5058		       00		      .byte.b	0
   4817  5058					      repend
   4818  5059		       00		      .byte.b	0
   4817  5059					      repend
   4818  505a		       00		      .byte.b	0
   4817  505a					      repend
   4818  505b		       00		      .byte.b	0
   4817  505b					      repend
   4818  505c		       00		      .byte.b	0
   4817  505c					      repend
   4818  505d		       00		      .byte.b	0
   4817  505d					      repend
   4818  505e		       00		      .byte.b	0
   4817  505e					      repend
   4818  505f		       00		      .byte.b	0
   4817  505f					      repend
   4818  5060		       00		      .byte.b	0
   4817  5060					      repend
   4818  5061		       00		      .byte.b	0
   4817  5061					      repend
   4818  5062		       00		      .byte.b	0
   4817  5062					      repend
   4818  5063		       00		      .byte.b	0
   4817  5063					      repend
   4818  5064		       00		      .byte.b	0
   4817  5064					      repend
   4818  5065		       00		      .byte.b	0
   4817  5065					      repend
   4818  5066		       00		      .byte.b	0
   4817  5066					      repend
   4818  5067		       00		      .byte.b	0
   4817  5067					      repend
   4818  5068		       00		      .byte.b	0
   4817  5068					      repend
   4818  5069		       00		      .byte.b	0
   4817  5069					      repend
   4818  506a		       00		      .byte.b	0
   4817  506a					      repend
   4818  506b		       00		      .byte.b	0
   4817  506b					      repend
   4818  506c		       00		      .byte.b	0
   4817  506c					      repend
   4818  506d		       00		      .byte.b	0
   4817  506d					      repend
   4818  506e		       00		      .byte.b	0
   4817  506e					      repend
   4818  506f		       00		      .byte.b	0
   4817  506f					      repend
   4818  5070		       00		      .byte.b	0
   4817  5070					      repend
   4818  5071		       00		      .byte.b	0
   4817  5071					      repend
   4818  5072		       00		      .byte.b	0
   4817  5072					      repend
   4818  5073		       00		      .byte.b	0
   4817  5073					      repend
   4818  5074		       00		      .byte.b	0
   4817  5074					      repend
   4818  5075		       00		      .byte.b	0
   4817  5075					      repend
   4818  5076		       00		      .byte.b	0
   4817  5076					      repend
   4818  5077		       00		      .byte.b	0
   4817  5077					      repend
   4818  5078		       00		      .byte.b	0
   4817  5078					      repend
   4818  5079		       00		      .byte.b	0
   4817  5079					      repend
   4818  507a		       00		      .byte.b	0
   4817  507a					      repend
   4818  507b		       00		      .byte.b	0
   4817  507b					      repend
   4818  507c		       00		      .byte.b	0
   4817  507c					      repend
   4818  507d		       00		      .byte.b	0
   4817  507d					      repend
   4818  507e		       00		      .byte.b	0
   4817  507e					      repend
   4818  507f		       00		      .byte.b	0
   4817  507f					      repend
   4818  5080		       00		      .byte.b	0
   4819  5081					      repend
   4820  5081				   .L0262		;  temp1 = temp1
   4821  5081
   4822  5081		       a5 cb		      LDA	temp1
   4823  5083		       85 cb		      STA	temp1
   4824  5085				   .
   4825  5085							; 
   4826  5085
   4827  5085				   .L0263		;  bank 6
   4828  5085
   4829  5085					      if	ECHO5
      3919 bytes of ROM space left in bank 5
   4830  5085					      echo	"    ",[(start_bank5 - *)]d , "bytes of ROM space left in bank 5")
   4831  5085					      endif
   4832  5085		       00 01	   ECHO5      =	1
   4833  5fd4					      ORG	$5FF4-bscode_length
   4834  5fd4					      RORG	$9FF4-bscode_length
   4835  5fd4		       a2 ff	   start_bank5 ldx	#$ff
   4836  5fd6					      ifconst	FASTFETCH	; using DPC+
   4837  5fd6		       8e 58 10 	      stx	FASTFETCH
   4838  5fd9					      endif
   4839  5fd9		       9a		      txs
   4840  5fda				  -	      if	bankswitch == 64
   4841  5fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4842  5fda					      else
   4843  5fda		       a9 18		      lda	#>(start-1)
   4844  5fdc					      endif
   4845  5fdc		       48		      pha
   4846  5fdd		       a9 e3		      lda	#<(start-1)
   4847  5fdf		       48		      pha
   4848  5fe0		       48		      pha
   4849  5fe1		       8a		      txa
   4850  5fe2		       48		      pha
   4851  5fe3		       ba		      tsx
   4852  5fe4					      if	bankswitch != 64
   4853  5fe4		       b5 04		      lda	4,x	; get high byte of return address
   4854  5fe6		       2a		      rol
   4855  5fe7		       2a		      rol
   4856  5fe8		       2a		      rol
   4857  5fe9		       2a		      rol
   4858  5fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4859  5fec		       aa		      tax
   4860  5fed		       e8		      inx
   4861  5fee				  -	      else
   4862  5fee				  -	      lda	4,x	; get high byte of return address
   4863  5fee				  -	      tay
   4864  5fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4865  5fee				  -	      sta	4,x
   4866  5fee				  -	      tya
   4867  5fee				  -	      lsr
   4868  5fee				  -	      lsr
   4869  5fee				  -	      lsr
   4870  5fee				  -	      lsr
   4871  5fee				  -	      tax
   4872  5fee				  -	      inx
   4873  5fee					      endif
   4874  5fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4875  5ff1		       68		      pla
   4876  5ff2		       aa		      tax
   4877  5ff3		       68		      pla
   4878  5ff4		       60		      rts
   4879  5ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4880  5ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4881  5ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4882  5ff5					      endif
   4883  5ffc					      ORG	$5FFC
   4884  5ffc					      RORG	$9FFC
   4885  5ffc		       d4 9f		      .word.w	(start_bank5 & $ffff)
   4886  5ffe		       d4 9f		      .word.w	(start_bank5 & $ffff)
   4887  6000					      ORG	$6000
   4888  6000					      RORG	$B000
   4889  6000					      repeat	129
   4890  6000		       00		      .byte.b	0
   4889  6000					      repend
   4890  6001		       00		      .byte.b	0
   4889  6001					      repend
   4890  6002		       00		      .byte.b	0
   4889  6002					      repend
   4890  6003		       00		      .byte.b	0
   4889  6003					      repend
   4890  6004		       00		      .byte.b	0
   4889  6004					      repend
   4890  6005		       00		      .byte.b	0
   4889  6005					      repend
   4890  6006		       00		      .byte.b	0
   4889  6006					      repend
   4890  6007		       00		      .byte.b	0
   4889  6007					      repend
   4890  6008		       00		      .byte.b	0
   4889  6008					      repend
   4890  6009		       00		      .byte.b	0
   4889  6009					      repend
   4890  600a		       00		      .byte.b	0
   4889  600a					      repend
   4890  600b		       00		      .byte.b	0
   4889  600b					      repend
   4890  600c		       00		      .byte.b	0
   4889  600c					      repend
   4890  600d		       00		      .byte.b	0
   4889  600d					      repend
   4890  600e		       00		      .byte.b	0
   4889  600e					      repend
   4890  600f		       00		      .byte.b	0
   4889  600f					      repend
   4890  6010		       00		      .byte.b	0
   4889  6010					      repend
   4890  6011		       00		      .byte.b	0
   4889  6011					      repend
   4890  6012		       00		      .byte.b	0
   4889  6012					      repend
   4890  6013		       00		      .byte.b	0
   4889  6013					      repend
   4890  6014		       00		      .byte.b	0
   4889  6014					      repend
   4890  6015		       00		      .byte.b	0
   4889  6015					      repend
   4890  6016		       00		      .byte.b	0
   4889  6016					      repend
   4890  6017		       00		      .byte.b	0
   4889  6017					      repend
   4890  6018		       00		      .byte.b	0
   4889  6018					      repend
   4890  6019		       00		      .byte.b	0
   4889  6019					      repend
   4890  601a		       00		      .byte.b	0
   4889  601a					      repend
   4890  601b		       00		      .byte.b	0
   4889  601b					      repend
   4890  601c		       00		      .byte.b	0
   4889  601c					      repend
   4890  601d		       00		      .byte.b	0
   4889  601d					      repend
   4890  601e		       00		      .byte.b	0
   4889  601e					      repend
   4890  601f		       00		      .byte.b	0
   4889  601f					      repend
   4890  6020		       00		      .byte.b	0
   4889  6020					      repend
   4890  6021		       00		      .byte.b	0
   4889  6021					      repend
   4890  6022		       00		      .byte.b	0
   4889  6022					      repend
   4890  6023		       00		      .byte.b	0
   4889  6023					      repend
   4890  6024		       00		      .byte.b	0
   4889  6024					      repend
   4890  6025		       00		      .byte.b	0
   4889  6025					      repend
   4890  6026		       00		      .byte.b	0
   4889  6026					      repend
   4890  6027		       00		      .byte.b	0
   4889  6027					      repend
   4890  6028		       00		      .byte.b	0
   4889  6028					      repend
   4890  6029		       00		      .byte.b	0
   4889  6029					      repend
   4890  602a		       00		      .byte.b	0
   4889  602a					      repend
   4890  602b		       00		      .byte.b	0
   4889  602b					      repend
   4890  602c		       00		      .byte.b	0
   4889  602c					      repend
   4890  602d		       00		      .byte.b	0
   4889  602d					      repend
   4890  602e		       00		      .byte.b	0
   4889  602e					      repend
   4890  602f		       00		      .byte.b	0
   4889  602f					      repend
   4890  6030		       00		      .byte.b	0
   4889  6030					      repend
   4890  6031		       00		      .byte.b	0
   4889  6031					      repend
   4890  6032		       00		      .byte.b	0
   4889  6032					      repend
   4890  6033		       00		      .byte.b	0
   4889  6033					      repend
   4890  6034		       00		      .byte.b	0
   4889  6034					      repend
   4890  6035		       00		      .byte.b	0
   4889  6035					      repend
   4890  6036		       00		      .byte.b	0
   4889  6036					      repend
   4890  6037		       00		      .byte.b	0
   4889  6037					      repend
   4890  6038		       00		      .byte.b	0
   4889  6038					      repend
   4890  6039		       00		      .byte.b	0
   4889  6039					      repend
   4890  603a		       00		      .byte.b	0
   4889  603a					      repend
   4890  603b		       00		      .byte.b	0
   4889  603b					      repend
   4890  603c		       00		      .byte.b	0
   4889  603c					      repend
   4890  603d		       00		      .byte.b	0
   4889  603d					      repend
   4890  603e		       00		      .byte.b	0
   4889  603e					      repend
   4890  603f		       00		      .byte.b	0
   4889  603f					      repend
   4890  6040		       00		      .byte.b	0
   4889  6040					      repend
   4890  6041		       00		      .byte.b	0
   4889  6041					      repend
   4890  6042		       00		      .byte.b	0
   4889  6042					      repend
   4890  6043		       00		      .byte.b	0
   4889  6043					      repend
   4890  6044		       00		      .byte.b	0
   4889  6044					      repend
   4890  6045		       00		      .byte.b	0
   4889  6045					      repend
   4890  6046		       00		      .byte.b	0
   4889  6046					      repend
   4890  6047		       00		      .byte.b	0
   4889  6047					      repend
   4890  6048		       00		      .byte.b	0
   4889  6048					      repend
   4890  6049		       00		      .byte.b	0
   4889  6049					      repend
   4890  604a		       00		      .byte.b	0
   4889  604a					      repend
   4890  604b		       00		      .byte.b	0
   4889  604b					      repend
   4890  604c		       00		      .byte.b	0
   4889  604c					      repend
   4890  604d		       00		      .byte.b	0
   4889  604d					      repend
   4890  604e		       00		      .byte.b	0
   4889  604e					      repend
   4890  604f		       00		      .byte.b	0
   4889  604f					      repend
   4890  6050		       00		      .byte.b	0
   4889  6050					      repend
   4890  6051		       00		      .byte.b	0
   4889  6051					      repend
   4890  6052		       00		      .byte.b	0
   4889  6052					      repend
   4890  6053		       00		      .byte.b	0
   4889  6053					      repend
   4890  6054		       00		      .byte.b	0
   4889  6054					      repend
   4890  6055		       00		      .byte.b	0
   4889  6055					      repend
   4890  6056		       00		      .byte.b	0
   4889  6056					      repend
   4890  6057		       00		      .byte.b	0
   4889  6057					      repend
   4890  6058		       00		      .byte.b	0
   4889  6058					      repend
   4890  6059		       00		      .byte.b	0
   4889  6059					      repend
   4890  605a		       00		      .byte.b	0
   4889  605a					      repend
   4890  605b		       00		      .byte.b	0
   4889  605b					      repend
   4890  605c		       00		      .byte.b	0
   4889  605c					      repend
   4890  605d		       00		      .byte.b	0
   4889  605d					      repend
   4890  605e		       00		      .byte.b	0
   4889  605e					      repend
   4890  605f		       00		      .byte.b	0
   4889  605f					      repend
   4890  6060		       00		      .byte.b	0
   4889  6060					      repend
   4890  6061		       00		      .byte.b	0
   4889  6061					      repend
   4890  6062		       00		      .byte.b	0
   4889  6062					      repend
   4890  6063		       00		      .byte.b	0
   4889  6063					      repend
   4890  6064		       00		      .byte.b	0
   4889  6064					      repend
   4890  6065		       00		      .byte.b	0
   4889  6065					      repend
   4890  6066		       00		      .byte.b	0
   4889  6066					      repend
   4890  6067		       00		      .byte.b	0
   4889  6067					      repend
   4890  6068		       00		      .byte.b	0
   4889  6068					      repend
   4890  6069		       00		      .byte.b	0
   4889  6069					      repend
   4890  606a		       00		      .byte.b	0
   4889  606a					      repend
   4890  606b		       00		      .byte.b	0
   4889  606b					      repend
   4890  606c		       00		      .byte.b	0
   4889  606c					      repend
   4890  606d		       00		      .byte.b	0
   4889  606d					      repend
   4890  606e		       00		      .byte.b	0
   4889  606e					      repend
   4890  606f		       00		      .byte.b	0
   4889  606f					      repend
   4890  6070		       00		      .byte.b	0
   4889  6070					      repend
   4890  6071		       00		      .byte.b	0
   4889  6071					      repend
   4890  6072		       00		      .byte.b	0
   4889  6072					      repend
   4890  6073		       00		      .byte.b	0
   4889  6073					      repend
   4890  6074		       00		      .byte.b	0
   4889  6074					      repend
   4890  6075		       00		      .byte.b	0
   4889  6075					      repend
   4890  6076		       00		      .byte.b	0
   4889  6076					      repend
   4890  6077		       00		      .byte.b	0
   4889  6077					      repend
   4890  6078		       00		      .byte.b	0
   4889  6078					      repend
   4890  6079		       00		      .byte.b	0
   4889  6079					      repend
   4890  607a		       00		      .byte.b	0
   4889  607a					      repend
   4890  607b		       00		      .byte.b	0
   4889  607b					      repend
   4890  607c		       00		      .byte.b	0
   4889  607c					      repend
   4890  607d		       00		      .byte.b	0
   4889  607d					      repend
   4890  607e		       00		      .byte.b	0
   4889  607e					      repend
   4890  607f		       00		      .byte.b	0
   4889  607f					      repend
   4890  6080		       00		      .byte.b	0
   4891  6081					      repend
   4892  6081				   .L0264		;  temp1 = temp1
   4893  6081
   4894  6081		       a5 cb		      LDA	temp1
   4895  6083		       85 cb		      STA	temp1
   4896  6085				   .
   4897  6085							; 
   4898  6085
   4899  6085				   .L0265		;  bank 7
   4900  6085
   4901  6085					      if	ECHO6
      3919 bytes of ROM space left in bank 6
   4902  6085					      echo	"    ",[(start_bank6 - *)]d , "bytes of ROM space left in bank 6")
   4903  6085					      endif
   4904  6085		       00 01	   ECHO6      =	1
   4905  6fd4					      ORG	$6FF4-bscode_length
   4906  6fd4					      RORG	$BFF4-bscode_length
   4907  6fd4		       a2 ff	   start_bank6 ldx	#$ff
   4908  6fd6					      ifconst	FASTFETCH	; using DPC+
   4909  6fd6		       8e 58 10 	      stx	FASTFETCH
   4910  6fd9					      endif
   4911  6fd9		       9a		      txs
   4912  6fda				  -	      if	bankswitch == 64
   4913  6fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   4914  6fda					      else
   4915  6fda		       a9 18		      lda	#>(start-1)
   4916  6fdc					      endif
   4917  6fdc		       48		      pha
   4918  6fdd		       a9 e3		      lda	#<(start-1)
   4919  6fdf		       48		      pha
   4920  6fe0		       48		      pha
   4921  6fe1		       8a		      txa
   4922  6fe2		       48		      pha
   4923  6fe3		       ba		      tsx
   4924  6fe4					      if	bankswitch != 64
   4925  6fe4		       b5 04		      lda	4,x	; get high byte of return address
   4926  6fe6		       2a		      rol
   4927  6fe7		       2a		      rol
   4928  6fe8		       2a		      rol
   4929  6fe9		       2a		      rol
   4930  6fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   4931  6fec		       aa		      tax
   4932  6fed		       e8		      inx
   4933  6fee				  -	      else
   4934  6fee				  -	      lda	4,x	; get high byte of return address
   4935  6fee				  -	      tay
   4936  6fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   4937  6fee				  -	      sta	4,x
   4938  6fee				  -	      tya
   4939  6fee				  -	      lsr
   4940  6fee				  -	      lsr
   4941  6fee				  -	      lsr
   4942  6fee				  -	      lsr
   4943  6fee				  -	      tax
   4944  6fee				  -	      inx
   4945  6fee					      endif
   4946  6fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   4947  6ff1		       68		      pla
   4948  6ff2		       aa		      tax
   4949  6ff3		       68		      pla
   4950  6ff4		       60		      rts
   4951  6ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   4952  6ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   4953  6ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   4954  6ff5					      endif
   4955  6ffc					      ORG	$6FFC
   4956  6ffc					      RORG	$BFFC
   4957  6ffc		       d4 bf		      .word.w	(start_bank6 & $ffff)
   4958  6ffe		       d4 bf		      .word.w	(start_bank6 & $ffff)
   4959  7000					      ORG	$7000
   4960  7000					      RORG	$D000
   4961  7000					      repeat	129
   4962  7000		       00		      .byte.b	0
   4961  7000					      repend
   4962  7001		       00		      .byte.b	0
   4961  7001					      repend
   4962  7002		       00		      .byte.b	0
   4961  7002					      repend
   4962  7003		       00		      .byte.b	0
   4961  7003					      repend
   4962  7004		       00		      .byte.b	0
   4961  7004					      repend
   4962  7005		       00		      .byte.b	0
   4961  7005					      repend
   4962  7006		       00		      .byte.b	0
   4961  7006					      repend
   4962  7007		       00		      .byte.b	0
   4961  7007					      repend
   4962  7008		       00		      .byte.b	0
   4961  7008					      repend
   4962  7009		       00		      .byte.b	0
   4961  7009					      repend
   4962  700a		       00		      .byte.b	0
   4961  700a					      repend
   4962  700b		       00		      .byte.b	0
   4961  700b					      repend
   4962  700c		       00		      .byte.b	0
   4961  700c					      repend
   4962  700d		       00		      .byte.b	0
   4961  700d					      repend
   4962  700e		       00		      .byte.b	0
   4961  700e					      repend
   4962  700f		       00		      .byte.b	0
   4961  700f					      repend
   4962  7010		       00		      .byte.b	0
   4961  7010					      repend
   4962  7011		       00		      .byte.b	0
   4961  7011					      repend
   4962  7012		       00		      .byte.b	0
   4961  7012					      repend
   4962  7013		       00		      .byte.b	0
   4961  7013					      repend
   4962  7014		       00		      .byte.b	0
   4961  7014					      repend
   4962  7015		       00		      .byte.b	0
   4961  7015					      repend
   4962  7016		       00		      .byte.b	0
   4961  7016					      repend
   4962  7017		       00		      .byte.b	0
   4961  7017					      repend
   4962  7018		       00		      .byte.b	0
   4961  7018					      repend
   4962  7019		       00		      .byte.b	0
   4961  7019					      repend
   4962  701a		       00		      .byte.b	0
   4961  701a					      repend
   4962  701b		       00		      .byte.b	0
   4961  701b					      repend
   4962  701c		       00		      .byte.b	0
   4961  701c					      repend
   4962  701d		       00		      .byte.b	0
   4961  701d					      repend
   4962  701e		       00		      .byte.b	0
   4961  701e					      repend
   4962  701f		       00		      .byte.b	0
   4961  701f					      repend
   4962  7020		       00		      .byte.b	0
   4961  7020					      repend
   4962  7021		       00		      .byte.b	0
   4961  7021					      repend
   4962  7022		       00		      .byte.b	0
   4961  7022					      repend
   4962  7023		       00		      .byte.b	0
   4961  7023					      repend
   4962  7024		       00		      .byte.b	0
   4961  7024					      repend
   4962  7025		       00		      .byte.b	0
   4961  7025					      repend
   4962  7026		       00		      .byte.b	0
   4961  7026					      repend
   4962  7027		       00		      .byte.b	0
   4961  7027					      repend
   4962  7028		       00		      .byte.b	0
   4961  7028					      repend
   4962  7029		       00		      .byte.b	0
   4961  7029					      repend
   4962  702a		       00		      .byte.b	0
   4961  702a					      repend
   4962  702b		       00		      .byte.b	0
   4961  702b					      repend
   4962  702c		       00		      .byte.b	0
   4961  702c					      repend
   4962  702d		       00		      .byte.b	0
   4961  702d					      repend
   4962  702e		       00		      .byte.b	0
   4961  702e					      repend
   4962  702f		       00		      .byte.b	0
   4961  702f					      repend
   4962  7030		       00		      .byte.b	0
   4961  7030					      repend
   4962  7031		       00		      .byte.b	0
   4961  7031					      repend
   4962  7032		       00		      .byte.b	0
   4961  7032					      repend
   4962  7033		       00		      .byte.b	0
   4961  7033					      repend
   4962  7034		       00		      .byte.b	0
   4961  7034					      repend
   4962  7035		       00		      .byte.b	0
   4961  7035					      repend
   4962  7036		       00		      .byte.b	0
   4961  7036					      repend
   4962  7037		       00		      .byte.b	0
   4961  7037					      repend
   4962  7038		       00		      .byte.b	0
   4961  7038					      repend
   4962  7039		       00		      .byte.b	0
   4961  7039					      repend
   4962  703a		       00		      .byte.b	0
   4961  703a					      repend
   4962  703b		       00		      .byte.b	0
   4961  703b					      repend
   4962  703c		       00		      .byte.b	0
   4961  703c					      repend
   4962  703d		       00		      .byte.b	0
   4961  703d					      repend
   4962  703e		       00		      .byte.b	0
   4961  703e					      repend
   4962  703f		       00		      .byte.b	0
   4961  703f					      repend
   4962  7040		       00		      .byte.b	0
   4961  7040					      repend
   4962  7041		       00		      .byte.b	0
   4961  7041					      repend
   4962  7042		       00		      .byte.b	0
   4961  7042					      repend
   4962  7043		       00		      .byte.b	0
   4961  7043					      repend
   4962  7044		       00		      .byte.b	0
   4961  7044					      repend
   4962  7045		       00		      .byte.b	0
   4961  7045					      repend
   4962  7046		       00		      .byte.b	0
   4961  7046					      repend
   4962  7047		       00		      .byte.b	0
   4961  7047					      repend
   4962  7048		       00		      .byte.b	0
   4961  7048					      repend
   4962  7049		       00		      .byte.b	0
   4961  7049					      repend
   4962  704a		       00		      .byte.b	0
   4961  704a					      repend
   4962  704b		       00		      .byte.b	0
   4961  704b					      repend
   4962  704c		       00		      .byte.b	0
   4961  704c					      repend
   4962  704d		       00		      .byte.b	0
   4961  704d					      repend
   4962  704e		       00		      .byte.b	0
   4961  704e					      repend
   4962  704f		       00		      .byte.b	0
   4961  704f					      repend
   4962  7050		       00		      .byte.b	0
   4961  7050					      repend
   4962  7051		       00		      .byte.b	0
   4961  7051					      repend
   4962  7052		       00		      .byte.b	0
   4961  7052					      repend
   4962  7053		       00		      .byte.b	0
   4961  7053					      repend
   4962  7054		       00		      .byte.b	0
   4961  7054					      repend
   4962  7055		       00		      .byte.b	0
   4961  7055					      repend
   4962  7056		       00		      .byte.b	0
   4961  7056					      repend
   4962  7057		       00		      .byte.b	0
   4961  7057					      repend
   4962  7058		       00		      .byte.b	0
   4961  7058					      repend
   4962  7059		       00		      .byte.b	0
   4961  7059					      repend
   4962  705a		       00		      .byte.b	0
   4961  705a					      repend
   4962  705b		       00		      .byte.b	0
   4961  705b					      repend
   4962  705c		       00		      .byte.b	0
   4961  705c					      repend
   4962  705d		       00		      .byte.b	0
   4961  705d					      repend
   4962  705e		       00		      .byte.b	0
   4961  705e					      repend
   4962  705f		       00		      .byte.b	0
   4961  705f					      repend
   4962  7060		       00		      .byte.b	0
   4961  7060					      repend
   4962  7061		       00		      .byte.b	0
   4961  7061					      repend
   4962  7062		       00		      .byte.b	0
   4961  7062					      repend
   4962  7063		       00		      .byte.b	0
   4961  7063					      repend
   4962  7064		       00		      .byte.b	0
   4961  7064					      repend
   4962  7065		       00		      .byte.b	0
   4961  7065					      repend
   4962  7066		       00		      .byte.b	0
   4961  7066					      repend
   4962  7067		       00		      .byte.b	0
   4961  7067					      repend
   4962  7068		       00		      .byte.b	0
   4961  7068					      repend
   4962  7069		       00		      .byte.b	0
   4961  7069					      repend
   4962  706a		       00		      .byte.b	0
   4961  706a					      repend
   4962  706b		       00		      .byte.b	0
   4961  706b					      repend
   4962  706c		       00		      .byte.b	0
   4961  706c					      repend
   4962  706d		       00		      .byte.b	0
   4961  706d					      repend
   4962  706e		       00		      .byte.b	0
   4961  706e					      repend
   4962  706f		       00		      .byte.b	0
   4961  706f					      repend
   4962  7070		       00		      .byte.b	0
   4961  7070					      repend
   4962  7071		       00		      .byte.b	0
   4961  7071					      repend
   4962  7072		       00		      .byte.b	0
   4961  7072					      repend
   4962  7073		       00		      .byte.b	0
   4961  7073					      repend
   4962  7074		       00		      .byte.b	0
   4961  7074					      repend
   4962  7075		       00		      .byte.b	0
   4961  7075					      repend
   4962  7076		       00		      .byte.b	0
   4961  7076					      repend
   4962  7077		       00		      .byte.b	0
   4961  7077					      repend
   4962  7078		       00		      .byte.b	0
   4961  7078					      repend
   4962  7079		       00		      .byte.b	0
   4961  7079					      repend
   4962  707a		       00		      .byte.b	0
   4961  707a					      repend
   4962  707b		       00		      .byte.b	0
   4961  707b					      repend
   4962  707c		       00		      .byte.b	0
   4961  707c					      repend
   4962  707d		       00		      .byte.b	0
   4961  707d					      repend
   4962  707e		       00		      .byte.b	0
   4961  707e					      repend
   4962  707f		       00		      .byte.b	0
   4961  707f					      repend
   4962  7080		       00		      .byte.b	0
   4963  7081					      repend
   4964  7081							; Provided under the CC0 license. See the included LICENSE.txt for details.
   4965  7081
   4966  7081							;----------------------------------------
   4967  7081							; Display Data
   4968  7081							;----------------------------------------
   4969  7081							; The Display Data bank is copied into RAM when DPC+ initializes the cartridge.
   4970  7081							; This allows us to manipulate the data during run-time, but have a known
   4971  7081							; starting state when the Atari is first turned on.
   4972  7081							;
   4973  7081							; Unlike normal Atari VCS/2600 sprite definitions, the sprite data in the
   4974  7081							; Display Data bank is stored right-side-up.
   4975  7081							;
   4976  7081							;----------------------------------------
   4977  7081
   4978  7081				   Zeros32
   4979  7081		       00 84	   SOUND_OFF  =	(* & $1fff)/32
   4980  7081				   DisplayDataDigitBlank
   4981  7081		       00		      .byte.b	0	;--
   4982  7082		       00		      .byte.b	0	;--
   4983  7083		       00		      .byte.b	0	;--
   4984  7084		       00		      .byte.b	0	;--
   4985  7085		       00		      .byte.b	0	;--
   4986  7086		       00		      .byte.b	0	;--
   4987  7087		       00		      .byte.b	0	;--
   4988  7088		       00		      .byte.b	0	;--
   4989  7089
   4990  7089							;	align 32
   4991  7089							;Zeros32:
   4992  7089							;SOUND_OFF = (* & $1fff)/32
   4993  7089							;	.byte 0,0,0,0,0,0,0,0
   4994  7089		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4995  7091		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4996  7099		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   4997  70a1
   4998  70a1		       00 85	   SINE_WAVE  =	(* & $1fff)/32
   4999  70a1		       03 03 03 04*	      .byte.b	3,3,3,4,4,5,5,5
   5000  70a9		       05 05 05 05*	      .byte.b	5,5,5,5,4,4,3,3
   5001  70b1		       03 02 02 01*	      .byte.b	3,2,2,1,1,0,0,0
   5002  70b9		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,2,2
   5003  70c1
   5004  70e0		       00 00 00 00*	      align	32
   5005  70e0		       00 87	   TRIANGLE_WAVE =	(* & $1fff)/32
   5006  70e0		       00 00 01 01*	      .byte.b	0,0,1,1,1,2,2,2
   5007  70e8		       03 03 03 04*	      .byte.b	3,3,3,4,4,4,5,5
   5008  70f0		       05 05 04 04*	      .byte.b	5,5,4,4,4,3,3,3
   5009  70f8		       02 02 02 01*	      .byte.b	2,2,2,1,1,1,0,0
   5010  7100
   5011  7100					      align	32
   5012  7100		       00 88	   SAWTOOTH_WAVE =	(* & $1fff)/32
   5013  7100		       00 00 00 00*	      .byte.b	0,0,0,0,1,1,1,1
   5014  7108		       01 01 02 02*	      .byte.b	1,1,2,2,2,2,2,2
   5015  7110		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,4,4
   5016  7118		       04 04 04 04*	      .byte.b	4,4,4,4,5,5,5,5
   5017  7120
   5018  7120					      align	32
   5019  7120		       00 89	   SQUARE_WAVE_VOL5 =	(* & $1fff)/32
   5020  7120		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   5021  7128		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   5022  7130		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   5023  7138		       05 05 05 05*	      .byte.b	5,5,5,5,5,5,5,5
   5024  7140
   5025  7140					      align	32
   5026  7140		       00 8a	   SQUARE_WAVE_VOL4 =	(* & $1fff)/32
   5027  7140		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   5028  7148		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   5029  7150		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   5030  7158		       04 04 04 04*	      .byte.b	4,4,4,4,4,4,4,4
   5031  7160
   5032  7160					      align	32
   5033  7160		       00 8b	   SQUARE_WAVE_VOL3 =	(* & $1fff)/32
   5034  7160		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   5035  7168		       00 00 00 00*	      .byte.b	0,0,0,0,0,0,0,0
   5036  7170		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   5037  7178		       03 03 03 03*	      .byte.b	3,3,3,3,3,3,3,3
   5038  7180
   5039  7180					      align	32
   5040  7180		       00 8c	   NOISE_WAVE =	(* & $1fff)/32
   5041  7180		       07 01 09 0a*	      .byte.b	7, 1, 9,10, 2, 8, 8,14
   5042  7188		       03 0d 08 05*	      .byte.b	3,13, 8, 5,12, 2, 3, 7
   5043  7190		       07 01 08 04*	      .byte.b	7, 1, 8, 4,15, 1,13, 5
   5044  7198		       08 05 0b 06*	      .byte.b	8, 5,11, 6, 8, 7, 9, 2
   5045  71a0
   5046  71a0							; low and high byte of address table (for ROMdata array in C)
   5047  71a0		       51		      .byte.b	<fetcher_address_table
   5048  71a1		       0d		      .byte.b	((>fetcher_address_table) & $0f) | (((>fetcher_address_table) / 2) & $70)
   5049  71a2		       00		      .byte.b	0
   5050  71a3		       00		      .byte.b	0
   5051  71a4				   FETCHER_BEGIN
   5052  71a4		       10		      .byte.b	16
   5053  71a5		       10		      .byte.b	16
   5054  71a6		       10		      .byte.b	16
   5055  71a7		       10		      .byte.b	16	; to zero-fill on boot
   5056  71a8							;bB.asm
   5057  71a8							; bB.asm file is split here
   5058  71a8				   .L0266		;  temp1 = temp1
   5059  71a8
   5060  71a8		       a5 cb		      LDA	temp1
   5061  71aa		       85 cb		      STA	temp1
   5062  71ac				   .
   5063  71ac							; 
   5064  71ac
   5065  71ac				   .L0267		;  asm
   5066  71ac
   5067  7200		       00 00 00 00*	      align	256
   5068  7200
   5069  7200				   .L0268		;  data _scoretable2
   5070  7200
   5071  7200		       4c 23 d2 	      JMP	.skipL0268
   5072  7203				   _scoretable2
   5073  7203		       7e		      .byte.b	%01111110
   5074  7204
   5075  7204		       42		      .byte.b	%01000010
   5076  7205
   5077  7205		       42		      .byte.b	%01000010
   5078  7206
   5079  7206		       42		      .byte.b	%01000010
   5080  7207
   5081  7207		       42		      .byte.b	%01000010
   5082  7208
   5083  7208		       42		      .byte.b	%01000010
   5084  7209
   5085  7209		       42		      .byte.b	%01000010
   5086  720a
   5087  720a		       7e		      .byte.b	%01111110
   5088  720b
   5089  720b		       38		      .byte.b	%00111000
   5090  720c
   5091  720c		       08		      .byte.b	%00001000
   5092  720d
   5093  720d		       08		      .byte.b	%00001000
   5094  720e
   5095  720e		       08		      .byte.b	%00001000
   5096  720f
   5097  720f		       08		      .byte.b	%00001000
   5098  7210
   5099  7210		       08		      .byte.b	%00001000
   5100  7211
   5101  7211		       08		      .byte.b	%00001000
   5102  7212
   5103  7212		       7e		      .byte.b	%01111110
   5104  7213
   5105  7213		       7e		      .byte.b	%01111110
   5106  7214
   5107  7214		       02		      .byte.b	%00000010
   5108  7215
   5109  7215		       02		      .byte.b	%00000010
   5110  7216
   5111  7216		       7e		      .byte.b	%01111110
   5112  7217
   5113  7217		       40		      .byte.b	%01000000
   5114  7218
   5115  7218		       40		      .byte.b	%01000000
   5116  7219
   5117  7219		       40		      .byte.b	%01000000
   5118  721a
   5119  721a		       7e		      .byte.b	%01111110
   5120  721b
   5121  721b		       7e		      .byte.b	%01111110
   5122  721c
   5123  721c		       02		      .byte.b	%00000010
   5124  721d
   5125  721d		       02		      .byte.b	%00000010
   5126  721e
   5127  721e		       7e		      .byte.b	%01111110
   5128  721f
   5129  721f		       02		      .byte.b	%00000010
   5130  7220
   5131  7220		       02		      .byte.b	%00000010
   5132  7221
   5133  7221		       02		      .byte.b	%00000010
   5134  7222
   5135  7222		       7e		      .byte.b	%01111110
   5136  7223
   5137  7223				   .skipL0268
   5138  7223				   .
   5139  7223							; 
   5140  7223
   5141  7223				   .
   5142  7223							; 
   5143  7223
   5144  7223				   .
   5145  7223							; 
   5146  7223
   5147  7223				   .
   5148  7223							; 
   5149  7223
   5150  7223				   playerL074_0
   5151  7223		       00		      .byte.b	%00000000
   5152  7224		       10		      .byte.b	%00010000
   5153  7225		       38		      .byte.b	%00111000
   5154  7226		       7c		      .byte.b	%01111100
   5155  7227		       ee		      .byte.b	%11101110
   5156  7228				   playercolorL075_0
   5157  7228		       82		      .byte.b	$82
   5158  7229		       84		      .byte.b	$84
   5159  722a		       86		      .byte.b	$86
   5160  722b		       88		      .byte.b	$88
   5161  722c		       8a		      .byte.b	$8a
   5162  722d		       8c		      .byte.b	$8c
   5163  722e				   playercolorL078_2
   5164  722e		       84		      .byte.b	$84
   5165  722f		       84		      .byte.b	$84
   5166  7230		       84		      .byte.b	$84
   5167  7231		       86		      .byte.b	$86
   5168  7232		       86		      .byte.b	$86
   5169  7233		       8a		      .byte.b	$8a
   5170  7234		       8a		      .byte.b	$8a
   5171  7235		       8c		      .byte.b	$8c
   5172  7236				   playercolorL084_1
   5173  7236		       0e		      .byte.b	$0e
   5174  7237		       0e		      .byte.b	$0e
   5175  7238		       0e		      .byte.b	$0e
   5176  7239		       0e		      .byte.b	$0e
   5177  723a		       0e		      .byte.b	$0e
   5178  723b		       0e		      .byte.b	$0e
   5179  723c		       0e		      .byte.b	$0e
   5180  723d		       0e		      .byte.b	$0e
   5181  723e				   playerL0116_1
   5182  723e		       3f		      .byte.b	%111111
   5183  723f		       3f		      .byte.b	%111111
   5184  7240		       3f		      .byte.b	%111111
   5185  7241		       3f		      .byte.b	%111111
   5186  7242		       3f		      .byte.b	%111111
   5187  7243				   playercolorL0117_1
   5188  7243		       00		      .byte.b	$00
   5189  7244		       00		      .byte.b	$00
   5190  7245		       00		      .byte.b	$00
   5191  7246		       00		      .byte.b	$00
   5192  7247		       00		      .byte.b	$00
   5193  7248				   playerL0246_2
   5194  7248		       00		      .byte.b	%00000000
   5195  7249		       80		      .byte.b	%10000000
   5196  724a		       40		      .byte.b	%01000000
   5197  724b		       e0		      .byte.b	%11100000
   5198  724c		       10		      .byte.b	%00010000
   5199  724d		       f8		      .byte.b	%11111000
   5200  724e		       44		      .byte.b	%01000100
   5201  724f		       7e		      .byte.b	%01111110
   5202  7250				   playerL0249_2
   5203  7250		       01		      .byte.b	%00000001
   5204  7251		       02		      .byte.b	%00000010
   5205  7252		       04		      .byte.b	%00000100
   5206  7253		       0f		      .byte.b	%00001111
   5207  7254		       11		      .byte.b	%00010001
   5208  7255		       3f		      .byte.b	%00111111
   5209  7256		       44		      .byte.b	%01000100
   5210  7257		       fc		      .byte.b	%11111100
   5211  7258					      if	ECHOFIRST
      3452 bytes of ROM space left in graphics bank
   5212  7258					      echo	"    ",[(DPC_graphics_end - *)]d , "bytes of ROM space left in graphics bank")
   5213  7258					      endif
   5214  7258		       00 01	   ECHOFIRST  =	1
   5215  7258
   5216  7258
   5217  7258							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5218  7258
   5219  7fd4					      ORG	$7FF4-bscode_length
   5220  7fd4					      RORG	$DFF4-bscode_length
   5221  7fd4				   DPC_graphics_end
   5222  7fd4
   5223  7fd4							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5224  7fd4
   5225  7fd4							; every bank has this stuff at the same place
   5226  7fd4							; this code can switch to/from any bank at any entry point
   5227  7fd4							; and can preserve register values
   5228  7fd4							; note: lines not starting with a space are not placed in all banks
   5229  7fd4							;
   5230  7fd4							; line below tells the compiler how long this is - do not remove
   5231  7fd4							;size=32
   5232  7fd4
   5233  7fd4				   begin_bscode
   5234  7fd4		       a2 ff		      ldx	#$ff
   5235  7fd6					      ifconst	FASTFETCH	; using DPC+
   5236  7fd6		       8e 58 10 	      stx	FASTFETCH
   5237  7fd9					      endif
   5238  7fd9		       9a		      txs
   5239  7fda				  -	      if	bankswitch == 64
   5240  7fda				  -	      lda	#(((>(start-1)) & $0F) | $F0)
   5241  7fda					      else
   5242  7fda		       a9 18		      lda	#>(start-1)
   5243  7fdc					      endif
   5244  7fdc		       48		      pha
   5245  7fdd		       a9 e3		      lda	#<(start-1)
   5246  7fdf		       48		      pha
   5247  7fe0
   5248  7fe0				   BS_return
   5249  7fe0		       48		      pha
   5250  7fe1		       8a		      txa
   5251  7fe2		       48		      pha
   5252  7fe3		       ba		      tsx
   5253  7fe4
   5254  7fe4					      if	bankswitch != 64
   5255  7fe4		       b5 04		      lda	4,x	; get high byte of return address
   5256  7fe6
   5257  7fe6		       2a		      rol
   5258  7fe7		       2a		      rol
   5259  7fe8		       2a		      rol
   5260  7fe9		       2a		      rol
   5261  7fea		       29 07		      and	#bs_mask	;1 3 or 7 for F8/F6/F4
   5262  7fec		       aa		      tax
   5263  7fed		       e8		      inx
   5264  7fee				  -	      else
   5265  7fee				  -	      lda	4,x	; get high byte of return address
   5266  7fee				  -	      tay
   5267  7fee				  -	      ora	#$10	; change our bank nibble into a valid rom mirror
   5268  7fee				  -	      sta	4,x
   5269  7fee				  -	      tya
   5270  7fee				  -	      lsr
   5271  7fee				  -	      lsr
   5272  7fee				  -	      lsr
   5273  7fee				  -	      lsr
   5274  7fee				  -	      tax
   5275  7fee				  -	      inx
   5276  7fee					      endif
   5277  7fee
   5278  7fee				   BS_jsr
   5279  7fee		       bd f5 1f 	      lda	bankswitch_hotspot-1,x
   5280  7ff1		       68		      pla
   5281  7ff2		       aa		      tax
   5282  7ff3		       68		      pla
   5283  7ff4		       60		      rts
   5284  7ff5				  -	      if	((* & $1FFF) > ((bankswitch_hotspot & $1FFF) - 1))
   5285  7ff5				  -	      echo	"WARNING: size parameter in banksw.asm too small - the program probably will not work."
   5286  7ff5				  -	      echo	"Change to",[(*-begin_bscode+1)&$FF]d,"and try again."
   5287  7ff5					      endif
   5288  7ff5							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5289  7ff5
   5290  8000					      org	$8000
   5291  8000					      rorg	$1000
   5292  8000							; Provided under the CC0 license. See the included LICENSE.txt for details.
   5293  8000
   5294  8000							; 1K Frequency Table.
   5295  8000							; Fred Quimby, Darrell Spice Jr, Chris Walton 2010
   5296  8000							;
   5297  8000							; The 1K Frequency Table can contain up to 256 frequency values
   5298  8000							;
   5299  8000							; Table entries are defined as 2^32*freq/20000
   5300  8000							;
   5301  8000							; If User ARM code is being used, then the last 512 bytes of the frequency
   5302  8000							; table will no longer be available, reducing the number of frequencies you can
   5303  8000							; use to 128.
   5304  8000
   5305  8000							; piano key frequencies (s = sharp)
   5306  8000
   5307  8000				   .freq_table_start
   5308  8000
   5309  8000		       00 00 00 00	      DC.L	0
   5310  8000		       00 01	   A0	      =	(* & $3ff)/4
   5311  8004		       ac 1c 5a 00	      DC.L	5905580
   5312  8008
   5313  8008		       00 02	   A0s	      =	(* & $3ff)/4
   5314  8008		       68 78 5f 00	      DC.L	6256744
   5315  800c
   5316  800c		       00 03	   B0	      =	(* & $3ff)/4
   5317  800c		       b5 25 65 00	      DC.L	6628789
   5318  8010
   5319  8010		       00 04	   C1	      =	(* & $3ff)/4
   5320  8010		       6e 29 6b 00	      DC.L	7022958
   5321  8014
   5322  8014		       00 05	   C1s	      =	(* & $3ff)/4
   5323  8014		       b5 88 71 00	      DC.L	7440565
   5324  8018
   5325  8018		       00 06	   D1	      =	(* & $3ff)/4
   5326  8018		       fc 48 78 00	      DC.L	7883004
   5327  801c
   5328  801c		       00 07	   D1s	      =	(* & $3ff)/4
   5329  801c		       07 70 7f 00	      DC.L	8351751
   5330  8020
   5331  8020		       00 08	   E1	      =	(* & $3ff)/4
   5332  8020		       f4 03 87 00	      DC.L	8848372
   5333  8024
   5334  8024		       00 09	   F1	      =	(* & $3ff)/4
   5335  8024		       3c 0b 8f 00	      DC.L	9374524
   5336  8028
   5337  8028		       00 0a	   F1s	      =	(* & $3ff)/4
   5338  8028		       ba 8c 97 00	      DC.L	9931962
   5339  802c
   5340  802c		       00 0b	   G1	      =	(* & $3ff)/4
   5341  802c		       b3 8f a0 00	      DC.L	10522547
   5342  8030
   5343  8030		       00 0c	   G1s	      =	(* & $3ff)/4
   5344  8030		       db 1b aa 00	      DC.L	11148251
   5345  8034
   5346  8034		       00 0d	   A1	      =	(* & $3ff)/4
   5347  8034		       58 39 b4 00	      DC.L	11811160
   5348  8038
   5349  8038		       00 0e	   A1s	      =	(* & $3ff)/4
   5350  8038		       d0 f0 be 00	      DC.L	12513488
   5351  803c
   5352  803c		       00 0f	   B1	      =	(* & $3ff)/4
   5353  803c		       6b 4b ca 00	      DC.L	13257579
   5354  8040
   5355  8040		       00 10	   C2	      =	(* & $3ff)/4
   5356  8040		       dc 52 d6 00	      DC.L	14045916
   5357  8044
   5358  8044		       00 11	   C2s	      =	(* & $3ff)/4
   5359  8044		       69 11 e3 00	      DC.L	14881129
   5360  8048
   5361  8048		       00 12	   D2	      =	(* & $3ff)/4
   5362  8048		       f7 91 f0 00	      DC.L	15766007
   5363  804c
   5364  804c		       00 13	   D2s	      =	(* & $3ff)/4
   5365  804c		       0f e0 fe 00	      DC.L	16703503
   5366  8050
   5367  8050		       00 14	   E2	      =	(* & $3ff)/4
   5368  8050		       e9 07 0e 01	      DC.L	17696745
   5369  8054
   5370  8054		       00 15	   F2	      =	(* & $3ff)/4
   5371  8054		       78 16 1e 01	      DC.L	18749048
   5372  8058
   5373  8058		       00 16	   F2s	      =	(* & $3ff)/4
   5374  8058		       74 19 2f 01	      DC.L	19863924
   5375  805c
   5376  805c		       00 17	   G2	      =	(* & $3ff)/4
   5377  805c		       67 1f 41 01	      DC.L	21045095
   5378  8060
   5379  8060		       00 18	   G2s	      =	(* & $3ff)/4
   5380  8060		       b5 37 54 01	      DC.L	22296501
   5381  8064
   5382  8064		       00 19	   A2	      =	(* & $3ff)/4
   5383  8064		       b0 72 68 01	      DC.L	23622320
   5384  8068
   5385  8068		       00 1a	   A2s	      =	(* & $3ff)/4
   5386  8068		       a0 e1 7d 01	      DC.L	25026976
   5387  806c
   5388  806c		       00 1b	   B2	      =	(* & $3ff)/4
   5389  806c		       d6 96 94 01	      DC.L	26515158
   5390  8070
   5391  8070		       00 1c	   C3	      =	(* & $3ff)/4
   5392  8070		       b7 a5 ac 01	      DC.L	28091831
   5393  8074
   5394  8074		       00 1d	   C3s	      =	(* & $3ff)/4
   5395  8074		       d2 22 c6 01	      DC.L	29762258
   5396  8078
   5397  8078		       00 1e	   D3	      =	(* & $3ff)/4
   5398  8078		       ee 23 e1 01	      DC.L	31532014
   5399  807c
   5400  807c		       00 1f	   D3s	      =	(* & $3ff)/4
   5401  807c		       1d c0 fd 01	      DC.L	33407005
   5402  8080
   5403  8080		       00 20	   E3	      =	(* & $3ff)/4
   5404  8080		       d1 0f 1c 02	      DC.L	35393489
   5405  8084
   5406  8084		       00 21	   F3	      =	(* & $3ff)/4
   5407  8084		       f0 2c 3c 02	      DC.L	37498096
   5408  8088
   5409  8088		       00 22	   F3s	      =	(* & $3ff)/4
   5410  8088		       e9 32 5e 02	      DC.L	39727849
   5411  808c
   5412  808c		       00 23	   G3	      =	(* & $3ff)/4
   5413  808c		       cd 3e 82 02	      DC.L	42090189
   5414  8090
   5415  8090		       00 24	   G3s	      =	(* & $3ff)/4
   5416  8090		       6a 6f a8 02	      DC.L	44593002
   5417  8094
   5418  8094		       00 25	   A3	      =	(* & $3ff)/4
   5419  8094		       60 e5 d0 02	      DC.L	47244640
   5420  8098
   5421  8098		       00 26	   A3s	      =	(* & $3ff)/4
   5422  8098		       41 c3 fb 02	      DC.L	50053953
   5423  809c
   5424  809c		       00 27	   B3	      =	(* & $3ff)/4
   5425  809c		       ac 2d 29 03	      DC.L	53030316
   5426  80a0
   5427  80a0		       00 28	   C4	      =	(* & $3ff)/4
   5428  80a0		       6e 4b 59 03	      DC.L	56183662
   5429  80a4
   5430  80a4		       00 29	   C4s	      =	(* & $3ff)/4
   5431  80a4		       a5 45 8c 03	      DC.L	59524517
   5432  80a8
   5433  80a8		       00 2a	   D4	      =	(* & $3ff)/4
   5434  80a8		       dd 47 c2 03	      DC.L	63064029
   5435  80ac
   5436  80ac		       00 2b	   D4s	      =	(* & $3ff)/4
   5437  80ac		       3b 80 fb 03	      DC.L	66814011
   5438  80b0
   5439  80b0		       00 2c	   E4	      =	(* & $3ff)/4
   5440  80b0		       a3 1f 38 04	      DC.L	70786979
   5441  80b4
   5442  80b4		       00 2d	   F4	      =	(* & $3ff)/4
   5443  80b4		       e0 59 78 04	      DC.L	74996192
   5444  80b8
   5445  80b8		       00 2e	   F4s	      =	(* & $3ff)/4
   5446  80b8		       d1 65 bc 04	      DC.L	79455697
   5447  80bc
   5448  80bc		       00 2f	   G4	      =	(* & $3ff)/4
   5449  80bc		       9b 7d 04 05	      DC.L	84180379
   5450  80c0
   5451  80c0		       00 30	   G4s	      =	(* & $3ff)/4
   5452  80c0		       d5 de 50 05	      DC.L	89186005
   5453  80c4
   5454  80c4		       00 31	   A4	      =	(* & $3ff)/4
   5455  80c4		       c1 ca a1 05	      DC.L	94489281
   5456  80c8
   5457  80c8		       00 32	   A4s	      =	(* & $3ff)/4
   5458  80c8		       82 86 f7 05	      DC.L	100107906
   5459  80cc
   5460  80cc		       00 33	   B4	      =	(* & $3ff)/4
   5461  80cc		       57 5b 52 06	      DC.L	106060631
   5462  80d0
   5463  80d0		       00 34	   C5	      =	(* & $3ff)/4
   5464  80d0		       dd 96 b2 06	      DC.L	112367325
   5465  80d4
   5466  80d4		       00 35	   C5s	      =	(* & $3ff)/4
   5467  80d4		       4a 8b 18 07	      DC.L	119049034
   5468  80d8
   5469  80d8		       00 36	   D5	      =	(* & $3ff)/4
   5470  80d8		       b9 8f 84 07	      DC.L	126128057
   5471  80dc
   5472  80dc		       00 37	   D5s	      =	(* & $3ff)/4
   5473  80dc		       76 00 f7 07	      DC.L	133628022
   5474  80e0
   5475  80e0		       00 38	   E5	      =	(* & $3ff)/4
   5476  80e0		       46 3f 70 08	      DC.L	141573958
   5477  80e4
   5478  80e4		       00 39	   F5	      =	(* & $3ff)/4
   5479  80e4		       bf b3 f0 08	      DC.L	149992383
   5480  80e8
   5481  80e8		       00 3a	   F5s	      =	(* & $3ff)/4
   5482  80e8		       a3 cb 78 09	      DC.L	158911395
   5483  80ec
   5484  80ec		       00 3b	   G5	      =	(* & $3ff)/4
   5485  80ec		       36 fb 08 0a	      DC.L	168360758
   5486  80f0
   5487  80f0		       00 3c	   G5s	      =	(* & $3ff)/4
   5488  80f0		       a9 bd a1 0a	      DC.L	178372009
   5489  80f4
   5490  80f4		       00 3d	   A5	      =	(* & $3ff)/4
   5491  80f4		       81 95 43 0b	      DC.L	188978561
   5492  80f8
   5493  80f8		       00 3e	   A5s	      =	(* & $3ff)/4
   5494  80f8		       03 0d ef 0b	      DC.L	200215811
   5495  80fc
   5496  80fc		       00 3f	   B5	      =	(* & $3ff)/4
   5497  80fc		       af b6 a4 0c	      DC.L	212121263
   5498  8100
   5499  8100		       00 40	   C6	      =	(* & $3ff)/4
   5500  8100		       b9 2d 65 0d	      DC.L	224734649
   5501  8104
   5502  8104		       00 41	   C6s	      =	(* & $3ff)/4
   5503  8104		       93 16 31 0e	      DC.L	238098067
   5504  8108
   5505  8108		       00 42	   D6	      =	(* & $3ff)/4
   5506  8108		       73 1f 09 0f	      DC.L	252256115
   5507  810c
   5508  810c		       00 43	   D6s	      =	(* & $3ff)/4
   5509  810c		       ec 00 ee 0f	      DC.L	267256044
   5510  8110
   5511  8110		       00 44	   E6	      =	(* & $3ff)/4
   5512  8110		       8b 7e e0 10	      DC.L	283147915
   5513  8114
   5514  8114		       00 45	   F6	      =	(* & $3ff)/4
   5515  8114		       7f 67 e1 11	      DC.L	299984767
   5516  8118
   5517  8118		       00 46	   F6s	      =	(* & $3ff)/4
   5518  8118		       45 97 f1 12	      DC.L	317822789
   5519  811c
   5520  811c		       00 47	   G6	      =	(* & $3ff)/4
   5521  811c		       6c f6 11 14	      DC.L	336721516
   5522  8120
   5523  8120		       00 48	   G6s	      =	(* & $3ff)/4
   5524  8120		       53 7b 43 15	      DC.L	356744019
   5525  8124
   5526  8124		       00 49	   A6	      =	(* & $3ff)/4
   5527  8124		       02 2b 87 16	      DC.L	377957122
   5528  8128
   5529  8128		       00 4a	   A6s	      =	(* & $3ff)/4
   5530  8128		       06 1a de 17	      DC.L	400431622
   5531  812c
   5532  812c		       00 4b	   B6	      =	(* & $3ff)/4
   5533  812c		       5d 6d 49 19	      DC.L	424242525
   5534  8130
   5535  8130		       00 4c	   C7	      =	(* & $3ff)/4
   5536  8130		       73 5b ca 1a	      DC.L	449469299
   5537  8134
   5538  8134		       00 4d	   C7s	      =	(* & $3ff)/4
   5539  8134		       26 2d 62 1c	      DC.L	476196134
   5540  8138
   5541  8138		       00 4e	   D7	      =	(* & $3ff)/4
   5542  8138		       e6 3e 12 1e	      DC.L	504512230
   5543  813c
   5544  813c		       00 4f	   D7s	      =	(* & $3ff)/4
   5545  813c		       d8 01 dc 1f	      DC.L	534512088
   5546  8140
   5547  8140		       00 50	   E7	      =	(* & $3ff)/4
   5548  8140		       17 fd c0 21	      DC.L	566295831
   5549  8144
   5550  8144		       00 51	   F7	      =	(* & $3ff)/4
   5551  8144		       fd ce c2 23	      DC.L	599969533
   5552  8148
   5553  8148		       00 52	   F7s	      =	(* & $3ff)/4
   5554  8148		       8a 2e e3 25	      DC.L	635645578
   5555  814c
   5556  814c		       00 53	   G7	      =	(* & $3ff)/4
   5557  814c		       d7 ec 23 28	      DC.L	673443031
   5558  8150
   5559  8150		       00 54	   G7s	      =	(* & $3ff)/4
   5560  8150		       a6 f6 86 2a	      DC.L	713488038
   5561  8154
   5562  8154		       00 55	   A7	      =	(* & $3ff)/4
   5563  8154		       04 56 0e 2d	      DC.L	755914244
   5564  8158
   5565  8158		       00 56	   A7s	      =	(* & $3ff)/4
   5566  8158		       0c 34 bc 2f	      DC.L	800863244
   5567  815c
   5568  815c		       00 57	   B7	      =	(* & $3ff)/4
   5569  815c		       bb da 92 32	      DC.L	848485051
   5570  8160
   5571  8160		       00 58	   C8	      =	(* & $3ff)/4
   5572  8160		       e5 b6 94 35	      DC.L	898938597
   5573  8164
   5574  8164							;values for 89-255 may go here 
   5575  8164
   5576  8164					      if	(* <= $1400)
   5577  8164		       00 00 00 00*	      ds	($1400-*)	; pad out remaining space in frequency table
   5578  8400				  -	      else
   5579  8400				  -	      echo	"FATAL ERROR - Frequency table exceeds 1K"
   5580  8400				  -	      err
   5581  8400					      endif
